
FreeRTOS_SecureIOToggle_TrustZone_Secure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  0c000000  0c000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000063e0  0c0001f8  0c0001f8  000011f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000007e8  0c0065d8  0c0065d8  000075d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0c006dc0  0c006dc0  000090c0  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  0c006dc0  0c006dc0  00007dc0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0c006dc8  0c006dc8  000090c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0c006dc8  0c006dc8  00007dc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000008  0c006dd0  0c006dd0  00007dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         000000a0  30000000  0c006dd8  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .gnu.sgstubs  000000c0  0c03e000  0c03e000  00009000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .bss          00002d88  300000a0  300000a0  0000a0a0  2**2
                  ALLOC
 11 .gnu.linkonce.b._ns_work_buffer 00000100  30002e28  30002e28  0000a0a0  2**3
                  ALLOC, LINK_ONCE_DISCARD
 12 ._user_heap_stack 00000600  30002f28  30002f28  0000a0a0  2**0
                  ALLOC
 13 .ARM.attributes 00000036  00000000  00000000  000090c0  2**0
                  CONTENTS, READONLY
 14 .debug_line   0001058c  00000000  00000000  000090f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line_str 000000ae  00000000  00000000  00019682  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_info   0000c70c  00000000  00000000  00019730  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00002bec  00000000  00000000  00025e3c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00000d30  00000000  00000000  00028a28  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00110ff6  00000000  00000000  00029758  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_rnglists 000009d2  00000000  00000000  0013a74e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0002b458  00000000  00000000  0013b120  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .comment      00000043  00000000  00000000  00166578  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00003e78  00000000  00000000  001665bc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0c0001f8 <__do_global_dtors_aux>:
 c0001f8:	b510      	push	{r4, lr}
 c0001fa:	4c05      	ldr	r4, [pc, #20]	@ (c000210 <__do_global_dtors_aux+0x18>)
 c0001fc:	7823      	ldrb	r3, [r4, #0]
 c0001fe:	b933      	cbnz	r3, c00020e <__do_global_dtors_aux+0x16>
 c000200:	4b04      	ldr	r3, [pc, #16]	@ (c000214 <__do_global_dtors_aux+0x1c>)
 c000202:	b113      	cbz	r3, c00020a <__do_global_dtors_aux+0x12>
 c000204:	4804      	ldr	r0, [pc, #16]	@ (c000218 <__do_global_dtors_aux+0x20>)
 c000206:	f3af 8000 	nop.w
 c00020a:	2301      	movs	r3, #1
 c00020c:	7023      	strb	r3, [r4, #0]
 c00020e:	bd10      	pop	{r4, pc}
 c000210:	300000a0 	.word	0x300000a0
 c000214:	00000000 	.word	0x00000000
 c000218:	0c0065bc 	.word	0x0c0065bc

0c00021c <frame_dummy>:
 c00021c:	b508      	push	{r3, lr}
 c00021e:	4b03      	ldr	r3, [pc, #12]	@ (c00022c <frame_dummy+0x10>)
 c000220:	b11b      	cbz	r3, c00022a <frame_dummy+0xe>
 c000222:	4903      	ldr	r1, [pc, #12]	@ (c000230 <frame_dummy+0x14>)
 c000224:	4803      	ldr	r0, [pc, #12]	@ (c000234 <frame_dummy+0x18>)
 c000226:	f3af 8000 	nop.w
 c00022a:	bd08      	pop	{r3, pc}
 c00022c:	00000000 	.word	0x00000000
 c000230:	300000a4 	.word	0x300000a4
 c000234:	0c0065bc 	.word	0x0c0065bc

0c000238 <strlen>:
 c000238:	4603      	mov	r3, r0
 c00023a:	f813 2b01 	ldrb.w	r2, [r3], #1
 c00023e:	2a00      	cmp	r2, #0
 c000240:	d1fb      	bne.n	c00023a <strlen+0x2>
 c000242:	1a18      	subs	r0, r3, r0
 c000244:	3801      	subs	r0, #1
 c000246:	4770      	bx	lr

0c000248 <__gnu_cmse_nonsecure_call>:
 c000248:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
 c00024c:	4627      	mov	r7, r4
 c00024e:	46a0      	mov	r8, r4
 c000250:	46a1      	mov	r9, r4
 c000252:	46a2      	mov	sl, r4
 c000254:	46a3      	mov	fp, r4
 c000256:	46a4      	mov	ip, r4
 c000258:	ed2d 8b10 	vpush	{d8-d15}
 c00025c:	f04f 0500 	mov.w	r5, #0
 c000260:	ec45 5b18 	vmov	d8, r5, r5
 c000264:	ec45 5a19 	vmov	s18, s19, r5, r5
 c000268:	ec45 5a1a 	vmov	s20, s21, r5, r5
 c00026c:	ec45 5a1b 	vmov	s22, s23, r5, r5
 c000270:	ec45 5a1c 	vmov	s24, s25, r5, r5
 c000274:	ec45 5a1d 	vmov	s26, s27, r5, r5
 c000278:	ec45 5a1e 	vmov	s28, s29, r5, r5
 c00027c:	ec45 5a1f 	vmov	s30, s31, r5, r5
 c000280:	eef1 5a10 	vmrs	r5, fpscr
 c000284:	f64f 7660 	movw	r6, #65376	@ 0xff60
 c000288:	f6c0 76ff 	movt	r6, #4095	@ 0xfff
 c00028c:	4035      	ands	r5, r6
 c00028e:	eee1 5a10 	vmsr	fpscr, r5
 c000292:	f384 8800 	msr	CPSR_f, r4
 c000296:	4625      	mov	r5, r4
 c000298:	4626      	mov	r6, r4
 c00029a:	47a4      	blxns	r4
 c00029c:	ecbd 8b10 	vpop	{d8-d15}
 c0002a0:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0c0002a4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
Reset_Handler:

  ldr   sp, =_estack    /* set stack pointer */
 c0002a4:	f8df d034 	ldr.w	sp, [pc, #52]	@ c0002dc <LoopForever+0x2>
	.type	Reset_Handler, %function

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 c0002a8:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 c0002aa:	e003      	b.n	c0002b4 <LoopCopyDataInit>

0c0002ac <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 c0002ac:	4b0c      	ldr	r3, [pc, #48]	@ (c0002e0 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 c0002ae:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 c0002b0:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 c0002b2:	3104      	adds	r1, #4

0c0002b4 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 c0002b4:	480b      	ldr	r0, [pc, #44]	@ (c0002e4 <LoopForever+0xa>)
	ldr	r3, =_edata
 c0002b6:	4b0c      	ldr	r3, [pc, #48]	@ (c0002e8 <LoopForever+0xe>)
	adds	r2, r0, r1
 c0002b8:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 c0002ba:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 c0002bc:	d3f6      	bcc.n	c0002ac <CopyDataInit>
	ldr	r2, =_sbss
 c0002be:	4a0b      	ldr	r2, [pc, #44]	@ (c0002ec <LoopForever+0x12>)
	b	LoopFillZerobss
 c0002c0:	e002      	b.n	c0002c8 <LoopFillZerobss>

0c0002c2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 c0002c2:	2300      	movs	r3, #0
	str	r3, [r2], #4
 c0002c4:	f842 3b04 	str.w	r3, [r2], #4

0c0002c8 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 c0002c8:	4b09      	ldr	r3, [pc, #36]	@ (c0002f0 <LoopForever+0x16>)
	cmp	r2, r3
 c0002ca:	429a      	cmp	r2, r3
	bcc	FillZerobss
 c0002cc:	d3f9      	bcc.n	c0002c2 <FillZerobss>

/* Call the clock system initialization function.*/
    bl  SystemInit
 c0002ce:	f003 fb85 	bl	c0039dc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 c0002d2:	f005 fc69 	bl	c005ba8 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 c0002d6:	f000 ffff 	bl	c0012d8 <main>

0c0002da <LoopForever>:

LoopForever:
    b LoopForever
 c0002da:	e7fe      	b.n	c0002da <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 c0002dc:	30018000 	.word	0x30018000
	ldr	r3, =_sidata
 c0002e0:	0c006dd8 	.word	0x0c006dd8
	ldr	r0, =_sdata
 c0002e4:	30000000 	.word	0x30000000
	ldr	r3, =_edata
 c0002e8:	300000a0 	.word	0x300000a0
	ldr	r2, =_sbss
 c0002ec:	300000a0 	.word	0x300000a0
	ldr	r3, = _ebss
 c0002f0:	30002e28 	.word	0x30002e28

0c0002f4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 c0002f4:	e7fe      	b.n	c0002f4 <ADC1_2_IRQHandler>
	...

0c0002f8 <KeyExpansion>:
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states.
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
 c0002f8:	b480      	push	{r7}
 c0002fa:	b089      	sub	sp, #36	@ 0x24
 c0002fc:	af00      	add	r7, sp, #0
 c0002fe:	6078      	str	r0, [r7, #4]
 c000300:	6039      	str	r1, [r7, #0]
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations

  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
 c000302:	2300      	movs	r3, #0
 c000304:	61fb      	str	r3, [r7, #28]
 c000306:	e030      	b.n	c00036a <KeyExpansion+0x72>
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
 c000308:	69fb      	ldr	r3, [r7, #28]
 c00030a:	009b      	lsls	r3, r3, #2
 c00030c:	683a      	ldr	r2, [r7, #0]
 c00030e:	441a      	add	r2, r3
 c000310:	69fb      	ldr	r3, [r7, #28]
 c000312:	009b      	lsls	r3, r3, #2
 c000314:	6879      	ldr	r1, [r7, #4]
 c000316:	440b      	add	r3, r1
 c000318:	7812      	ldrb	r2, [r2, #0]
 c00031a:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
 c00031c:	69fb      	ldr	r3, [r7, #28]
 c00031e:	009b      	lsls	r3, r3, #2
 c000320:	3301      	adds	r3, #1
 c000322:	683a      	ldr	r2, [r7, #0]
 c000324:	441a      	add	r2, r3
 c000326:	69fb      	ldr	r3, [r7, #28]
 c000328:	009b      	lsls	r3, r3, #2
 c00032a:	3301      	adds	r3, #1
 c00032c:	6879      	ldr	r1, [r7, #4]
 c00032e:	440b      	add	r3, r1
 c000330:	7812      	ldrb	r2, [r2, #0]
 c000332:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
 c000334:	69fb      	ldr	r3, [r7, #28]
 c000336:	009b      	lsls	r3, r3, #2
 c000338:	3302      	adds	r3, #2
 c00033a:	683a      	ldr	r2, [r7, #0]
 c00033c:	441a      	add	r2, r3
 c00033e:	69fb      	ldr	r3, [r7, #28]
 c000340:	009b      	lsls	r3, r3, #2
 c000342:	3302      	adds	r3, #2
 c000344:	6879      	ldr	r1, [r7, #4]
 c000346:	440b      	add	r3, r1
 c000348:	7812      	ldrb	r2, [r2, #0]
 c00034a:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
 c00034c:	69fb      	ldr	r3, [r7, #28]
 c00034e:	009b      	lsls	r3, r3, #2
 c000350:	3303      	adds	r3, #3
 c000352:	683a      	ldr	r2, [r7, #0]
 c000354:	441a      	add	r2, r3
 c000356:	69fb      	ldr	r3, [r7, #28]
 c000358:	009b      	lsls	r3, r3, #2
 c00035a:	3303      	adds	r3, #3
 c00035c:	6879      	ldr	r1, [r7, #4]
 c00035e:	440b      	add	r3, r1
 c000360:	7812      	ldrb	r2, [r2, #0]
 c000362:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < Nk; ++i)
 c000364:	69fb      	ldr	r3, [r7, #28]
 c000366:	3301      	adds	r3, #1
 c000368:	61fb      	str	r3, [r7, #28]
 c00036a:	69fb      	ldr	r3, [r7, #28]
 c00036c:	2b03      	cmp	r3, #3
 c00036e:	d9cb      	bls.n	c000308 <KeyExpansion+0x10>
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
 c000370:	2304      	movs	r3, #4
 c000372:	61fb      	str	r3, [r7, #28]
 c000374:	e081      	b.n	c00047a <KeyExpansion+0x182>
  {
    {
      k = (i - 1) * 4;
 c000376:	69fb      	ldr	r3, [r7, #28]
 c000378:	3b01      	subs	r3, #1
 c00037a:	009b      	lsls	r3, r3, #2
 c00037c:	61bb      	str	r3, [r7, #24]
      tempa[0]=RoundKey[k + 0];
 c00037e:	687a      	ldr	r2, [r7, #4]
 c000380:	69bb      	ldr	r3, [r7, #24]
 c000382:	4413      	add	r3, r2
 c000384:	781b      	ldrb	r3, [r3, #0]
 c000386:	733b      	strb	r3, [r7, #12]
      tempa[1]=RoundKey[k + 1];
 c000388:	69bb      	ldr	r3, [r7, #24]
 c00038a:	3301      	adds	r3, #1
 c00038c:	687a      	ldr	r2, [r7, #4]
 c00038e:	4413      	add	r3, r2
 c000390:	781b      	ldrb	r3, [r3, #0]
 c000392:	737b      	strb	r3, [r7, #13]
      tempa[2]=RoundKey[k + 2];
 c000394:	69bb      	ldr	r3, [r7, #24]
 c000396:	3302      	adds	r3, #2
 c000398:	687a      	ldr	r2, [r7, #4]
 c00039a:	4413      	add	r3, r2
 c00039c:	781b      	ldrb	r3, [r3, #0]
 c00039e:	73bb      	strb	r3, [r7, #14]
      tempa[3]=RoundKey[k + 3];
 c0003a0:	69bb      	ldr	r3, [r7, #24]
 c0003a2:	3303      	adds	r3, #3
 c0003a4:	687a      	ldr	r2, [r7, #4]
 c0003a6:	4413      	add	r3, r2
 c0003a8:	781b      	ldrb	r3, [r3, #0]
 c0003aa:	73fb      	strb	r3, [r7, #15]

    }

    if (i % Nk == 0)
 c0003ac:	69fb      	ldr	r3, [r7, #28]
 c0003ae:	f003 0303 	and.w	r3, r3, #3
 c0003b2:	2b00      	cmp	r3, #0
 c0003b4:	d125      	bne.n	c000402 <KeyExpansion+0x10a>
      // This function shifts the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        const uint8_t u8tmp = tempa[0];
 c0003b6:	7b3b      	ldrb	r3, [r7, #12]
 c0003b8:	75fb      	strb	r3, [r7, #23]
        tempa[0] = tempa[1];
 c0003ba:	7b7b      	ldrb	r3, [r7, #13]
 c0003bc:	733b      	strb	r3, [r7, #12]
        tempa[1] = tempa[2];
 c0003be:	7bbb      	ldrb	r3, [r7, #14]
 c0003c0:	737b      	strb	r3, [r7, #13]
        tempa[2] = tempa[3];
 c0003c2:	7bfb      	ldrb	r3, [r7, #15]
 c0003c4:	73bb      	strb	r3, [r7, #14]
        tempa[3] = u8tmp;
 c0003c6:	7dfb      	ldrb	r3, [r7, #23]
 c0003c8:	73fb      	strb	r3, [r7, #15]
      // SubWord() is a function that takes a four-byte input word and
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
 c0003ca:	7b3b      	ldrb	r3, [r7, #12]
 c0003cc:	461a      	mov	r2, r3
 c0003ce:	4b30      	ldr	r3, [pc, #192]	@ (c000490 <KeyExpansion+0x198>)
 c0003d0:	5c9b      	ldrb	r3, [r3, r2]
 c0003d2:	733b      	strb	r3, [r7, #12]
        tempa[1] = getSBoxValue(tempa[1]);
 c0003d4:	7b7b      	ldrb	r3, [r7, #13]
 c0003d6:	461a      	mov	r2, r3
 c0003d8:	4b2d      	ldr	r3, [pc, #180]	@ (c000490 <KeyExpansion+0x198>)
 c0003da:	5c9b      	ldrb	r3, [r3, r2]
 c0003dc:	737b      	strb	r3, [r7, #13]
        tempa[2] = getSBoxValue(tempa[2]);
 c0003de:	7bbb      	ldrb	r3, [r7, #14]
 c0003e0:	461a      	mov	r2, r3
 c0003e2:	4b2b      	ldr	r3, [pc, #172]	@ (c000490 <KeyExpansion+0x198>)
 c0003e4:	5c9b      	ldrb	r3, [r3, r2]
 c0003e6:	73bb      	strb	r3, [r7, #14]
        tempa[3] = getSBoxValue(tempa[3]);
 c0003e8:	7bfb      	ldrb	r3, [r7, #15]
 c0003ea:	461a      	mov	r2, r3
 c0003ec:	4b28      	ldr	r3, [pc, #160]	@ (c000490 <KeyExpansion+0x198>)
 c0003ee:	5c9b      	ldrb	r3, [r3, r2]
 c0003f0:	73fb      	strb	r3, [r7, #15]
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
 c0003f2:	7b3a      	ldrb	r2, [r7, #12]
 c0003f4:	69fb      	ldr	r3, [r7, #28]
 c0003f6:	089b      	lsrs	r3, r3, #2
 c0003f8:	4926      	ldr	r1, [pc, #152]	@ (c000494 <KeyExpansion+0x19c>)
 c0003fa:	5ccb      	ldrb	r3, [r1, r3]
 c0003fc:	4053      	eors	r3, r2
 c0003fe:	b2db      	uxtb	r3, r3
 c000400:	733b      	strb	r3, [r7, #12]
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
 c000402:	69fb      	ldr	r3, [r7, #28]
 c000404:	009b      	lsls	r3, r3, #2
 c000406:	613b      	str	r3, [r7, #16]
 c000408:	69fb      	ldr	r3, [r7, #28]
 c00040a:	3b04      	subs	r3, #4
 c00040c:	009b      	lsls	r3, r3, #2
 c00040e:	61bb      	str	r3, [r7, #24]
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
 c000410:	687a      	ldr	r2, [r7, #4]
 c000412:	69bb      	ldr	r3, [r7, #24]
 c000414:	4413      	add	r3, r2
 c000416:	7819      	ldrb	r1, [r3, #0]
 c000418:	7b3a      	ldrb	r2, [r7, #12]
 c00041a:	6878      	ldr	r0, [r7, #4]
 c00041c:	693b      	ldr	r3, [r7, #16]
 c00041e:	4403      	add	r3, r0
 c000420:	404a      	eors	r2, r1
 c000422:	b2d2      	uxtb	r2, r2
 c000424:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
 c000426:	69bb      	ldr	r3, [r7, #24]
 c000428:	3301      	adds	r3, #1
 c00042a:	687a      	ldr	r2, [r7, #4]
 c00042c:	4413      	add	r3, r2
 c00042e:	7819      	ldrb	r1, [r3, #0]
 c000430:	7b7a      	ldrb	r2, [r7, #13]
 c000432:	693b      	ldr	r3, [r7, #16]
 c000434:	3301      	adds	r3, #1
 c000436:	6878      	ldr	r0, [r7, #4]
 c000438:	4403      	add	r3, r0
 c00043a:	404a      	eors	r2, r1
 c00043c:	b2d2      	uxtb	r2, r2
 c00043e:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
 c000440:	69bb      	ldr	r3, [r7, #24]
 c000442:	3302      	adds	r3, #2
 c000444:	687a      	ldr	r2, [r7, #4]
 c000446:	4413      	add	r3, r2
 c000448:	7819      	ldrb	r1, [r3, #0]
 c00044a:	7bba      	ldrb	r2, [r7, #14]
 c00044c:	693b      	ldr	r3, [r7, #16]
 c00044e:	3302      	adds	r3, #2
 c000450:	6878      	ldr	r0, [r7, #4]
 c000452:	4403      	add	r3, r0
 c000454:	404a      	eors	r2, r1
 c000456:	b2d2      	uxtb	r2, r2
 c000458:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
 c00045a:	69bb      	ldr	r3, [r7, #24]
 c00045c:	3303      	adds	r3, #3
 c00045e:	687a      	ldr	r2, [r7, #4]
 c000460:	4413      	add	r3, r2
 c000462:	7819      	ldrb	r1, [r3, #0]
 c000464:	7bfa      	ldrb	r2, [r7, #15]
 c000466:	693b      	ldr	r3, [r7, #16]
 c000468:	3303      	adds	r3, #3
 c00046a:	6878      	ldr	r0, [r7, #4]
 c00046c:	4403      	add	r3, r0
 c00046e:	404a      	eors	r2, r1
 c000470:	b2d2      	uxtb	r2, r2
 c000472:	701a      	strb	r2, [r3, #0]
  for (i = Nk; i < Nb * (Nr + 1); ++i)
 c000474:	69fb      	ldr	r3, [r7, #28]
 c000476:	3301      	adds	r3, #1
 c000478:	61fb      	str	r3, [r7, #28]
 c00047a:	69fb      	ldr	r3, [r7, #28]
 c00047c:	2b2b      	cmp	r3, #43	@ 0x2b
 c00047e:	f67f af7a 	bls.w	c000376 <KeyExpansion+0x7e>
  }
}
 c000482:	bf00      	nop
 c000484:	bf00      	nop
 c000486:	3724      	adds	r7, #36	@ 0x24
 c000488:	46bd      	mov	sp, r7
 c00048a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00048e:	4770      	bx	lr
 c000490:	0c006b64 	.word	0x0c006b64
 c000494:	0c006c64 	.word	0x0c006c64

0c000498 <AES_init_ctx_iv>:
{
  KeyExpansion(ctx->RoundKey, key);
}
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
{
 c000498:	b580      	push	{r7, lr}
 c00049a:	b084      	sub	sp, #16
 c00049c:	af00      	add	r7, sp, #0
 c00049e:	60f8      	str	r0, [r7, #12]
 c0004a0:	60b9      	str	r1, [r7, #8]
 c0004a2:	607a      	str	r2, [r7, #4]
  KeyExpansion(ctx->RoundKey, key);
 c0004a4:	68fb      	ldr	r3, [r7, #12]
 c0004a6:	68b9      	ldr	r1, [r7, #8]
 c0004a8:	4618      	mov	r0, r3
 c0004aa:	f7ff ff25 	bl	c0002f8 <KeyExpansion>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
 c0004ae:	68fb      	ldr	r3, [r7, #12]
 c0004b0:	33b0      	adds	r3, #176	@ 0xb0
 c0004b2:	2210      	movs	r2, #16
 c0004b4:	6879      	ldr	r1, [r7, #4]
 c0004b6:	4618      	mov	r0, r3
 c0004b8:	f005 fb9d 	bl	c005bf6 <memcpy>
}
 c0004bc:	bf00      	nop
 c0004be:	3710      	adds	r7, #16
 c0004c0:	46bd      	mov	sp, r7
 c0004c2:	bd80      	pop	{r7, pc}

0c0004c4 <AddRoundKey>:
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
 c0004c4:	b480      	push	{r7}
 c0004c6:	b087      	sub	sp, #28
 c0004c8:	af00      	add	r7, sp, #0
 c0004ca:	4603      	mov	r3, r0
 c0004cc:	60b9      	str	r1, [r7, #8]
 c0004ce:	607a      	str	r2, [r7, #4]
 c0004d0:	73fb      	strb	r3, [r7, #15]
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
 c0004d2:	2300      	movs	r3, #0
 c0004d4:	75fb      	strb	r3, [r7, #23]
 c0004d6:	e027      	b.n	c000528 <AddRoundKey+0x64>
  {
    for (j = 0; j < 4; ++j)
 c0004d8:	2300      	movs	r3, #0
 c0004da:	75bb      	strb	r3, [r7, #22]
 c0004dc:	e01e      	b.n	c00051c <AddRoundKey+0x58>
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
 c0004de:	7dfa      	ldrb	r2, [r7, #23]
 c0004e0:	7dbb      	ldrb	r3, [r7, #22]
 c0004e2:	68b9      	ldr	r1, [r7, #8]
 c0004e4:	0092      	lsls	r2, r2, #2
 c0004e6:	440a      	add	r2, r1
 c0004e8:	4413      	add	r3, r2
 c0004ea:	7818      	ldrb	r0, [r3, #0]
 c0004ec:	7bfb      	ldrb	r3, [r7, #15]
 c0004ee:	009a      	lsls	r2, r3, #2
 c0004f0:	7dfb      	ldrb	r3, [r7, #23]
 c0004f2:	4413      	add	r3, r2
 c0004f4:	009a      	lsls	r2, r3, #2
 c0004f6:	7dbb      	ldrb	r3, [r7, #22]
 c0004f8:	4413      	add	r3, r2
 c0004fa:	461a      	mov	r2, r3
 c0004fc:	687b      	ldr	r3, [r7, #4]
 c0004fe:	4413      	add	r3, r2
 c000500:	7819      	ldrb	r1, [r3, #0]
 c000502:	7dfa      	ldrb	r2, [r7, #23]
 c000504:	7dbb      	ldrb	r3, [r7, #22]
 c000506:	4041      	eors	r1, r0
 c000508:	b2c8      	uxtb	r0, r1
 c00050a:	68b9      	ldr	r1, [r7, #8]
 c00050c:	0092      	lsls	r2, r2, #2
 c00050e:	440a      	add	r2, r1
 c000510:	4413      	add	r3, r2
 c000512:	4602      	mov	r2, r0
 c000514:	701a      	strb	r2, [r3, #0]
    for (j = 0; j < 4; ++j)
 c000516:	7dbb      	ldrb	r3, [r7, #22]
 c000518:	3301      	adds	r3, #1
 c00051a:	75bb      	strb	r3, [r7, #22]
 c00051c:	7dbb      	ldrb	r3, [r7, #22]
 c00051e:	2b03      	cmp	r3, #3
 c000520:	d9dd      	bls.n	c0004de <AddRoundKey+0x1a>
  for (i = 0; i < 4; ++i)
 c000522:	7dfb      	ldrb	r3, [r7, #23]
 c000524:	3301      	adds	r3, #1
 c000526:	75fb      	strb	r3, [r7, #23]
 c000528:	7dfb      	ldrb	r3, [r7, #23]
 c00052a:	2b03      	cmp	r3, #3
 c00052c:	d9d4      	bls.n	c0004d8 <AddRoundKey+0x14>
    }
  }
}
 c00052e:	bf00      	nop
 c000530:	bf00      	nop
 c000532:	371c      	adds	r7, #28
 c000534:	46bd      	mov	sp, r7
 c000536:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00053a:	4770      	bx	lr

0c00053c <SubBytes>:

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
 c00053c:	b480      	push	{r7}
 c00053e:	b085      	sub	sp, #20
 c000540:	af00      	add	r7, sp, #0
 c000542:	6078      	str	r0, [r7, #4]
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
 c000544:	2300      	movs	r3, #0
 c000546:	73fb      	strb	r3, [r7, #15]
 c000548:	e01d      	b.n	c000586 <SubBytes+0x4a>
  {
    for (j = 0; j < 4; ++j)
 c00054a:	2300      	movs	r3, #0
 c00054c:	73bb      	strb	r3, [r7, #14]
 c00054e:	e014      	b.n	c00057a <SubBytes+0x3e>
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
 c000550:	7bba      	ldrb	r2, [r7, #14]
 c000552:	7bfb      	ldrb	r3, [r7, #15]
 c000554:	6879      	ldr	r1, [r7, #4]
 c000556:	0092      	lsls	r2, r2, #2
 c000558:	440a      	add	r2, r1
 c00055a:	4413      	add	r3, r2
 c00055c:	781b      	ldrb	r3, [r3, #0]
 c00055e:	4618      	mov	r0, r3
 c000560:	7bba      	ldrb	r2, [r7, #14]
 c000562:	7bfb      	ldrb	r3, [r7, #15]
 c000564:	490d      	ldr	r1, [pc, #52]	@ (c00059c <SubBytes+0x60>)
 c000566:	5c08      	ldrb	r0, [r1, r0]
 c000568:	6879      	ldr	r1, [r7, #4]
 c00056a:	0092      	lsls	r2, r2, #2
 c00056c:	440a      	add	r2, r1
 c00056e:	4413      	add	r3, r2
 c000570:	4602      	mov	r2, r0
 c000572:	701a      	strb	r2, [r3, #0]
    for (j = 0; j < 4; ++j)
 c000574:	7bbb      	ldrb	r3, [r7, #14]
 c000576:	3301      	adds	r3, #1
 c000578:	73bb      	strb	r3, [r7, #14]
 c00057a:	7bbb      	ldrb	r3, [r7, #14]
 c00057c:	2b03      	cmp	r3, #3
 c00057e:	d9e7      	bls.n	c000550 <SubBytes+0x14>
  for (i = 0; i < 4; ++i)
 c000580:	7bfb      	ldrb	r3, [r7, #15]
 c000582:	3301      	adds	r3, #1
 c000584:	73fb      	strb	r3, [r7, #15]
 c000586:	7bfb      	ldrb	r3, [r7, #15]
 c000588:	2b03      	cmp	r3, #3
 c00058a:	d9de      	bls.n	c00054a <SubBytes+0xe>
    }
  }
}
 c00058c:	bf00      	nop
 c00058e:	bf00      	nop
 c000590:	3714      	adds	r7, #20
 c000592:	46bd      	mov	sp, r7
 c000594:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000598:	4770      	bx	lr
 c00059a:	bf00      	nop
 c00059c:	0c006b64 	.word	0x0c006b64

0c0005a0 <ShiftRows>:

// The ShiftRows() function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
static void ShiftRows(state_t* state)
{
 c0005a0:	b480      	push	{r7}
 c0005a2:	b085      	sub	sp, #20
 c0005a4:	af00      	add	r7, sp, #0
 c0005a6:	6078      	str	r0, [r7, #4]
  uint8_t temp;

  // Rotate first row 1 columns to left
  temp           = (*state)[0][1];
 c0005a8:	687b      	ldr	r3, [r7, #4]
 c0005aa:	785b      	ldrb	r3, [r3, #1]
 c0005ac:	73fb      	strb	r3, [r7, #15]
  (*state)[0][1] = (*state)[1][1];
 c0005ae:	687b      	ldr	r3, [r7, #4]
 c0005b0:	795a      	ldrb	r2, [r3, #5]
 c0005b2:	687b      	ldr	r3, [r7, #4]
 c0005b4:	705a      	strb	r2, [r3, #1]
  (*state)[1][1] = (*state)[2][1];
 c0005b6:	687b      	ldr	r3, [r7, #4]
 c0005b8:	7a5a      	ldrb	r2, [r3, #9]
 c0005ba:	687b      	ldr	r3, [r7, #4]
 c0005bc:	715a      	strb	r2, [r3, #5]
  (*state)[2][1] = (*state)[3][1];
 c0005be:	687b      	ldr	r3, [r7, #4]
 c0005c0:	7b5a      	ldrb	r2, [r3, #13]
 c0005c2:	687b      	ldr	r3, [r7, #4]
 c0005c4:	725a      	strb	r2, [r3, #9]
  (*state)[3][1] = temp;
 c0005c6:	687b      	ldr	r3, [r7, #4]
 c0005c8:	7bfa      	ldrb	r2, [r7, #15]
 c0005ca:	735a      	strb	r2, [r3, #13]

  // Rotate second row 2 columns to left
  temp           = (*state)[0][2];
 c0005cc:	687b      	ldr	r3, [r7, #4]
 c0005ce:	789b      	ldrb	r3, [r3, #2]
 c0005d0:	73fb      	strb	r3, [r7, #15]
  (*state)[0][2] = (*state)[2][2];
 c0005d2:	687b      	ldr	r3, [r7, #4]
 c0005d4:	7a9a      	ldrb	r2, [r3, #10]
 c0005d6:	687b      	ldr	r3, [r7, #4]
 c0005d8:	709a      	strb	r2, [r3, #2]
  (*state)[2][2] = temp;
 c0005da:	687b      	ldr	r3, [r7, #4]
 c0005dc:	7bfa      	ldrb	r2, [r7, #15]
 c0005de:	729a      	strb	r2, [r3, #10]

  temp           = (*state)[1][2];
 c0005e0:	687b      	ldr	r3, [r7, #4]
 c0005e2:	799b      	ldrb	r3, [r3, #6]
 c0005e4:	73fb      	strb	r3, [r7, #15]
  (*state)[1][2] = (*state)[3][2];
 c0005e6:	687b      	ldr	r3, [r7, #4]
 c0005e8:	7b9a      	ldrb	r2, [r3, #14]
 c0005ea:	687b      	ldr	r3, [r7, #4]
 c0005ec:	719a      	strb	r2, [r3, #6]
  (*state)[3][2] = temp;
 c0005ee:	687b      	ldr	r3, [r7, #4]
 c0005f0:	7bfa      	ldrb	r2, [r7, #15]
 c0005f2:	739a      	strb	r2, [r3, #14]

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
 c0005f4:	687b      	ldr	r3, [r7, #4]
 c0005f6:	78db      	ldrb	r3, [r3, #3]
 c0005f8:	73fb      	strb	r3, [r7, #15]
  (*state)[0][3] = (*state)[3][3];
 c0005fa:	687b      	ldr	r3, [r7, #4]
 c0005fc:	7bda      	ldrb	r2, [r3, #15]
 c0005fe:	687b      	ldr	r3, [r7, #4]
 c000600:	70da      	strb	r2, [r3, #3]
  (*state)[3][3] = (*state)[2][3];
 c000602:	687b      	ldr	r3, [r7, #4]
 c000604:	7ada      	ldrb	r2, [r3, #11]
 c000606:	687b      	ldr	r3, [r7, #4]
 c000608:	73da      	strb	r2, [r3, #15]
  (*state)[2][3] = (*state)[1][3];
 c00060a:	687b      	ldr	r3, [r7, #4]
 c00060c:	79da      	ldrb	r2, [r3, #7]
 c00060e:	687b      	ldr	r3, [r7, #4]
 c000610:	72da      	strb	r2, [r3, #11]
  (*state)[1][3] = temp;
 c000612:	687b      	ldr	r3, [r7, #4]
 c000614:	7bfa      	ldrb	r2, [r7, #15]
 c000616:	71da      	strb	r2, [r3, #7]
}
 c000618:	bf00      	nop
 c00061a:	3714      	adds	r7, #20
 c00061c:	46bd      	mov	sp, r7
 c00061e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000622:	4770      	bx	lr

0c000624 <xtime>:

static uint8_t xtime(uint8_t x)
{
 c000624:	b480      	push	{r7}
 c000626:	b083      	sub	sp, #12
 c000628:	af00      	add	r7, sp, #0
 c00062a:	4603      	mov	r3, r0
 c00062c:	71fb      	strb	r3, [r7, #7]
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
 c00062e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c000632:	005b      	lsls	r3, r3, #1
 c000634:	b25a      	sxtb	r2, r3
 c000636:	79fb      	ldrb	r3, [r7, #7]
 c000638:	09db      	lsrs	r3, r3, #7
 c00063a:	b2db      	uxtb	r3, r3
 c00063c:	b25b      	sxtb	r3, r3
 c00063e:	4619      	mov	r1, r3
 c000640:	0049      	lsls	r1, r1, #1
 c000642:	440b      	add	r3, r1
 c000644:	4619      	mov	r1, r3
 c000646:	00c8      	lsls	r0, r1, #3
 c000648:	4619      	mov	r1, r3
 c00064a:	4603      	mov	r3, r0
 c00064c:	440b      	add	r3, r1
 c00064e:	b25b      	sxtb	r3, r3
 c000650:	4053      	eors	r3, r2
 c000652:	b25b      	sxtb	r3, r3
 c000654:	b2db      	uxtb	r3, r3
}
 c000656:	4618      	mov	r0, r3
 c000658:	370c      	adds	r7, #12
 c00065a:	46bd      	mov	sp, r7
 c00065c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000660:	4770      	bx	lr

0c000662 <MixColumns>:

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
 c000662:	b580      	push	{r7, lr}
 c000664:	b084      	sub	sp, #16
 c000666:	af00      	add	r7, sp, #0
 c000668:	6078      	str	r0, [r7, #4]
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
 c00066a:	2300      	movs	r3, #0
 c00066c:	73fb      	strb	r3, [r7, #15]
 c00066e:	e0a4      	b.n	c0007ba <MixColumns+0x158>
  {
    t   = (*state)[i][0];
 c000670:	7bfa      	ldrb	r2, [r7, #15]
 c000672:	687b      	ldr	r3, [r7, #4]
 c000674:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
 c000678:	73bb      	strb	r3, [r7, #14]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
 c00067a:	7bfa      	ldrb	r2, [r7, #15]
 c00067c:	687b      	ldr	r3, [r7, #4]
 c00067e:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
 c000682:	7bfb      	ldrb	r3, [r7, #15]
 c000684:	6879      	ldr	r1, [r7, #4]
 c000686:	009b      	lsls	r3, r3, #2
 c000688:	440b      	add	r3, r1
 c00068a:	785b      	ldrb	r3, [r3, #1]
 c00068c:	4053      	eors	r3, r2
 c00068e:	b2da      	uxtb	r2, r3
 c000690:	7bfb      	ldrb	r3, [r7, #15]
 c000692:	6879      	ldr	r1, [r7, #4]
 c000694:	009b      	lsls	r3, r3, #2
 c000696:	440b      	add	r3, r1
 c000698:	789b      	ldrb	r3, [r3, #2]
 c00069a:	4053      	eors	r3, r2
 c00069c:	b2da      	uxtb	r2, r3
 c00069e:	7bfb      	ldrb	r3, [r7, #15]
 c0006a0:	6879      	ldr	r1, [r7, #4]
 c0006a2:	009b      	lsls	r3, r3, #2
 c0006a4:	440b      	add	r3, r1
 c0006a6:	78db      	ldrb	r3, [r3, #3]
 c0006a8:	4053      	eors	r3, r2
 c0006aa:	737b      	strb	r3, [r7, #13]
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
 c0006ac:	7bfa      	ldrb	r2, [r7, #15]
 c0006ae:	687b      	ldr	r3, [r7, #4]
 c0006b0:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
 c0006b4:	7bfb      	ldrb	r3, [r7, #15]
 c0006b6:	6879      	ldr	r1, [r7, #4]
 c0006b8:	009b      	lsls	r3, r3, #2
 c0006ba:	440b      	add	r3, r1
 c0006bc:	785b      	ldrb	r3, [r3, #1]
 c0006be:	4053      	eors	r3, r2
 c0006c0:	733b      	strb	r3, [r7, #12]
 c0006c2:	7b3b      	ldrb	r3, [r7, #12]
 c0006c4:	4618      	mov	r0, r3
 c0006c6:	f7ff ffad 	bl	c000624 <xtime>
 c0006ca:	4603      	mov	r3, r0
 c0006cc:	733b      	strb	r3, [r7, #12]
 c0006ce:	7bfa      	ldrb	r2, [r7, #15]
 c0006d0:	687b      	ldr	r3, [r7, #4]
 c0006d2:	f813 1022 	ldrb.w	r1, [r3, r2, lsl #2]
 c0006d6:	7b3a      	ldrb	r2, [r7, #12]
 c0006d8:	7b7b      	ldrb	r3, [r7, #13]
 c0006da:	4053      	eors	r3, r2
 c0006dc:	b2db      	uxtb	r3, r3
 c0006de:	7bfa      	ldrb	r2, [r7, #15]
 c0006e0:	404b      	eors	r3, r1
 c0006e2:	b2d9      	uxtb	r1, r3
 c0006e4:	687b      	ldr	r3, [r7, #4]
 c0006e6:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
 c0006ea:	7bfb      	ldrb	r3, [r7, #15]
 c0006ec:	687a      	ldr	r2, [r7, #4]
 c0006ee:	009b      	lsls	r3, r3, #2
 c0006f0:	4413      	add	r3, r2
 c0006f2:	785a      	ldrb	r2, [r3, #1]
 c0006f4:	7bfb      	ldrb	r3, [r7, #15]
 c0006f6:	6879      	ldr	r1, [r7, #4]
 c0006f8:	009b      	lsls	r3, r3, #2
 c0006fa:	440b      	add	r3, r1
 c0006fc:	789b      	ldrb	r3, [r3, #2]
 c0006fe:	4053      	eors	r3, r2
 c000700:	733b      	strb	r3, [r7, #12]
 c000702:	7b3b      	ldrb	r3, [r7, #12]
 c000704:	4618      	mov	r0, r3
 c000706:	f7ff ff8d 	bl	c000624 <xtime>
 c00070a:	4603      	mov	r3, r0
 c00070c:	733b      	strb	r3, [r7, #12]
 c00070e:	7bfb      	ldrb	r3, [r7, #15]
 c000710:	687a      	ldr	r2, [r7, #4]
 c000712:	009b      	lsls	r3, r3, #2
 c000714:	4413      	add	r3, r2
 c000716:	7859      	ldrb	r1, [r3, #1]
 c000718:	7b3a      	ldrb	r2, [r7, #12]
 c00071a:	7b7b      	ldrb	r3, [r7, #13]
 c00071c:	4053      	eors	r3, r2
 c00071e:	b2da      	uxtb	r2, r3
 c000720:	7bfb      	ldrb	r3, [r7, #15]
 c000722:	404a      	eors	r2, r1
 c000724:	b2d1      	uxtb	r1, r2
 c000726:	687a      	ldr	r2, [r7, #4]
 c000728:	009b      	lsls	r3, r3, #2
 c00072a:	4413      	add	r3, r2
 c00072c:	460a      	mov	r2, r1
 c00072e:	705a      	strb	r2, [r3, #1]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
 c000730:	7bfb      	ldrb	r3, [r7, #15]
 c000732:	687a      	ldr	r2, [r7, #4]
 c000734:	009b      	lsls	r3, r3, #2
 c000736:	4413      	add	r3, r2
 c000738:	789a      	ldrb	r2, [r3, #2]
 c00073a:	7bfb      	ldrb	r3, [r7, #15]
 c00073c:	6879      	ldr	r1, [r7, #4]
 c00073e:	009b      	lsls	r3, r3, #2
 c000740:	440b      	add	r3, r1
 c000742:	78db      	ldrb	r3, [r3, #3]
 c000744:	4053      	eors	r3, r2
 c000746:	733b      	strb	r3, [r7, #12]
 c000748:	7b3b      	ldrb	r3, [r7, #12]
 c00074a:	4618      	mov	r0, r3
 c00074c:	f7ff ff6a 	bl	c000624 <xtime>
 c000750:	4603      	mov	r3, r0
 c000752:	733b      	strb	r3, [r7, #12]
 c000754:	7bfb      	ldrb	r3, [r7, #15]
 c000756:	687a      	ldr	r2, [r7, #4]
 c000758:	009b      	lsls	r3, r3, #2
 c00075a:	4413      	add	r3, r2
 c00075c:	7899      	ldrb	r1, [r3, #2]
 c00075e:	7b3a      	ldrb	r2, [r7, #12]
 c000760:	7b7b      	ldrb	r3, [r7, #13]
 c000762:	4053      	eors	r3, r2
 c000764:	b2da      	uxtb	r2, r3
 c000766:	7bfb      	ldrb	r3, [r7, #15]
 c000768:	404a      	eors	r2, r1
 c00076a:	b2d1      	uxtb	r1, r2
 c00076c:	687a      	ldr	r2, [r7, #4]
 c00076e:	009b      	lsls	r3, r3, #2
 c000770:	4413      	add	r3, r2
 c000772:	460a      	mov	r2, r1
 c000774:	709a      	strb	r2, [r3, #2]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
 c000776:	7bfb      	ldrb	r3, [r7, #15]
 c000778:	687a      	ldr	r2, [r7, #4]
 c00077a:	009b      	lsls	r3, r3, #2
 c00077c:	4413      	add	r3, r2
 c00077e:	78da      	ldrb	r2, [r3, #3]
 c000780:	7bbb      	ldrb	r3, [r7, #14]
 c000782:	4053      	eors	r3, r2
 c000784:	733b      	strb	r3, [r7, #12]
 c000786:	7b3b      	ldrb	r3, [r7, #12]
 c000788:	4618      	mov	r0, r3
 c00078a:	f7ff ff4b 	bl	c000624 <xtime>
 c00078e:	4603      	mov	r3, r0
 c000790:	733b      	strb	r3, [r7, #12]
 c000792:	7bfb      	ldrb	r3, [r7, #15]
 c000794:	687a      	ldr	r2, [r7, #4]
 c000796:	009b      	lsls	r3, r3, #2
 c000798:	4413      	add	r3, r2
 c00079a:	78d9      	ldrb	r1, [r3, #3]
 c00079c:	7b3a      	ldrb	r2, [r7, #12]
 c00079e:	7b7b      	ldrb	r3, [r7, #13]
 c0007a0:	4053      	eors	r3, r2
 c0007a2:	b2da      	uxtb	r2, r3
 c0007a4:	7bfb      	ldrb	r3, [r7, #15]
 c0007a6:	404a      	eors	r2, r1
 c0007a8:	b2d1      	uxtb	r1, r2
 c0007aa:	687a      	ldr	r2, [r7, #4]
 c0007ac:	009b      	lsls	r3, r3, #2
 c0007ae:	4413      	add	r3, r2
 c0007b0:	460a      	mov	r2, r1
 c0007b2:	70da      	strb	r2, [r3, #3]
  for (i = 0; i < 4; ++i)
 c0007b4:	7bfb      	ldrb	r3, [r7, #15]
 c0007b6:	3301      	adds	r3, #1
 c0007b8:	73fb      	strb	r3, [r7, #15]
 c0007ba:	7bfb      	ldrb	r3, [r7, #15]
 c0007bc:	2b03      	cmp	r3, #3
 c0007be:	f67f af57 	bls.w	c000670 <MixColumns+0xe>
  }
}
 c0007c2:	bf00      	nop
 c0007c4:	bf00      	nop
 c0007c6:	3710      	adds	r7, #16
 c0007c8:	46bd      	mov	sp, r7
 c0007ca:	bd80      	pop	{r7, pc}

0c0007cc <Cipher>:
}
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
 c0007cc:	b580      	push	{r7, lr}
 c0007ce:	b084      	sub	sp, #16
 c0007d0:	af00      	add	r7, sp, #0
 c0007d2:	6078      	str	r0, [r7, #4]
 c0007d4:	6039      	str	r1, [r7, #0]
  uint8_t round = 0;
 c0007d6:	2300      	movs	r3, #0
 c0007d8:	73fb      	strb	r3, [r7, #15]

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);
 c0007da:	683a      	ldr	r2, [r7, #0]
 c0007dc:	6879      	ldr	r1, [r7, #4]
 c0007de:	2000      	movs	r0, #0
 c0007e0:	f7ff fe70 	bl	c0004c4 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
 c0007e4:	2301      	movs	r3, #1
 c0007e6:	73fb      	strb	r3, [r7, #15]
  {
    SubBytes(state);
 c0007e8:	6878      	ldr	r0, [r7, #4]
 c0007ea:	f7ff fea7 	bl	c00053c <SubBytes>
    ShiftRows(state);
 c0007ee:	6878      	ldr	r0, [r7, #4]
 c0007f0:	f7ff fed6 	bl	c0005a0 <ShiftRows>
    if (round == Nr) {
 c0007f4:	7bfb      	ldrb	r3, [r7, #15]
 c0007f6:	2b0a      	cmp	r3, #10
 c0007f8:	d00c      	beq.n	c000814 <Cipher+0x48>
      break;
    }
    MixColumns(state);
 c0007fa:	6878      	ldr	r0, [r7, #4]
 c0007fc:	f7ff ff31 	bl	c000662 <MixColumns>
    AddRoundKey(round, state, RoundKey);
 c000800:	7bfb      	ldrb	r3, [r7, #15]
 c000802:	683a      	ldr	r2, [r7, #0]
 c000804:	6879      	ldr	r1, [r7, #4]
 c000806:	4618      	mov	r0, r3
 c000808:	f7ff fe5c 	bl	c0004c4 <AddRoundKey>
  for (round = 1; ; ++round)
 c00080c:	7bfb      	ldrb	r3, [r7, #15]
 c00080e:	3301      	adds	r3, #1
 c000810:	73fb      	strb	r3, [r7, #15]
    SubBytes(state);
 c000812:	e7e9      	b.n	c0007e8 <Cipher+0x1c>
      break;
 c000814:	bf00      	nop
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
 c000816:	683a      	ldr	r2, [r7, #0]
 c000818:	6879      	ldr	r1, [r7, #4]
 c00081a:	200a      	movs	r0, #10
 c00081c:	f7ff fe52 	bl	c0004c4 <AddRoundKey>
}
 c000820:	bf00      	nop
 c000822:	3710      	adds	r7, #16
 c000824:	46bd      	mov	sp, r7
 c000826:	bd80      	pop	{r7, pc}

0c000828 <AES_CTR_xcrypt_buffer>:

#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
 c000828:	b590      	push	{r4, r7, lr}
 c00082a:	b08b      	sub	sp, #44	@ 0x2c
 c00082c:	af00      	add	r7, sp, #0
 c00082e:	60f8      	str	r0, [r7, #12]
 c000830:	60b9      	str	r1, [r7, #8]
 c000832:	607a      	str	r2, [r7, #4]
  uint8_t buffer[AES_BLOCKLEN];

  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
 c000834:	2300      	movs	r3, #0
 c000836:	627b      	str	r3, [r7, #36]	@ 0x24
 c000838:	2310      	movs	r3, #16
 c00083a:	623b      	str	r3, [r7, #32]
 c00083c:	e04e      	b.n	c0008dc <AES_CTR_xcrypt_buffer+0xb4>
  {
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
 c00083e:	6a3b      	ldr	r3, [r7, #32]
 c000840:	2b10      	cmp	r3, #16
 c000842:	d136      	bne.n	c0008b2 <AES_CTR_xcrypt_buffer+0x8a>
    {

      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
 c000844:	68fb      	ldr	r3, [r7, #12]
 c000846:	33b0      	adds	r3, #176	@ 0xb0
 c000848:	f107 0410 	add.w	r4, r7, #16
 c00084c:	6818      	ldr	r0, [r3, #0]
 c00084e:	6859      	ldr	r1, [r3, #4]
 c000850:	689a      	ldr	r2, [r3, #8]
 c000852:	68db      	ldr	r3, [r3, #12]
 c000854:	c40f      	stmia	r4!, {r0, r1, r2, r3}
      Cipher((state_t*)buffer,ctx->RoundKey);
 c000856:	68fa      	ldr	r2, [r7, #12]
 c000858:	f107 0310 	add.w	r3, r7, #16
 c00085c:	4611      	mov	r1, r2
 c00085e:	4618      	mov	r0, r3
 c000860:	f7ff ffb4 	bl	c0007cc <Cipher>

      /* Increment Iv and handle overflow */
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
 c000864:	230f      	movs	r3, #15
 c000866:	623b      	str	r3, [r7, #32]
 c000868:	e01e      	b.n	c0008a8 <AES_CTR_xcrypt_buffer+0x80>
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
 c00086a:	68fa      	ldr	r2, [r7, #12]
 c00086c:	6a3b      	ldr	r3, [r7, #32]
 c00086e:	4413      	add	r3, r2
 c000870:	33b0      	adds	r3, #176	@ 0xb0
 c000872:	781b      	ldrb	r3, [r3, #0]
 c000874:	2bff      	cmp	r3, #255	@ 0xff
 c000876:	d106      	bne.n	c000886 <AES_CTR_xcrypt_buffer+0x5e>
	{
          ctx->Iv[bi] = 0;
 c000878:	68fa      	ldr	r2, [r7, #12]
 c00087a:	6a3b      	ldr	r3, [r7, #32]
 c00087c:	4413      	add	r3, r2
 c00087e:	33b0      	adds	r3, #176	@ 0xb0
 c000880:	2200      	movs	r2, #0
 c000882:	701a      	strb	r2, [r3, #0]
          continue;
 c000884:	e00d      	b.n	c0008a2 <AES_CTR_xcrypt_buffer+0x7a>
        }
        ctx->Iv[bi] += 1;
 c000886:	68fa      	ldr	r2, [r7, #12]
 c000888:	6a3b      	ldr	r3, [r7, #32]
 c00088a:	4413      	add	r3, r2
 c00088c:	33b0      	adds	r3, #176	@ 0xb0
 c00088e:	781b      	ldrb	r3, [r3, #0]
 c000890:	3301      	adds	r3, #1
 c000892:	b2d9      	uxtb	r1, r3
 c000894:	68fa      	ldr	r2, [r7, #12]
 c000896:	6a3b      	ldr	r3, [r7, #32]
 c000898:	4413      	add	r3, r2
 c00089a:	33b0      	adds	r3, #176	@ 0xb0
 c00089c:	460a      	mov	r2, r1
 c00089e:	701a      	strb	r2, [r3, #0]
        break;
 c0008a0:	e005      	b.n	c0008ae <AES_CTR_xcrypt_buffer+0x86>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
 c0008a2:	6a3b      	ldr	r3, [r7, #32]
 c0008a4:	3b01      	subs	r3, #1
 c0008a6:	623b      	str	r3, [r7, #32]
 c0008a8:	6a3b      	ldr	r3, [r7, #32]
 c0008aa:	2b00      	cmp	r3, #0
 c0008ac:	dadd      	bge.n	c00086a <AES_CTR_xcrypt_buffer+0x42>
      }
      bi = 0;
 c0008ae:	2300      	movs	r3, #0
 c0008b0:	623b      	str	r3, [r7, #32]
    }

    buf[i] = (buf[i] ^ buffer[bi]);
 c0008b2:	68ba      	ldr	r2, [r7, #8]
 c0008b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008b6:	4413      	add	r3, r2
 c0008b8:	7819      	ldrb	r1, [r3, #0]
 c0008ba:	f107 0210 	add.w	r2, r7, #16
 c0008be:	6a3b      	ldr	r3, [r7, #32]
 c0008c0:	4413      	add	r3, r2
 c0008c2:	781a      	ldrb	r2, [r3, #0]
 c0008c4:	68b8      	ldr	r0, [r7, #8]
 c0008c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008c8:	4403      	add	r3, r0
 c0008ca:	404a      	eors	r2, r1
 c0008cc:	b2d2      	uxtb	r2, r2
 c0008ce:	701a      	strb	r2, [r3, #0]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
 c0008d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008d2:	3301      	adds	r3, #1
 c0008d4:	627b      	str	r3, [r7, #36]	@ 0x24
 c0008d6:	6a3b      	ldr	r3, [r7, #32]
 c0008d8:	3301      	adds	r3, #1
 c0008da:	623b      	str	r3, [r7, #32]
 c0008dc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 c0008de:	687b      	ldr	r3, [r7, #4]
 c0008e0:	429a      	cmp	r2, r3
 c0008e2:	d3ac      	bcc.n	c00083e <AES_CTR_xcrypt_buffer+0x16>
  }
}
 c0008e4:	bf00      	nop
 c0008e6:	bf00      	nop
 c0008e8:	372c      	adds	r7, #44	@ 0x2c
 c0008ea:	46bd      	mov	sp, r7
 c0008ec:	bd90      	pop	{r4, r7, pc}
	...

0c0008f0 <sha256_initialize>:
    uint32_t	buffer[16];	// Changed by RKW, unsigned long becomes uint32_t
    uint32_t	state[8];	// Changed by RKW, unsinged long becomes uint32_t
    uint8_t		length[8];	// Changed by RKW, unsigned char becomes uint8_t
} sha256;

void sha256_initialize(sha256 *sha) {
 c0008f0:	b480      	push	{r7}
 c0008f2:	b085      	sub	sp, #20
 c0008f4:	af00      	add	r7, sp, #0
 c0008f6:	6078      	str	r0, [r7, #4]
    int i;
    for (i = 0; i < 17; ++i) sha->buffer[i] = 0;
 c0008f8:	2300      	movs	r3, #0
 c0008fa:	60fb      	str	r3, [r7, #12]
 c0008fc:	e008      	b.n	c000910 <sha256_initialize+0x20>
 c0008fe:	687b      	ldr	r3, [r7, #4]
 c000900:	68fa      	ldr	r2, [r7, #12]
 c000902:	3208      	adds	r2, #8
 c000904:	2100      	movs	r1, #0
 c000906:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 c00090a:	68fb      	ldr	r3, [r7, #12]
 c00090c:	3301      	adds	r3, #1
 c00090e:	60fb      	str	r3, [r7, #12]
 c000910:	68fb      	ldr	r3, [r7, #12]
 c000912:	2b10      	cmp	r3, #16
 c000914:	ddf3      	ble.n	c0008fe <sha256_initialize+0xe>
    sha->state[0] = 0x6a09e667;
 c000916:	687b      	ldr	r3, [r7, #4]
 c000918:	4a16      	ldr	r2, [pc, #88]	@ (c000974 <sha256_initialize+0x84>)
 c00091a:	661a      	str	r2, [r3, #96]	@ 0x60
    sha->state[1] = 0xbb67ae85;
 c00091c:	687b      	ldr	r3, [r7, #4]
 c00091e:	4a16      	ldr	r2, [pc, #88]	@ (c000978 <sha256_initialize+0x88>)
 c000920:	665a      	str	r2, [r3, #100]	@ 0x64
    sha->state[2] = 0x3c6ef372;
 c000922:	687b      	ldr	r3, [r7, #4]
 c000924:	4a15      	ldr	r2, [pc, #84]	@ (c00097c <sha256_initialize+0x8c>)
 c000926:	669a      	str	r2, [r3, #104]	@ 0x68
    sha->state[3] = 0xa54ff53a;
 c000928:	687b      	ldr	r3, [r7, #4]
 c00092a:	4a15      	ldr	r2, [pc, #84]	@ (c000980 <sha256_initialize+0x90>)
 c00092c:	66da      	str	r2, [r3, #108]	@ 0x6c
    sha->state[4] = 0x510e527f;
 c00092e:	687b      	ldr	r3, [r7, #4]
 c000930:	4a14      	ldr	r2, [pc, #80]	@ (c000984 <sha256_initialize+0x94>)
 c000932:	671a      	str	r2, [r3, #112]	@ 0x70
    sha->state[5] = 0x9b05688c;
 c000934:	687b      	ldr	r3, [r7, #4]
 c000936:	4a14      	ldr	r2, [pc, #80]	@ (c000988 <sha256_initialize+0x98>)
 c000938:	675a      	str	r2, [r3, #116]	@ 0x74
    sha->state[6] = 0x1f83d9ab;
 c00093a:	687b      	ldr	r3, [r7, #4]
 c00093c:	4a13      	ldr	r2, [pc, #76]	@ (c00098c <sha256_initialize+0x9c>)
 c00093e:	679a      	str	r2, [r3, #120]	@ 0x78
    sha->state[7] = 0x5be0cd19;
 c000940:	687b      	ldr	r3, [r7, #4]
 c000942:	4a13      	ldr	r2, [pc, #76]	@ (c000990 <sha256_initialize+0xa0>)
 c000944:	67da      	str	r2, [r3, #124]	@ 0x7c
    for (i = 0; i < 8; ++i) sha->length[i] = 0;
 c000946:	2300      	movs	r3, #0
 c000948:	60fb      	str	r3, [r7, #12]
 c00094a:	e008      	b.n	c00095e <sha256_initialize+0x6e>
 c00094c:	687a      	ldr	r2, [r7, #4]
 c00094e:	68fb      	ldr	r3, [r7, #12]
 c000950:	4413      	add	r3, r2
 c000952:	3380      	adds	r3, #128	@ 0x80
 c000954:	2200      	movs	r2, #0
 c000956:	701a      	strb	r2, [r3, #0]
 c000958:	68fb      	ldr	r3, [r7, #12]
 c00095a:	3301      	adds	r3, #1
 c00095c:	60fb      	str	r3, [r7, #12]
 c00095e:	68fb      	ldr	r3, [r7, #12]
 c000960:	2b07      	cmp	r3, #7
 c000962:	ddf3      	ble.n	c00094c <sha256_initialize+0x5c>
}
 c000964:	bf00      	nop
 c000966:	bf00      	nop
 c000968:	3714      	adds	r7, #20
 c00096a:	46bd      	mov	sp, r7
 c00096c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000970:	4770      	bx	lr
 c000972:	bf00      	nop
 c000974:	6a09e667 	.word	0x6a09e667
 c000978:	bb67ae85 	.word	0xbb67ae85
 c00097c:	3c6ef372 	.word	0x3c6ef372
 c000980:	a54ff53a 	.word	0xa54ff53a
 c000984:	510e527f 	.word	0x510e527f
 c000988:	9b05688c 	.word	0x9b05688c
 c00098c:	1f83d9ab 	.word	0x1f83d9ab
 c000990:	5be0cd19 	.word	0x5be0cd19

0c000994 <sha256_update>:

//  Changed by RKW, formal args are now const uint8_t, uint_32
//    from const unsigned char, unsigned long respectively
void sha256_update(sha256 *sha,
                   const uint8_t *message,
                   uint32_t length) {
 c000994:	b590      	push	{r4, r7, lr}
 c000996:	f5ad 7d19 	sub.w	sp, sp, #612	@ 0x264
 c00099a:	af00      	add	r7, sp, #0
 c00099c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009a0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c0009a4:	6018      	str	r0, [r3, #0]
 c0009a6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009aa:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c0009ae:	6019      	str	r1, [r3, #0]
 c0009b0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009b4:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c0009b8:	601a      	str	r2, [r3, #0]
    int i, j;
    /* Add the length of the received message, counted in
     * bytes, to the total length of the messages hashed to
     * date, counted in bits and stored in 8 separate bytes. */
    for (i = 7; i >= 0; --i) {
 c0009ba:	2307      	movs	r3, #7
 c0009bc:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
 c0009c0:	e086      	b.n	c000ad0 <sha256_update+0x13c>
        int bits;
		if (i == 7)
 c0009c2:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009c6:	2b07      	cmp	r3, #7
 c0009c8:	d108      	bne.n	c0009dc <sha256_update+0x48>
			bits = length << 3;
 c0009ca:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009ce:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c0009d2:	681b      	ldr	r3, [r3, #0]
 c0009d4:	00db      	lsls	r3, r3, #3
 c0009d6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 c0009da:	e01d      	b.n	c000a18 <sha256_update+0x84>
		else if (i == 0 || i == 1 || i == 2)
 c0009dc:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009e0:	2b00      	cmp	r3, #0
 c0009e2:	d007      	beq.n	c0009f4 <sha256_update+0x60>
 c0009e4:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009e8:	2b01      	cmp	r3, #1
 c0009ea:	d003      	beq.n	c0009f4 <sha256_update+0x60>
 c0009ec:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009f0:	2b02      	cmp	r3, #2
 c0009f2:	d103      	bne.n	c0009fc <sha256_update+0x68>
			bits = 0;
 c0009f4:	2300      	movs	r3, #0
 c0009f6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 c0009fa:	e00d      	b.n	c000a18 <sha256_update+0x84>
		else
			bits = length >> (53 - 8 * i);
 c0009fc:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a00:	00db      	lsls	r3, r3, #3
 c000a02:	f1c3 0335 	rsb	r3, r3, #53	@ 0x35
 c000a06:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000a0a:	f5a2 7217 	sub.w	r2, r2, #604	@ 0x25c
 c000a0e:	6812      	ldr	r2, [r2, #0]
 c000a10:	fa22 f303 	lsr.w	r3, r2, r3
 c000a14:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
		bits &= 0xff;
 c000a18:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000a1c:	b2db      	uxtb	r3, r3
 c000a1e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
        if (sha->length[i] + bits > 0xff) {
 c000a22:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a26:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a2a:	681a      	ldr	r2, [r3, #0]
 c000a2c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a30:	4413      	add	r3, r2
 c000a32:	3380      	adds	r3, #128	@ 0x80
 c000a34:	781b      	ldrb	r3, [r3, #0]
 c000a36:	461a      	mov	r2, r3
 c000a38:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000a3c:	4413      	add	r3, r2
 c000a3e:	2bff      	cmp	r3, #255	@ 0xff
 c000a40:	dd27      	ble.n	c000a92 <sha256_update+0xfe>
            for (j = i - 1; j >= 0 && sha->length[j]++ == 0xff; --j);
 c000a42:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a46:	3b01      	subs	r3, #1
 c000a48:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
 c000a4c:	e004      	b.n	c000a58 <sha256_update+0xc4>
 c000a4e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a52:	3b01      	subs	r3, #1
 c000a54:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
 c000a58:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a5c:	2b00      	cmp	r3, #0
 c000a5e:	db18      	blt.n	c000a92 <sha256_update+0xfe>
 c000a60:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a64:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a68:	681a      	ldr	r2, [r3, #0]
 c000a6a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a6e:	4413      	add	r3, r2
 c000a70:	3380      	adds	r3, #128	@ 0x80
 c000a72:	781b      	ldrb	r3, [r3, #0]
 c000a74:	1c5a      	adds	r2, r3, #1
 c000a76:	b2d0      	uxtb	r0, r2
 c000a78:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000a7c:	f5a2 7215 	sub.w	r2, r2, #596	@ 0x254
 c000a80:	6811      	ldr	r1, [r2, #0]
 c000a82:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 c000a86:	440a      	add	r2, r1
 c000a88:	3280      	adds	r2, #128	@ 0x80
 c000a8a:	4601      	mov	r1, r0
 c000a8c:	7011      	strb	r1, [r2, #0]
 c000a8e:	2bff      	cmp	r3, #255	@ 0xff
 c000a90:	d0dd      	beq.n	c000a4e <sha256_update+0xba>
        }
        sha->length[i] += bits;
 c000a92:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a96:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a9a:	681a      	ldr	r2, [r3, #0]
 c000a9c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000aa0:	4413      	add	r3, r2
 c000aa2:	3380      	adds	r3, #128	@ 0x80
 c000aa4:	781a      	ldrb	r2, [r3, #0]
 c000aa6:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000aaa:	b2db      	uxtb	r3, r3
 c000aac:	4413      	add	r3, r2
 c000aae:	b2d9      	uxtb	r1, r3
 c000ab0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ab4:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ab8:	681a      	ldr	r2, [r3, #0]
 c000aba:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000abe:	4413      	add	r3, r2
 c000ac0:	3380      	adds	r3, #128	@ 0x80
 c000ac2:	460a      	mov	r2, r1
 c000ac4:	701a      	strb	r2, [r3, #0]
    for (i = 7; i >= 0; --i) {
 c000ac6:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000aca:	3b01      	subs	r3, #1
 c000acc:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
 c000ad0:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000ad4:	2b00      	cmp	r3, #0
 c000ad6:	f6bf af74 	bge.w	c0009c2 <sha256_update+0x2e>
    }
    /* Add the received message to the SHA buffer, updating the
     * hash at each block (each time the buffer is filled). */
    while (length > 0) {
 c000ada:	e294      	b.n	c001006 <sha256_update+0x672>
        /* Find the index in the SHA buffer at which to
         * append what's left of the received message. */
        int index = sha->length[6] % 2 * 32 + sha->length[7] / 8;
 c000adc:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ae0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ae4:	681b      	ldr	r3, [r3, #0]
 c000ae6:	f893 3086 	ldrb.w	r3, [r3, #134]	@ 0x86
 c000aea:	f003 0301 	and.w	r3, r3, #1
 c000aee:	015b      	lsls	r3, r3, #5
 c000af0:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000af4:	f5a2 7215 	sub.w	r2, r2, #596	@ 0x254
 c000af8:	6812      	ldr	r2, [r2, #0]
 c000afa:	f892 2087 	ldrb.w	r2, [r2, #135]	@ 0x87
 c000afe:	08d2      	lsrs	r2, r2, #3
 c000b00:	b2d2      	uxtb	r2, r2
 c000b02:	4413      	add	r3, r2
 c000b04:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
        index = (index + 64 - length % 64) % 64;
 c000b08:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 c000b0c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b10:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000b14:	681b      	ldr	r3, [r3, #0]
 c000b16:	1ad3      	subs	r3, r2, r3
 c000b18:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 c000b1c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
        /* Append the received message bytes to the SHA buffer until
         * we run out of message bytes or until the buffer is filled. */
        for (;length > 0 && index < 64; ++message, ++index, --length) {
 c000b20:	e048      	b.n	c000bb4 <sha256_update+0x220>
            sha->buffer[index / 4] |= *message << (24 - index % 4 * 8);
 c000b22:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b26:	2b00      	cmp	r3, #0
 c000b28:	da00      	bge.n	c000b2c <sha256_update+0x198>
 c000b2a:	3303      	adds	r3, #3
 c000b2c:	109b      	asrs	r3, r3, #2
 c000b2e:	461a      	mov	r2, r3
 c000b30:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b34:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000b38:	681b      	ldr	r3, [r3, #0]
 c000b3a:	f102 0108 	add.w	r1, r2, #8
 c000b3e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 c000b42:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b46:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c000b4a:	681b      	ldr	r3, [r3, #0]
 c000b4c:	781b      	ldrb	r3, [r3, #0]
 c000b4e:	461c      	mov	r4, r3
 c000b50:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b54:	4258      	negs	r0, r3
 c000b56:	f003 0303 	and.w	r3, r3, #3
 c000b5a:	f000 0003 	and.w	r0, r0, #3
 c000b5e:	bf58      	it	pl
 c000b60:	4243      	negpl	r3, r0
 c000b62:	f1c3 0303 	rsb	r3, r3, #3
 c000b66:	00db      	lsls	r3, r3, #3
 c000b68:	fa04 f303 	lsl.w	r3, r4, r3
 c000b6c:	4319      	orrs	r1, r3
 c000b6e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b72:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000b76:	681b      	ldr	r3, [r3, #0]
 c000b78:	3208      	adds	r2, #8
 c000b7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (;length > 0 && index < 64; ++message, ++index, --length) {
 c000b7e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b82:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c000b86:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000b8a:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 c000b8e:	6812      	ldr	r2, [r2, #0]
 c000b90:	3201      	adds	r2, #1
 c000b92:	601a      	str	r2, [r3, #0]
 c000b94:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b98:	3301      	adds	r3, #1
 c000b9a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
 c000b9e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ba2:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000ba6:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000baa:	f5a2 7217 	sub.w	r2, r2, #604	@ 0x25c
 c000bae:	6812      	ldr	r2, [r2, #0]
 c000bb0:	3a01      	subs	r2, #1
 c000bb2:	601a      	str	r2, [r3, #0]
 c000bb4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bb8:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000bbc:	681b      	ldr	r3, [r3, #0]
 c000bbe:	2b00      	cmp	r3, #0
 c000bc0:	d003      	beq.n	c000bca <sha256_update+0x236>
 c000bc2:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000bc6:	2b3f      	cmp	r3, #63	@ 0x3f
 c000bc8:	ddab      	ble.n	c000b22 <sha256_update+0x18e>
        }
        /* Update the hash with the buffer contents if the buffer is full. */
        if (index == 64) {
 c000bca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000bce:	2b40      	cmp	r3, #64	@ 0x40
 c000bd0:	f040 8219 	bne.w	c001006 <sha256_update+0x672>
            /* Update the hash with a block of message content. See FIPS 180-2
             * (<csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf>)
             * for a description of and details on the algorithm used here. */
			// Changed by RKW, const unsigned long becomes const uint32_t
            const uint32_t k[64] = {
 c000bd4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bd8:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 c000bdc:	4a80      	ldr	r2, [pc, #512]	@ (c000de0 <sha256_update+0x44c>)
 c000bde:	4618      	mov	r0, r3
 c000be0:	4611      	mov	r1, r2
 c000be2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c000be6:	461a      	mov	r2, r3
 c000be8:	f005 f805 	bl	c005bf6 <memcpy>
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            };
			// Changed by RKW, unsigned long becomes uint32_t
            uint32_t w[64], a, b, c, d, e, f, g, h;
            int t;
            for (t = 0; t < 16; ++t) {
 c000bec:	2300      	movs	r3, #0
 c000bee:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000bf2:	e021      	b.n	c000c38 <sha256_update+0x2a4>
                w[t] = sha->buffer[t];
 c000bf4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bf8:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000bfc:	681b      	ldr	r3, [r3, #0]
 c000bfe:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c02:	3208      	adds	r2, #8
 c000c04:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c000c08:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c0c:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c10:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c14:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                sha->buffer[t] = 0;
 c000c18:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c1c:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000c20:	681b      	ldr	r3, [r3, #0]
 c000c22:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c26:	3208      	adds	r2, #8
 c000c28:	2100      	movs	r1, #0
 c000c2a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            for (t = 0; t < 16; ++t) {
 c000c2e:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c32:	3301      	adds	r3, #1
 c000c34:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000c38:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c3c:	2b0f      	cmp	r3, #15
 c000c3e:	ddd9      	ble.n	c000bf4 <sha256_update+0x260>
            }
            for (t = 16; t < 64; ++t) {
 c000c40:	2310      	movs	r3, #16
 c000c42:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000c46:	e081      	b.n	c000d4c <sha256_update+0x3b8>
				// Changed by RKW, unsigned long becomes uint32_t
                uint32_t s0, s1;
                s0 = (w[t - 15] >> 7 | w[t - 15] << 25);
 c000c48:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c4c:	f1a3 020f 	sub.w	r2, r3, #15
 c000c50:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c54:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c5c:	ea4f 13f3 	mov.w	r3, r3, ror #7
 c000c60:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s0 ^= (w[t - 15] >> 18 | w[t - 15] << 14);
 c000c64:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c68:	f1a3 020f 	sub.w	r2, r3, #15
 c000c6c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c70:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c78:	ea4f 43b3 	mov.w	r3, r3, ror #18
 c000c7c:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 c000c80:	4053      	eors	r3, r2
 c000c82:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s0 ^= (w[t - 15] >> 3);
 c000c86:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c8a:	f1a3 020f 	sub.w	r2, r3, #15
 c000c8e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c92:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c96:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c9a:	08db      	lsrs	r3, r3, #3
 c000c9c:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 c000ca0:	4053      	eors	r3, r2
 c000ca2:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s1 = (w[t - 2] >> 17 | w[t - 2] << 15);
 c000ca6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000caa:	1e9a      	subs	r2, r3, #2
 c000cac:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cb0:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cb8:	ea4f 4373 	mov.w	r3, r3, ror #17
 c000cbc:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                s1 ^= (w[t - 2] >> 19 | w[t - 2] << 13);
 c000cc0:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000cc4:	1e9a      	subs	r2, r3, #2
 c000cc6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cca:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cd2:	ea4f 43f3 	mov.w	r3, r3, ror #19
 c000cd6:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 c000cda:	4053      	eors	r3, r2
 c000cdc:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                s1 ^= (w[t - 2] >> 10);
 c000ce0:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000ce4:	1e9a      	subs	r2, r3, #2
 c000ce6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cea:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cf2:	0a9b      	lsrs	r3, r3, #10
 c000cf4:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 c000cf8:	4053      	eors	r3, r2
 c000cfa:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                w[t] = (s1 + w[t - 7] + s0 + w[t - 16]) & 0xffffffffU;
 c000cfe:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d02:	1fda      	subs	r2, r3, #7
 c000d04:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d08:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d0c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c000d10:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 c000d14:	441a      	add	r2, r3
 c000d16:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 c000d1a:	441a      	add	r2, r3
 c000d1c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d20:	f1a3 0110 	sub.w	r1, r3, #16
 c000d24:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d28:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d2c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000d30:	18d1      	adds	r1, r2, r3
 c000d32:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d36:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d3a:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000d3e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            for (t = 16; t < 64; ++t) {
 c000d42:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d46:	3301      	adds	r3, #1
 c000d48:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000d4c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d50:	2b3f      	cmp	r3, #63	@ 0x3f
 c000d52:	f77f af79 	ble.w	c000c48 <sha256_update+0x2b4>
            }
            a = sha->state[0];
 c000d56:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d5a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d5e:	681b      	ldr	r3, [r3, #0]
 c000d60:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c000d62:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
            b = sha->state[1];
 c000d66:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d6a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d6e:	681b      	ldr	r3, [r3, #0]
 c000d70:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 c000d72:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
            c = sha->state[2];
 c000d76:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d7a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d7e:	681b      	ldr	r3, [r3, #0]
 c000d80:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 c000d82:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
            d = sha->state[3];
 c000d86:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d8a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d8e:	681b      	ldr	r3, [r3, #0]
 c000d90:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 c000d92:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
            e = sha->state[4];
 c000d96:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d9a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d9e:	681b      	ldr	r3, [r3, #0]
 c000da0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 c000da2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
            f = sha->state[5];
 c000da6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000daa:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dae:	681b      	ldr	r3, [r3, #0]
 c000db0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 c000db2:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
            g = sha->state[6];
 c000db6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000dba:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dbe:	681b      	ldr	r3, [r3, #0]
 c000dc0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 c000dc2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
            h = sha->state[7];
 c000dc6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000dca:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dce:	681b      	ldr	r3, [r3, #0]
 c000dd0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 c000dd2:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
            for (t = 0; t < 64; ++t) {
 c000dd6:	2300      	movs	r3, #0
 c000dd8:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000ddc:	e096      	b.n	c000f0c <sha256_update+0x578>
 c000dde:	bf00      	nop
 c000de0:	0c0065d8 	.word	0x0c0065d8
				// Changed by RKW, unsigned long becomes uint32_t
                uint32_t e0, e1, t1, t2;
                e0 = (a >> 2 | a << 30);
 c000de4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000de8:	ea4f 03b3 	mov.w	r3, r3, ror #2
 c000dec:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e0 ^= (a >> 13 | a << 19);
 c000df0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000df4:	ea4f 3373 	mov.w	r3, r3, ror #13
 c000df8:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000dfc:	4053      	eors	r3, r2
 c000dfe:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e0 ^= (a >> 22 | a << 10);
 c000e02:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000e06:	ea4f 53b3 	mov.w	r3, r3, ror #22
 c000e0a:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000e0e:	4053      	eors	r3, r2
 c000e10:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e1 = (e >> 6 | e << 26);
 c000e14:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e18:	ea4f 13b3 	mov.w	r3, r3, ror #6
 c000e1c:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                e1 ^= (e >> 11 | e << 21);
 c000e20:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e24:	ea4f 23f3 	mov.w	r3, r3, ror #11
 c000e28:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 c000e2c:	4053      	eors	r3, r2
 c000e2e:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                e1 ^= (e >> 25 | e << 7);
 c000e32:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e36:	ea4f 6373 	mov.w	r3, r3, ror #25
 c000e3a:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 c000e3e:	4053      	eors	r3, r2
 c000e40:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                t1 = h + e1 + ((e & f) ^ (~e & g)) + k[t] + w[t];
 c000e44:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 c000e48:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 c000e4c:	441a      	add	r2, r3
 c000e4e:	f8d7 123c 	ldr.w	r1, [r7, #572]	@ 0x23c
 c000e52:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000e56:	4019      	ands	r1, r3
 c000e58:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e5c:	43d8      	mvns	r0, r3
 c000e5e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000e62:	4003      	ands	r3, r0
 c000e64:	404b      	eors	r3, r1
 c000e66:	441a      	add	r2, r3
 c000e68:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000e6c:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 c000e70:	f8d7 122c 	ldr.w	r1, [r7, #556]	@ 0x22c
 c000e74:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000e78:	441a      	add	r2, r3
 c000e7a:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000e7e:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000e82:	f8d7 122c 	ldr.w	r1, [r7, #556]	@ 0x22c
 c000e86:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000e8a:	4413      	add	r3, r2
 c000e8c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
                t2 = e0 + ((a & b) ^ (a & c) ^ (b & c));
 c000e90:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 c000e94:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000e98:	405a      	eors	r2, r3
 c000e9a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000e9e:	401a      	ands	r2, r3
 c000ea0:	f8d7 1248 	ldr.w	r1, [r7, #584]	@ 0x248
 c000ea4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000ea8:	400b      	ands	r3, r1
 c000eaa:	4053      	eors	r3, r2
 c000eac:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000eb0:	4413      	add	r3, r2
 c000eb2:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
                h = g;
 c000eb6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000eba:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
                g = f;
 c000ebe:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000ec2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
                f = e;
 c000ec6:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000eca:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
                e = d + t1;
 c000ece:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 c000ed2:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 c000ed6:	4413      	add	r3, r2
 c000ed8:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
                d = c;
 c000edc:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000ee0:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
                c = b;
 c000ee4:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 c000ee8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
                b = a;
 c000eec:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000ef0:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
                a = t1 + t2;
 c000ef4:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 c000ef8:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 c000efc:	4413      	add	r3, r2
 c000efe:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
            for (t = 0; t < 64; ++t) {
 c000f02:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000f06:	3301      	adds	r3, #1
 c000f08:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000f0c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000f10:	2b3f      	cmp	r3, #63	@ 0x3f
 c000f12:	f77f af67 	ble.w	c000de4 <sha256_update+0x450>
            }
            sha->state[0] = (sha->state[0] + a) & 0xffffffffU;
 c000f16:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f1a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f1e:	681b      	ldr	r3, [r3, #0]
 c000f20:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 c000f22:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000f26:	441a      	add	r2, r3
 c000f28:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f2c:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f30:	681b      	ldr	r3, [r3, #0]
 c000f32:	661a      	str	r2, [r3, #96]	@ 0x60
            sha->state[1] = (sha->state[1] + b) & 0xffffffffU;
 c000f34:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f38:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f3c:	681b      	ldr	r3, [r3, #0]
 c000f3e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 c000f40:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 c000f44:	441a      	add	r2, r3
 c000f46:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f4a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f4e:	681b      	ldr	r3, [r3, #0]
 c000f50:	665a      	str	r2, [r3, #100]	@ 0x64
            sha->state[2] = (sha->state[2] + c) & 0xffffffffU;
 c000f52:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f56:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f5a:	681b      	ldr	r3, [r3, #0]
 c000f5c:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 c000f5e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000f62:	441a      	add	r2, r3
 c000f64:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f68:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f6c:	681b      	ldr	r3, [r3, #0]
 c000f6e:	669a      	str	r2, [r3, #104]	@ 0x68
            sha->state[3] = (sha->state[3] + d) & 0xffffffffU;
 c000f70:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f74:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f78:	681b      	ldr	r3, [r3, #0]
 c000f7a:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 c000f7c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 c000f80:	441a      	add	r2, r3
 c000f82:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f86:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f8a:	681b      	ldr	r3, [r3, #0]
 c000f8c:	66da      	str	r2, [r3, #108]	@ 0x6c
            sha->state[4] = (sha->state[4] + e) & 0xffffffffU;
 c000f8e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f92:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f96:	681b      	ldr	r3, [r3, #0]
 c000f98:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 c000f9a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000f9e:	441a      	add	r2, r3
 c000fa0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fa4:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fa8:	681b      	ldr	r3, [r3, #0]
 c000faa:	671a      	str	r2, [r3, #112]	@ 0x70
            sha->state[5] = (sha->state[5] + f) & 0xffffffffU;
 c000fac:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fb0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fb4:	681b      	ldr	r3, [r3, #0]
 c000fb6:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 c000fb8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000fbc:	441a      	add	r2, r3
 c000fbe:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fc2:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fc6:	681b      	ldr	r3, [r3, #0]
 c000fc8:	675a      	str	r2, [r3, #116]	@ 0x74
            sha->state[6] = (sha->state[6] + g) & 0xffffffffU;
 c000fca:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fce:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fd2:	681b      	ldr	r3, [r3, #0]
 c000fd4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 c000fd6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000fda:	441a      	add	r2, r3
 c000fdc:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fe0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fe4:	681b      	ldr	r3, [r3, #0]
 c000fe6:	679a      	str	r2, [r3, #120]	@ 0x78
            sha->state[7] = (sha->state[7] + h) & 0xffffffffU;
 c000fe8:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fec:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ff0:	681b      	ldr	r3, [r3, #0]
 c000ff2:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 c000ff4:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 c000ff8:	441a      	add	r2, r3
 c000ffa:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ffe:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c001002:	681b      	ldr	r3, [r3, #0]
 c001004:	67da      	str	r2, [r3, #124]	@ 0x7c
    while (length > 0) {
 c001006:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c00100a:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c00100e:	681b      	ldr	r3, [r3, #0]
 c001010:	2b00      	cmp	r3, #0
 c001012:	f47f ad63 	bne.w	c000adc <sha256_update+0x148>
        }
    }
}
 c001016:	bf00      	nop
 c001018:	bf00      	nop
 c00101a:	f507 7719 	add.w	r7, r7, #612	@ 0x264
 c00101e:	46bd      	mov	sp, r7
 c001020:	bd90      	pop	{r4, r7, pc}
 c001022:	bf00      	nop

0c001024 <sha256_finalize>:

//  Changed by RKW, formal args are now const uint8_t, uint_32
//    from const unsigned char, unsigned long respectively
void sha256_finalize(sha256 *sha,
                     const uint8_t *message,
                     uint32_t length) {
 c001024:	b580      	push	{r7, lr}
 c001026:	b098      	sub	sp, #96	@ 0x60
 c001028:	af00      	add	r7, sp, #0
 c00102a:	60f8      	str	r0, [r7, #12]
 c00102c:	60b9      	str	r1, [r7, #8]
 c00102e:	607a      	str	r2, [r7, #4]
    int i;
	// Changed by RKW, unsigned char becomes uint8_t
    uint8_t terminator[64 + 8] = { 0x80 };
 c001030:	2380      	movs	r3, #128	@ 0x80
 c001032:	617b      	str	r3, [r7, #20]
 c001034:	f107 0318 	add.w	r3, r7, #24
 c001038:	2244      	movs	r2, #68	@ 0x44
 c00103a:	2100      	movs	r1, #0
 c00103c:	4618      	mov	r0, r3
 c00103e:	f004 fd3b 	bl	c005ab8 <memset>
    /* Hash the final message bytes if necessary. */
    if (length > 0) sha256_update(sha, message, length);
 c001042:	687b      	ldr	r3, [r7, #4]
 c001044:	2b00      	cmp	r3, #0
 c001046:	d004      	beq.n	c001052 <sha256_finalize+0x2e>
 c001048:	687a      	ldr	r2, [r7, #4]
 c00104a:	68b9      	ldr	r1, [r7, #8]
 c00104c:	68f8      	ldr	r0, [r7, #12]
 c00104e:	f7ff fca1 	bl	c000994 <sha256_update>
    /* Create a terminator that includes a stop bit, padding, and
     * the the total message length. See FIPS 180-2 for details. */
    length = 64 - sha->length[6] % 2 * 32 - sha->length[7] / 8;
 c001052:	68fb      	ldr	r3, [r7, #12]
 c001054:	f893 3086 	ldrb.w	r3, [r3, #134]	@ 0x86
 c001058:	f003 0301 	and.w	r3, r3, #1
 c00105c:	f1c3 0302 	rsb	r3, r3, #2
 c001060:	015b      	lsls	r3, r3, #5
 c001062:	68fa      	ldr	r2, [r7, #12]
 c001064:	f892 2087 	ldrb.w	r2, [r2, #135]	@ 0x87
 c001068:	08d2      	lsrs	r2, r2, #3
 c00106a:	b2d2      	uxtb	r2, r2
 c00106c:	1a9b      	subs	r3, r3, r2
 c00106e:	607b      	str	r3, [r7, #4]
    if (length < 9) length += 64;
 c001070:	687b      	ldr	r3, [r7, #4]
 c001072:	2b08      	cmp	r3, #8
 c001074:	d802      	bhi.n	c00107c <sha256_finalize+0x58>
 c001076:	687b      	ldr	r3, [r7, #4]
 c001078:	3340      	adds	r3, #64	@ 0x40
 c00107a:	607b      	str	r3, [r7, #4]
    for (i = 0; i < 8; ++i) terminator[length - 8 + i] = sha->length[i];
 c00107c:	2300      	movs	r3, #0
 c00107e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c001080:	e00f      	b.n	c0010a2 <sha256_finalize+0x7e>
 c001082:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c001084:	687b      	ldr	r3, [r7, #4]
 c001086:	4413      	add	r3, r2
 c001088:	3b08      	subs	r3, #8
 c00108a:	68f9      	ldr	r1, [r7, #12]
 c00108c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c00108e:	440a      	add	r2, r1
 c001090:	3280      	adds	r2, #128	@ 0x80
 c001092:	7812      	ldrb	r2, [r2, #0]
 c001094:	3360      	adds	r3, #96	@ 0x60
 c001096:	443b      	add	r3, r7
 c001098:	f803 2c4c 	strb.w	r2, [r3, #-76]
 c00109c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c00109e:	3301      	adds	r3, #1
 c0010a0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010a4:	2b07      	cmp	r3, #7
 c0010a6:	ddec      	ble.n	c001082 <sha256_finalize+0x5e>
    /* Hash the terminator to finalize the message digest. */
    sha256_update(sha, terminator, length);
 c0010a8:	f107 0314 	add.w	r3, r7, #20
 c0010ac:	687a      	ldr	r2, [r7, #4]
 c0010ae:	4619      	mov	r1, r3
 c0010b0:	68f8      	ldr	r0, [r7, #12]
 c0010b2:	f7ff fc6f 	bl	c000994 <sha256_update>
    /* Extract the message digest. */
    for (i = 0; i < 32; ++i) {
 c0010b6:	2300      	movs	r3, #0
 c0010b8:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010ba:	e01f      	b.n	c0010fc <sha256_finalize+0xd8>
        sha->hash[i] = (sha->state[i / 4] >> (24 - 8 * (i % 4))) & 0xff;
 c0010bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010be:	2b00      	cmp	r3, #0
 c0010c0:	da00      	bge.n	c0010c4 <sha256_finalize+0xa0>
 c0010c2:	3303      	adds	r3, #3
 c0010c4:	109b      	asrs	r3, r3, #2
 c0010c6:	461a      	mov	r2, r3
 c0010c8:	68fb      	ldr	r3, [r7, #12]
 c0010ca:	3218      	adds	r2, #24
 c0010cc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c0010d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010d2:	4259      	negs	r1, r3
 c0010d4:	f003 0303 	and.w	r3, r3, #3
 c0010d8:	f001 0103 	and.w	r1, r1, #3
 c0010dc:	bf58      	it	pl
 c0010de:	424b      	negpl	r3, r1
 c0010e0:	f1c3 0303 	rsb	r3, r3, #3
 c0010e4:	00db      	lsls	r3, r3, #3
 c0010e6:	fa22 f303 	lsr.w	r3, r2, r3
 c0010ea:	b2d9      	uxtb	r1, r3
 c0010ec:	68fa      	ldr	r2, [r7, #12]
 c0010ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010f0:	4413      	add	r3, r2
 c0010f2:	460a      	mov	r2, r1
 c0010f4:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < 32; ++i) {
 c0010f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010f8:	3301      	adds	r3, #1
 c0010fa:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010fc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010fe:	2b1f      	cmp	r3, #31
 c001100:	dddc      	ble.n	c0010bc <sha256_finalize+0x98>
    }
}
 c001102:	bf00      	nop
 c001104:	bf00      	nop
 c001106:	3760      	adds	r7, #96	@ 0x60
 c001108:	46bd      	mov	sp, r7
 c00110a:	bd80      	pop	{r7, pc}

0c00110c <hmac_sha256_initialize>:
} hmac_sha256;

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_initialize(hmac_sha256 *hmac,
                            const uint8_t *key, int length) {
 c00110c:	b580      	push	{r7, lr}
 c00110e:	b086      	sub	sp, #24
 c001110:	af00      	add	r7, sp, #0
 c001112:	60f8      	str	r0, [r7, #12]
 c001114:	60b9      	str	r1, [r7, #8]
 c001116:	607a      	str	r2, [r7, #4]
    int i;
    /* Prepare the inner hash key block, hashing the key if it's too long. */
    if (length <= 64) {
 c001118:	687b      	ldr	r3, [r7, #4]
 c00111a:	2b40      	cmp	r3, #64	@ 0x40
 c00111c:	dc24      	bgt.n	c001168 <hmac_sha256_initialize+0x5c>
        for (i = 0; i < length; ++i) hmac->key[i] = key[i] ^ 0x36;
 c00111e:	2300      	movs	r3, #0
 c001120:	617b      	str	r3, [r7, #20]
 c001122:	e00f      	b.n	c001144 <hmac_sha256_initialize+0x38>
 c001124:	697b      	ldr	r3, [r7, #20]
 c001126:	68ba      	ldr	r2, [r7, #8]
 c001128:	4413      	add	r3, r2
 c00112a:	781b      	ldrb	r3, [r3, #0]
 c00112c:	f083 0336 	eor.w	r3, r3, #54	@ 0x36
 c001130:	b2d9      	uxtb	r1, r3
 c001132:	68fa      	ldr	r2, [r7, #12]
 c001134:	697b      	ldr	r3, [r7, #20]
 c001136:	4413      	add	r3, r2
 c001138:	3320      	adds	r3, #32
 c00113a:	460a      	mov	r2, r1
 c00113c:	701a      	strb	r2, [r3, #0]
 c00113e:	697b      	ldr	r3, [r7, #20]
 c001140:	3301      	adds	r3, #1
 c001142:	617b      	str	r3, [r7, #20]
 c001144:	697a      	ldr	r2, [r7, #20]
 c001146:	687b      	ldr	r3, [r7, #4]
 c001148:	429a      	cmp	r2, r3
 c00114a:	dbeb      	blt.n	c001124 <hmac_sha256_initialize+0x18>
        for (; i < 64; ++i) hmac->key[i] = 0x36;
 c00114c:	e008      	b.n	c001160 <hmac_sha256_initialize+0x54>
 c00114e:	68fa      	ldr	r2, [r7, #12]
 c001150:	697b      	ldr	r3, [r7, #20]
 c001152:	4413      	add	r3, r2
 c001154:	3320      	adds	r3, #32
 c001156:	2236      	movs	r2, #54	@ 0x36
 c001158:	701a      	strb	r2, [r3, #0]
 c00115a:	697b      	ldr	r3, [r7, #20]
 c00115c:	3301      	adds	r3, #1
 c00115e:	617b      	str	r3, [r7, #20]
 c001160:	697b      	ldr	r3, [r7, #20]
 c001162:	2b3f      	cmp	r3, #63	@ 0x3f
 c001164:	ddf3      	ble.n	c00114e <hmac_sha256_initialize+0x42>
 c001166:	e02f      	b.n	c0011c8 <hmac_sha256_initialize+0xbc>
    } else {
        sha256_initialize(&(hmac->sha));
 c001168:	68fb      	ldr	r3, [r7, #12]
 c00116a:	3360      	adds	r3, #96	@ 0x60
 c00116c:	4618      	mov	r0, r3
 c00116e:	f7ff fbbf 	bl	c0008f0 <sha256_initialize>
        sha256_finalize(&(hmac->sha), key, length);
 c001172:	68fb      	ldr	r3, [r7, #12]
 c001174:	3360      	adds	r3, #96	@ 0x60
 c001176:	687a      	ldr	r2, [r7, #4]
 c001178:	68b9      	ldr	r1, [r7, #8]
 c00117a:	4618      	mov	r0, r3
 c00117c:	f7ff ff52 	bl	c001024 <sha256_finalize>
        for (i = 0; i < 32; ++i) hmac->key[i] = hmac->sha.hash[i] ^ 0x36;
 c001180:	2300      	movs	r3, #0
 c001182:	617b      	str	r3, [r7, #20]
 c001184:	e010      	b.n	c0011a8 <hmac_sha256_initialize+0x9c>
 c001186:	68fa      	ldr	r2, [r7, #12]
 c001188:	697b      	ldr	r3, [r7, #20]
 c00118a:	4413      	add	r3, r2
 c00118c:	3360      	adds	r3, #96	@ 0x60
 c00118e:	781b      	ldrb	r3, [r3, #0]
 c001190:	f083 0336 	eor.w	r3, r3, #54	@ 0x36
 c001194:	b2d9      	uxtb	r1, r3
 c001196:	68fa      	ldr	r2, [r7, #12]
 c001198:	697b      	ldr	r3, [r7, #20]
 c00119a:	4413      	add	r3, r2
 c00119c:	3320      	adds	r3, #32
 c00119e:	460a      	mov	r2, r1
 c0011a0:	701a      	strb	r2, [r3, #0]
 c0011a2:	697b      	ldr	r3, [r7, #20]
 c0011a4:	3301      	adds	r3, #1
 c0011a6:	617b      	str	r3, [r7, #20]
 c0011a8:	697b      	ldr	r3, [r7, #20]
 c0011aa:	2b1f      	cmp	r3, #31
 c0011ac:	ddeb      	ble.n	c001186 <hmac_sha256_initialize+0x7a>
        for (; i < 64; ++i) hmac->key[i] = 0x36;
 c0011ae:	e008      	b.n	c0011c2 <hmac_sha256_initialize+0xb6>
 c0011b0:	68fa      	ldr	r2, [r7, #12]
 c0011b2:	697b      	ldr	r3, [r7, #20]
 c0011b4:	4413      	add	r3, r2
 c0011b6:	3320      	adds	r3, #32
 c0011b8:	2236      	movs	r2, #54	@ 0x36
 c0011ba:	701a      	strb	r2, [r3, #0]
 c0011bc:	697b      	ldr	r3, [r7, #20]
 c0011be:	3301      	adds	r3, #1
 c0011c0:	617b      	str	r3, [r7, #20]
 c0011c2:	697b      	ldr	r3, [r7, #20]
 c0011c4:	2b3f      	cmp	r3, #63	@ 0x3f
 c0011c6:	ddf3      	ble.n	c0011b0 <hmac_sha256_initialize+0xa4>
    }
    /* Initialize the inner hash with the key block. */
    sha256_initialize(&(hmac->sha));
 c0011c8:	68fb      	ldr	r3, [r7, #12]
 c0011ca:	3360      	adds	r3, #96	@ 0x60
 c0011cc:	4618      	mov	r0, r3
 c0011ce:	f7ff fb8f 	bl	c0008f0 <sha256_initialize>
    sha256_update(&(hmac->sha), hmac->key, 64);
 c0011d2:	68fb      	ldr	r3, [r7, #12]
 c0011d4:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 c0011d8:	68fb      	ldr	r3, [r7, #12]
 c0011da:	3320      	adds	r3, #32
 c0011dc:	2240      	movs	r2, #64	@ 0x40
 c0011de:	4619      	mov	r1, r3
 c0011e0:	f7ff fbd8 	bl	c000994 <sha256_update>
}
 c0011e4:	bf00      	nop
 c0011e6:	3718      	adds	r7, #24
 c0011e8:	46bd      	mov	sp, r7
 c0011ea:	bd80      	pop	{r7, pc}

0c0011ec <hmac_sha256_update>:

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_update(hmac_sha256 *hmac,
                        const uint8_t *message, int length) {
 c0011ec:	b580      	push	{r7, lr}
 c0011ee:	b084      	sub	sp, #16
 c0011f0:	af00      	add	r7, sp, #0
 c0011f2:	60f8      	str	r0, [r7, #12]
 c0011f4:	60b9      	str	r1, [r7, #8]
 c0011f6:	607a      	str	r2, [r7, #4]
    /* Update the inner hash. */
    sha256_update(&(hmac->sha), message, length);
 c0011f8:	68fb      	ldr	r3, [r7, #12]
 c0011fa:	3360      	adds	r3, #96	@ 0x60
 c0011fc:	687a      	ldr	r2, [r7, #4]
 c0011fe:	68b9      	ldr	r1, [r7, #8]
 c001200:	4618      	mov	r0, r3
 c001202:	f7ff fbc7 	bl	c000994 <sha256_update>
}
 c001206:	bf00      	nop
 c001208:	3710      	adds	r7, #16
 c00120a:	46bd      	mov	sp, r7
 c00120c:	bd80      	pop	{r7, pc}

0c00120e <hmac_sha256_finalize>:

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_finalize(hmac_sha256 *hmac,
                          const uint8_t *message, int length) {
 c00120e:	b580      	push	{r7, lr}
 c001210:	b086      	sub	sp, #24
 c001212:	af00      	add	r7, sp, #0
 c001214:	60f8      	str	r0, [r7, #12]
 c001216:	60b9      	str	r1, [r7, #8]
 c001218:	607a      	str	r2, [r7, #4]
    int i;
    /* Finalize the inner hash and store its value in the digest array. */
    sha256_finalize(&(hmac->sha), message, length);
 c00121a:	68fb      	ldr	r3, [r7, #12]
 c00121c:	3360      	adds	r3, #96	@ 0x60
 c00121e:	687a      	ldr	r2, [r7, #4]
 c001220:	68b9      	ldr	r1, [r7, #8]
 c001222:	4618      	mov	r0, r3
 c001224:	f7ff fefe 	bl	c001024 <sha256_finalize>
    for (i = 0; i < 32; ++i) hmac->digest[i] = hmac->sha.hash[i];
 c001228:	2300      	movs	r3, #0
 c00122a:	617b      	str	r3, [r7, #20]
 c00122c:	e00c      	b.n	c001248 <hmac_sha256_finalize+0x3a>
 c00122e:	68fa      	ldr	r2, [r7, #12]
 c001230:	697b      	ldr	r3, [r7, #20]
 c001232:	4413      	add	r3, r2
 c001234:	3360      	adds	r3, #96	@ 0x60
 c001236:	7819      	ldrb	r1, [r3, #0]
 c001238:	68fa      	ldr	r2, [r7, #12]
 c00123a:	697b      	ldr	r3, [r7, #20]
 c00123c:	4413      	add	r3, r2
 c00123e:	460a      	mov	r2, r1
 c001240:	701a      	strb	r2, [r3, #0]
 c001242:	697b      	ldr	r3, [r7, #20]
 c001244:	3301      	adds	r3, #1
 c001246:	617b      	str	r3, [r7, #20]
 c001248:	697b      	ldr	r3, [r7, #20]
 c00124a:	2b1f      	cmp	r3, #31
 c00124c:	ddef      	ble.n	c00122e <hmac_sha256_finalize+0x20>
    /* Convert the inner hash key block to the outer hash key block. */
    for (i = 0; i < 64; ++i) hmac->key[i] ^= (0x36 ^ 0x5c);
 c00124e:	2300      	movs	r3, #0
 c001250:	617b      	str	r3, [r7, #20]
 c001252:	e010      	b.n	c001276 <hmac_sha256_finalize+0x68>
 c001254:	68fa      	ldr	r2, [r7, #12]
 c001256:	697b      	ldr	r3, [r7, #20]
 c001258:	4413      	add	r3, r2
 c00125a:	3320      	adds	r3, #32
 c00125c:	781b      	ldrb	r3, [r3, #0]
 c00125e:	f083 036a 	eor.w	r3, r3, #106	@ 0x6a
 c001262:	b2d9      	uxtb	r1, r3
 c001264:	68fa      	ldr	r2, [r7, #12]
 c001266:	697b      	ldr	r3, [r7, #20]
 c001268:	4413      	add	r3, r2
 c00126a:	3320      	adds	r3, #32
 c00126c:	460a      	mov	r2, r1
 c00126e:	701a      	strb	r2, [r3, #0]
 c001270:	697b      	ldr	r3, [r7, #20]
 c001272:	3301      	adds	r3, #1
 c001274:	617b      	str	r3, [r7, #20]
 c001276:	697b      	ldr	r3, [r7, #20]
 c001278:	2b3f      	cmp	r3, #63	@ 0x3f
 c00127a:	ddeb      	ble.n	c001254 <hmac_sha256_finalize+0x46>
    /* Calculate the outer hash. */
    sha256_initialize(&(hmac->sha));
 c00127c:	68fb      	ldr	r3, [r7, #12]
 c00127e:	3360      	adds	r3, #96	@ 0x60
 c001280:	4618      	mov	r0, r3
 c001282:	f7ff fb35 	bl	c0008f0 <sha256_initialize>
    sha256_update(&(hmac->sha), hmac->key, 64);
 c001286:	68fb      	ldr	r3, [r7, #12]
 c001288:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 c00128c:	68fb      	ldr	r3, [r7, #12]
 c00128e:	3320      	adds	r3, #32
 c001290:	2240      	movs	r2, #64	@ 0x40
 c001292:	4619      	mov	r1, r3
 c001294:	f7ff fb7e 	bl	c000994 <sha256_update>
    sha256_finalize(&(hmac->sha), hmac->digest, 32);
 c001298:	68fb      	ldr	r3, [r7, #12]
 c00129a:	3360      	adds	r3, #96	@ 0x60
 c00129c:	68f9      	ldr	r1, [r7, #12]
 c00129e:	2220      	movs	r2, #32
 c0012a0:	4618      	mov	r0, r3
 c0012a2:	f7ff febf 	bl	c001024 <sha256_finalize>
    /* Use the outer hash value as the HMAC digest. */
    for (i = 0; i < 32; ++i) hmac->digest[i] = hmac->sha.hash[i];
 c0012a6:	2300      	movs	r3, #0
 c0012a8:	617b      	str	r3, [r7, #20]
 c0012aa:	e00c      	b.n	c0012c6 <hmac_sha256_finalize+0xb8>
 c0012ac:	68fa      	ldr	r2, [r7, #12]
 c0012ae:	697b      	ldr	r3, [r7, #20]
 c0012b0:	4413      	add	r3, r2
 c0012b2:	3360      	adds	r3, #96	@ 0x60
 c0012b4:	7819      	ldrb	r1, [r3, #0]
 c0012b6:	68fa      	ldr	r2, [r7, #12]
 c0012b8:	697b      	ldr	r3, [r7, #20]
 c0012ba:	4413      	add	r3, r2
 c0012bc:	460a      	mov	r2, r1
 c0012be:	701a      	strb	r2, [r3, #0]
 c0012c0:	697b      	ldr	r3, [r7, #20]
 c0012c2:	3301      	adds	r3, #1
 c0012c4:	617b      	str	r3, [r7, #20]
 c0012c6:	697b      	ldr	r3, [r7, #20]
 c0012c8:	2b1f      	cmp	r3, #31
 c0012ca:	ddef      	ble.n	c0012ac <hmac_sha256_finalize+0x9e>
}
 c0012cc:	bf00      	nop
 c0012ce:	bf00      	nop
 c0012d0:	3718      	adds	r7, #24
 c0012d2:	46bd      	mov	sp, r7
 c0012d4:	bd80      	pop	{r7, pc}
	...

0c0012d8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 c0012d8:	b580      	push	{r7, lr}
 c0012da:	b088      	sub	sp, #32
 c0012dc:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and interrupts secure/non-secure allocation setup done */
  /* in SystemInit() based on partition_stm32l552xx.h file's definitions. */

  /* USER CODE BEGIN 1 */
  /* Enable SecureFault handler (HardFault is default) */
  SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
 c0012de:	4b53      	ldr	r3, [pc, #332]	@ (c00142c <main+0x154>)
 c0012e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0012e2:	4a52      	ldr	r2, [pc, #328]	@ (c00142c <main+0x154>)
 c0012e4:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 c0012e8:	6253      	str	r3, [r2, #36]	@ 0x24
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 c0012ea:	f002 fc7d 	bl	c003be8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* GTZC initialisation */
  MX_GTZC_S_Init();
 c0012ee:	f000 f8f5 	bl	c0014dc <MX_GTZC_S_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 c0012f2:	f000 f97f 	bl	c0015f4 <MX_GPIO_Init>
  MX_ICACHE_Init();
 c0012f6:	f000 f969 	bl	c0015cc <MX_ICACHE_Init>
   /* Add your secure application code here prior to non-secure initialization
     */

  /* All IOs are by default allocated to secure */
  /* Release them all to non-secure except PC.07 (LED1) kept as secure */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c0012fa:	4b4d      	ldr	r3, [pc, #308]	@ (c001430 <main+0x158>)
 c0012fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0012fe:	4a4c      	ldr	r2, [pc, #304]	@ (c001430 <main+0x158>)
 c001300:	f043 0301 	orr.w	r3, r3, #1
 c001304:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001306:	4b4a      	ldr	r3, [pc, #296]	@ (c001430 <main+0x158>)
 c001308:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00130a:	f003 0301 	and.w	r3, r3, #1
 c00130e:	61fb      	str	r3, [r7, #28]
 c001310:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c001312:	4b47      	ldr	r3, [pc, #284]	@ (c001430 <main+0x158>)
 c001314:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001316:	4a46      	ldr	r2, [pc, #280]	@ (c001430 <main+0x158>)
 c001318:	f043 0302 	orr.w	r3, r3, #2
 c00131c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00131e:	4b44      	ldr	r3, [pc, #272]	@ (c001430 <main+0x158>)
 c001320:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001322:	f003 0302 	and.w	r3, r3, #2
 c001326:	61bb      	str	r3, [r7, #24]
 c001328:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 c00132a:	4b41      	ldr	r3, [pc, #260]	@ (c001430 <main+0x158>)
 c00132c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00132e:	4a40      	ldr	r2, [pc, #256]	@ (c001430 <main+0x158>)
 c001330:	f043 0304 	orr.w	r3, r3, #4
 c001334:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001336:	4b3e      	ldr	r3, [pc, #248]	@ (c001430 <main+0x158>)
 c001338:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00133a:	f003 0304 	and.w	r3, r3, #4
 c00133e:	617b      	str	r3, [r7, #20]
 c001340:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 c001342:	4b3b      	ldr	r3, [pc, #236]	@ (c001430 <main+0x158>)
 c001344:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001346:	4a3a      	ldr	r2, [pc, #232]	@ (c001430 <main+0x158>)
 c001348:	f043 0308 	orr.w	r3, r3, #8
 c00134c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00134e:	4b38      	ldr	r3, [pc, #224]	@ (c001430 <main+0x158>)
 c001350:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001352:	f003 0308 	and.w	r3, r3, #8
 c001356:	613b      	str	r3, [r7, #16]
 c001358:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 c00135a:	4b35      	ldr	r3, [pc, #212]	@ (c001430 <main+0x158>)
 c00135c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00135e:	4a34      	ldr	r2, [pc, #208]	@ (c001430 <main+0x158>)
 c001360:	f043 0310 	orr.w	r3, r3, #16
 c001364:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001366:	4b32      	ldr	r3, [pc, #200]	@ (c001430 <main+0x158>)
 c001368:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00136a:	f003 0310 	and.w	r3, r3, #16
 c00136e:	60fb      	str	r3, [r7, #12]
 c001370:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 c001372:	4b2f      	ldr	r3, [pc, #188]	@ (c001430 <main+0x158>)
 c001374:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001376:	4a2e      	ldr	r2, [pc, #184]	@ (c001430 <main+0x158>)
 c001378:	f043 0320 	orr.w	r3, r3, #32
 c00137c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00137e:	4b2c      	ldr	r3, [pc, #176]	@ (c001430 <main+0x158>)
 c001380:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001382:	f003 0320 	and.w	r3, r3, #32
 c001386:	60bb      	str	r3, [r7, #8]
 c001388:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c00138a:	4b29      	ldr	r3, [pc, #164]	@ (c001430 <main+0x158>)
 c00138c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00138e:	4a28      	ldr	r2, [pc, #160]	@ (c001430 <main+0x158>)
 c001390:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c001394:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001396:	4b26      	ldr	r3, [pc, #152]	@ (c001430 <main+0x158>)
 c001398:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00139a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 c00139e:	607b      	str	r3, [r7, #4]
 c0013a0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c0013a2:	4b23      	ldr	r3, [pc, #140]	@ (c001430 <main+0x158>)
 c0013a4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0013a6:	4a22      	ldr	r2, [pc, #136]	@ (c001430 <main+0x158>)
 c0013a8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c0013ac:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c0013ae:	4b20      	ldr	r3, [pc, #128]	@ (c001430 <main+0x158>)
 c0013b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0013b2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 c0013b6:	603b      	str	r3, [r7, #0]
 c0013b8:	683b      	ldr	r3, [r7, #0]
  HAL_GPIO_ConfigPinAttributes(GPIOA, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013ba:	2200      	movs	r2, #0
 c0013bc:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013c0:	481c      	ldr	r0, [pc, #112]	@ (c001434 <main+0x15c>)
 c0013c2:	f003 fa49 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013c6:	2200      	movs	r2, #0
 c0013c8:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013cc:	481a      	ldr	r0, [pc, #104]	@ (c001438 <main+0x160>)
 c0013ce:	f003 fa43 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC, (GPIO_PIN_All & ~(GPIO_PIN_7)), GPIO_PIN_NSEC);
 c0013d2:	2200      	movs	r2, #0
 c0013d4:	f64f 717f 	movw	r1, #65407	@ 0xff7f
 c0013d8:	4818      	ldr	r0, [pc, #96]	@ (c00143c <main+0x164>)
 c0013da:	f003 fa3d 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013de:	2200      	movs	r2, #0
 c0013e0:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013e4:	4816      	ldr	r0, [pc, #88]	@ (c001440 <main+0x168>)
 c0013e6:	f003 fa37 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013ea:	2200      	movs	r2, #0
 c0013ec:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013f0:	4814      	ldr	r0, [pc, #80]	@ (c001444 <main+0x16c>)
 c0013f2:	f003 fa31 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOF, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013f6:	2200      	movs	r2, #0
 c0013f8:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013fc:	4812      	ldr	r0, [pc, #72]	@ (c001448 <main+0x170>)
 c0013fe:	f003 fa2b 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG, GPIO_PIN_All, GPIO_PIN_NSEC);
 c001402:	2200      	movs	r2, #0
 c001404:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c001408:	4810      	ldr	r0, [pc, #64]	@ (c00144c <main+0x174>)
 c00140a:	f003 fa25 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH, GPIO_PIN_All, GPIO_PIN_NSEC);
 c00140e:	2200      	movs	r2, #0
 c001410:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c001414:	480e      	ldr	r0, [pc, #56]	@ (c001450 <main+0x178>)
 c001416:	f003 fa1f 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>

  /* Leave the GPIO clocks enabled to let non-secure having I/Os control */

  /* Initialize PC.07 to drive external LED (LED1) */
  BSP_LED_Init(LED1);
 c00141a:	2000      	movs	r0, #0
 c00141c:	f002 f9e6 	bl	c0037ec <BSP_LED_Init>

  /* Secure SysTick should rather be suspended before calling non-secure  */
  /* in order to avoid wake-up from sleep mode entered by non-secure      */
  /* The Secure SysTick shall be resumed on non-secure callable functions */
  HAL_SuspendTick();
 c001420:	f002 fc58 	bl	c003cd4 <HAL_SuspendTick>
  /* USER CODE END 2 */

  /*************** Setup and jump to non-secure *******************************/

  NonSecure_Init();
 c001424:	f000 f816 	bl	c001454 <NonSecure_Init>

  /* Non-secure software does not return, this code is not executed */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 c001428:	bf00      	nop
 c00142a:	e7fd      	b.n	c001428 <main+0x150>
 c00142c:	e000ed00 	.word	0xe000ed00
 c001430:	50021000 	.word	0x50021000
 c001434:	52020000 	.word	0x52020000
 c001438:	52020400 	.word	0x52020400
 c00143c:	52020800 	.word	0x52020800
 c001440:	52020c00 	.word	0x52020c00
 c001444:	52021000 	.word	0x52021000
 c001448:	52021400 	.word	0x52021400
 c00144c:	52021800 	.word	0x52021800
 c001450:	52021c00 	.word	0x52021c00

0c001454 <NonSecure_Init>:
  *         This function is responsible for Non-secure initialization and switch
  *         to non-secure state
  * @retval None
  */
static void NonSecure_Init(void)
{
 c001454:	b590      	push	{r4, r7, lr}
 c001456:	b083      	sub	sp, #12
 c001458:	af00      	add	r7, sp, #0
  funcptr_NS NonSecure_ResetHandler;

  SCB_NS->VTOR = VTOR_TABLE_NS_START_ADDR;
 c00145a:	4b1d      	ldr	r3, [pc, #116]	@ (c0014d0 <NonSecure_Init+0x7c>)
 c00145c:	4a1d      	ldr	r2, [pc, #116]	@ (c0014d4 <NonSecure_Init+0x80>)
 c00145e:	609a      	str	r2, [r3, #8]

  /* Set non-secure main stack (MSP_NS) */
  __TZ_set_MSP_NS((*(uint32_t *)VTOR_TABLE_NS_START_ADDR));
 c001460:	4b1c      	ldr	r3, [pc, #112]	@ (c0014d4 <NonSecure_Init+0x80>)
 c001462:	681b      	ldr	r3, [r3, #0]
 c001464:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 c001466:	683b      	ldr	r3, [r7, #0]
 c001468:	f383 8888 	msr	MSP_NS, r3
}
 c00146c:	bf00      	nop

  /* Get non-secure reset handler */
  NonSecure_ResetHandler = (funcptr_NS)(*((uint32_t *)((VTOR_TABLE_NS_START_ADDR) + 4U)));
 c00146e:	4b1a      	ldr	r3, [pc, #104]	@ (c0014d8 <NonSecure_Init+0x84>)
 c001470:	681b      	ldr	r3, [r3, #0]
 c001472:	607b      	str	r3, [r7, #4]

  /* Start non-secure state software application */
  NonSecure_ResetHandler();
 c001474:	687b      	ldr	r3, [r7, #4]
 c001476:	461c      	mov	r4, r3
 c001478:	0864      	lsrs	r4, r4, #1
 c00147a:	0064      	lsls	r4, r4, #1
 c00147c:	4620      	mov	r0, r4
 c00147e:	4621      	mov	r1, r4
 c001480:	4622      	mov	r2, r4
 c001482:	4623      	mov	r3, r4
 c001484:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001488:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00148c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001490:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001494:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001498:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00149c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0014a0:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0014a4:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0014a8:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0014ac:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0014b0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0014b4:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0014b8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0014bc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0014c0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0014c4:	f7fe fec0 	bl	c000248 <__gnu_cmse_nonsecure_call>
}
 c0014c8:	bf00      	nop
 c0014ca:	370c      	adds	r7, #12
 c0014cc:	46bd      	mov	sp, r7
 c0014ce:	bd90      	pop	{r4, r7, pc}
 c0014d0:	e002ed00 	.word	0xe002ed00
 c0014d4:	08040000 	.word	0x08040000
 c0014d8:	08040004 	.word	0x08040004

0c0014dc <MX_GTZC_S_Init>:
  * @brief GTZC_S Initialization Function
  * @param None
  * @retval None
  */
static void MX_GTZC_S_Init(void)
{
 c0014dc:	b580      	push	{r7, lr}
 c0014de:	b09c      	sub	sp, #112	@ 0x70
 c0014e0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN GTZC_S_Init 0 */

  /* USER CODE END GTZC_S_Init 0 */

  MPCBB_ConfigTypeDef MPCBB_NonSecureArea_Desc = {0};
 c0014e2:	1d3b      	adds	r3, r7, #4
 c0014e4:	226c      	movs	r2, #108	@ 0x6c
 c0014e6:	2100      	movs	r1, #0
 c0014e8:	4618      	mov	r0, r3
 c0014ea:	f004 fae5 	bl	c005ab8 <memset>

  /* USER CODE BEGIN GTZC_S_Init 1 */

  /* USER CODE END GTZC_S_Init 1 */
  MPCBB_NonSecureArea_Desc.SecureRWIllegalMode = GTZC_MPCBB_SRWILADIS_ENABLE;
 c0014ee:	2300      	movs	r3, #0
 c0014f0:	607b      	str	r3, [r7, #4]
  MPCBB_NonSecureArea_Desc.InvertSecureState = GTZC_MPCBB_INVSECSTATE_NOT_INVERTED;
 c0014f2:	2300      	movs	r3, #0
 c0014f4:	60bb      	str	r3, [r7, #8]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0xFFFFFFFF;
 c0014f6:	f04f 33ff 	mov.w	r3, #4294967295
 c0014fa:	60fb      	str	r3, [r7, #12]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0xFFFFFFFF;
 c0014fc:	f04f 33ff 	mov.w	r3, #4294967295
 c001500:	613b      	str	r3, [r7, #16]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0xFFFFFFFF;
 c001502:	f04f 33ff 	mov.w	r3, #4294967295
 c001506:	617b      	str	r3, [r7, #20]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0xFFFFFFFF;
 c001508:	f04f 33ff 	mov.w	r3, #4294967295
 c00150c:	61bb      	str	r3, [r7, #24]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0xFFFFFFFF;
 c00150e:	f04f 33ff 	mov.w	r3, #4294967295
 c001512:	61fb      	str	r3, [r7, #28]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0xFFFFFFFF;
 c001514:	f04f 33ff 	mov.w	r3, #4294967295
 c001518:	623b      	str	r3, [r7, #32]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0xFFFFFFFF;
 c00151a:	f04f 33ff 	mov.w	r3, #4294967295
 c00151e:	627b      	str	r3, [r7, #36]	@ 0x24
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0xFFFFFFFF;
 c001520:	f04f 33ff 	mov.w	r3, #4294967295
 c001524:	62bb      	str	r3, [r7, #40]	@ 0x28
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[8] =   0xFFFFFFFF;
 c001526:	f04f 33ff 	mov.w	r3, #4294967295
 c00152a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[9] =   0xFFFFFFFF;
 c00152c:	f04f 33ff 	mov.w	r3, #4294967295
 c001530:	633b      	str	r3, [r7, #48]	@ 0x30
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[10] =   0xFFFFFFFF;
 c001532:	f04f 33ff 	mov.w	r3, #4294967295
 c001536:	637b      	str	r3, [r7, #52]	@ 0x34
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[11] =   0xFFFFFFFF;
 c001538:	f04f 33ff 	mov.w	r3, #4294967295
 c00153c:	63bb      	str	r3, [r7, #56]	@ 0x38
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[12] =   0x00000000;
 c00153e:	2300      	movs	r3, #0
 c001540:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[13] =   0x00000000;
 c001542:	2300      	movs	r3, #0
 c001544:	643b      	str	r3, [r7, #64]	@ 0x40
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[14] =   0x00000000;
 c001546:	2300      	movs	r3, #0
 c001548:	647b      	str	r3, [r7, #68]	@ 0x44
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[15] =   0x00000000;
 c00154a:	2300      	movs	r3, #0
 c00154c:	64bb      	str	r3, [r7, #72]	@ 0x48
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[16] =   0x00000000;
 c00154e:	2300      	movs	r3, #0
 c001550:	64fb      	str	r3, [r7, #76]	@ 0x4c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[17] =   0x00000000;
 c001552:	2300      	movs	r3, #0
 c001554:	653b      	str	r3, [r7, #80]	@ 0x50
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[18] =   0x00000000;
 c001556:	2300      	movs	r3, #0
 c001558:	657b      	str	r3, [r7, #84]	@ 0x54
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[19] =   0x00000000;
 c00155a:	2300      	movs	r3, #0
 c00155c:	65bb      	str	r3, [r7, #88]	@ 0x58
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[20] =   0x00000000;
 c00155e:	2300      	movs	r3, #0
 c001560:	65fb      	str	r3, [r7, #92]	@ 0x5c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[21] =   0x00000000;
 c001562:	2300      	movs	r3, #0
 c001564:	663b      	str	r3, [r7, #96]	@ 0x60
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[22] =   0x00000000;
 c001566:	2300      	movs	r3, #0
 c001568:	667b      	str	r3, [r7, #100]	@ 0x64
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[23] =   0x00000000;
 c00156a:	2300      	movs	r3, #0
 c00156c:	66bb      	str	r3, [r7, #104]	@ 0x68
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
 c00156e:	2300      	movs	r3, #0
 c001570:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_GTZC_MPCBB_ConfigMem(SRAM1_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
 c001572:	1d3b      	adds	r3, r7, #4
 c001574:	4619      	mov	r1, r3
 c001576:	f04f 5040 	mov.w	r0, #805306368	@ 0x30000000
 c00157a:	f003 f98d 	bl	c004898 <HAL_GTZC_MPCBB_ConfigMem>
 c00157e:	4603      	mov	r3, r0
 c001580:	2b00      	cmp	r3, #0
 c001582:	d001      	beq.n	c001588 <MX_GTZC_S_Init+0xac>
  {
    Error_Handler();
 c001584:	f000 f856 	bl	c001634 <Error_Handler>
  }
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0x00000000;
 c001588:	2300      	movs	r3, #0
 c00158a:	60fb      	str	r3, [r7, #12]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0x00000000;
 c00158c:	2300      	movs	r3, #0
 c00158e:	613b      	str	r3, [r7, #16]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0x00000000;
 c001590:	2300      	movs	r3, #0
 c001592:	617b      	str	r3, [r7, #20]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0x00000000;
 c001594:	2300      	movs	r3, #0
 c001596:	61bb      	str	r3, [r7, #24]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0x00000000;
 c001598:	2300      	movs	r3, #0
 c00159a:	61fb      	str	r3, [r7, #28]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0x00000000;
 c00159c:	2300      	movs	r3, #0
 c00159e:	623b      	str	r3, [r7, #32]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0x00000000;
 c0015a0:	2300      	movs	r3, #0
 c0015a2:	627b      	str	r3, [r7, #36]	@ 0x24
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0x00000000;
 c0015a4:	2300      	movs	r3, #0
 c0015a6:	62bb      	str	r3, [r7, #40]	@ 0x28
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
 c0015a8:	2300      	movs	r3, #0
 c0015aa:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
 c0015ac:	1d3b      	adds	r3, r7, #4
 c0015ae:	4619      	mov	r1, r3
 c0015b0:	4805      	ldr	r0, [pc, #20]	@ (c0015c8 <MX_GTZC_S_Init+0xec>)
 c0015b2:	f003 f971 	bl	c004898 <HAL_GTZC_MPCBB_ConfigMem>
 c0015b6:	4603      	mov	r3, r0
 c0015b8:	2b00      	cmp	r3, #0
 c0015ba:	d001      	beq.n	c0015c0 <MX_GTZC_S_Init+0xe4>
  {
    Error_Handler();
 c0015bc:	f000 f83a 	bl	c001634 <Error_Handler>
  }
  /* USER CODE BEGIN GTZC_S_Init 2 */

  /* USER CODE END GTZC_S_Init 2 */

}
 c0015c0:	bf00      	nop
 c0015c2:	3770      	adds	r7, #112	@ 0x70
 c0015c4:	46bd      	mov	sp, r7
 c0015c6:	bd80      	pop	{r7, pc}
 c0015c8:	30030000 	.word	0x30030000

0c0015cc <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 c0015cc:	b580      	push	{r7, lr}
 c0015ce:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 c0015d0:	2000      	movs	r0, #0
 c0015d2:	f003 fa73 	bl	c004abc <HAL_ICACHE_ConfigAssociativityMode>
 c0015d6:	4603      	mov	r3, r0
 c0015d8:	2b00      	cmp	r3, #0
 c0015da:	d001      	beq.n	c0015e0 <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 c0015dc:	f000 f82a 	bl	c001634 <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 c0015e0:	f003 fa8c 	bl	c004afc <HAL_ICACHE_Enable>
 c0015e4:	4603      	mov	r3, r0
 c0015e6:	2b00      	cmp	r3, #0
 c0015e8:	d001      	beq.n	c0015ee <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 c0015ea:	f000 f823 	bl	c001634 <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 c0015ee:	bf00      	nop
 c0015f0:	bd80      	pop	{r7, pc}
	...

0c0015f4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 c0015f4:	b580      	push	{r7, lr}
 c0015f6:	b082      	sub	sp, #8
 c0015f8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c0015fa:	4b0c      	ldr	r3, [pc, #48]	@ (c00162c <MX_GPIO_Init+0x38>)
 c0015fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0015fe:	4a0b      	ldr	r2, [pc, #44]	@ (c00162c <MX_GPIO_Init+0x38>)
 c001600:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c001604:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001606:	4b09      	ldr	r3, [pc, #36]	@ (c00162c <MX_GPIO_Init+0x38>)
 c001608:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00160a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 c00160e:	607b      	str	r3, [r7, #4]
 c001610:	687b      	ldr	r3, [r7, #4]
  HAL_PWREx_EnableVddIO2();
 c001612:	f003 fafd 	bl	c004c10 <HAL_PWREx_EnableVddIO2>

  /*IO attributes management functions */
  HAL_GPIO_ConfigPinAttributes(GPIOG, GPIO_PIN_7|GPIO_PIN_8, GPIO_PIN_NSEC);
 c001616:	2200      	movs	r2, #0
 c001618:	f44f 71c0 	mov.w	r1, #384	@ 0x180
 c00161c:	4804      	ldr	r0, [pc, #16]	@ (c001630 <MX_GPIO_Init+0x3c>)
 c00161e:	f003 f91b 	bl	c004858 <HAL_GPIO_ConfigPinAttributes>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 c001622:	bf00      	nop
 c001624:	3708      	adds	r7, #8
 c001626:	46bd      	mov	sp, r7
 c001628:	bd80      	pop	{r7, pc}
 c00162a:	bf00      	nop
 c00162c:	50021000 	.word	0x50021000
 c001630:	52021800 	.word	0x52021800

0c001634 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 c001634:	b480      	push	{r7}
 c001636:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
 c001638:	bf00      	nop
 c00163a:	e7fd      	b.n	c001638 <Error_Handler+0x4>

0c00163c <InvalidateICache>:
#define FLASH_TEST_DATA         0x1234567812345678ULL


//   helper function  top 
static inline void InvalidateICache(void)
{
 c00163c:	b480      	push	{r7}
 c00163e:	af00      	add	r7, sp, #0
    #if (__ICACHE_PRESENT == 1U)
    SCB->ICIALLU = 0UL;  // Invalidate entire I-Cache
    __DSB();
    __ISB();
    #endif
}
 c001640:	bf00      	nop
 c001642:	46bd      	mov	sp, r7
 c001644:	f85d 7b04 	ldr.w	r7, [sp], #4
 c001648:	4770      	bx	lr
	...

0c00164c <__acle_se_SECURE_RegisterPrintCallback>:
/* Private functions ---------------------------------------------------------*/



CMSE_NS_ENTRY void SECURE_RegisterPrintCallback(void *callback)
{
 c00164c:	b480      	push	{r7}
 c00164e:	b083      	sub	sp, #12
 c001650:	af00      	add	r7, sp, #0
 c001652:	6078      	str	r0, [r7, #4]
    ns_print_cb = (void (*)(const char *))cmse_nsfptr_create(callback);
 c001654:	687b      	ldr	r3, [r7, #4]
 c001656:	f023 0301 	bic.w	r3, r3, #1
 c00165a:	461a      	mov	r2, r3
 c00165c:	4b1d      	ldr	r3, [pc, #116]	@ (c0016d4 <__acle_se_SECURE_RegisterPrintCallback+0x88>)
 c00165e:	601a      	str	r2, [r3, #0]
}
 c001660:	bf00      	nop
 c001662:	370c      	adds	r7, #12
 c001664:	46bd      	mov	sp, r7
 c001666:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00166a:	4670      	mov	r0, lr
 c00166c:	4671      	mov	r1, lr
 c00166e:	4672      	mov	r2, lr
 c001670:	4673      	mov	r3, lr
 c001672:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001676:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00167a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00167e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001682:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001686:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00168a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00168e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001692:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001696:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00169a:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00169e:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0016a2:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0016a6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0016aa:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0016ae:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0016b2:	f38e 8c00 	msr	CPSR_fs, lr
 c0016b6:	b410      	push	{r4}
 c0016b8:	eef1 ca10 	vmrs	ip, fpscr
 c0016bc:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0016c0:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0016c4:	ea0c 0c04 	and.w	ip, ip, r4
 c0016c8:	eee1 ca10 	vmsr	fpscr, ip
 c0016cc:	bc10      	pop	{r4}
 c0016ce:	46f4      	mov	ip, lr
 c0016d0:	4774      	bxns	lr
 c0016d2:	bf00      	nop
 c0016d4:	300000c4 	.word	0x300000c4

0c0016d8 <__acle_se_SECURE_Print>:

CMSE_NS_ENTRY void SECURE_Print(const char *msg)
{
 c0016d8:	b580      	push	{r7, lr}
 c0016da:	b082      	sub	sp, #8
 c0016dc:	af00      	add	r7, sp, #0
 c0016de:	6078      	str	r0, [r7, #4]
    if (ns_print_cb)
 c0016e0:	4b20      	ldr	r3, [pc, #128]	@ (c001764 <__acle_se_SECURE_Print+0x8c>)
 c0016e2:	681b      	ldr	r3, [r3, #0]
 c0016e4:	2b00      	cmp	r3, #0
 c0016e6:	d003      	beq.n	c0016f0 <__acle_se_SECURE_Print+0x18>
    {
        ns_print_cb(msg);
 c0016e8:	4b1e      	ldr	r3, [pc, #120]	@ (c001764 <__acle_se_SECURE_Print+0x8c>)
 c0016ea:	681b      	ldr	r3, [r3, #0]
 c0016ec:	6878      	ldr	r0, [r7, #4]
 c0016ee:	4798      	blx	r3
    }
}
 c0016f0:	bf00      	nop
 c0016f2:	3708      	adds	r7, #8
 c0016f4:	46bd      	mov	sp, r7
 c0016f6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0016fa:	4670      	mov	r0, lr
 c0016fc:	4671      	mov	r1, lr
 c0016fe:	4672      	mov	r2, lr
 c001700:	4673      	mov	r3, lr
 c001702:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001706:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00170a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00170e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001712:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001716:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00171a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00171e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001722:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001726:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00172a:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00172e:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001732:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001736:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00173a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c00173e:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001742:	f38e 8c00 	msr	CPSR_fs, lr
 c001746:	b410      	push	{r4}
 c001748:	eef1 ca10 	vmrs	ip, fpscr
 c00174c:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001750:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001754:	ea0c 0c04 	and.w	ip, ip, r4
 c001758:	eee1 ca10 	vmsr	fpscr, ip
 c00175c:	bc10      	pop	{r4}
 c00175e:	46f4      	mov	ip, lr
 c001760:	4774      	bxns	lr
 c001762:	bf00      	nop
 c001764:	300000c4 	.word	0x300000c4

0c001768 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
 c001768:	b2c0      	uxtb	r0, r0
 c00176a:	b480      	push	{r7}
 c00176c:	b083      	sub	sp, #12
 c00176e:	af00      	add	r7, sp, #0
 c001770:	4603      	mov	r3, r0
 c001772:	6039      	str	r1, [r7, #0]
 c001774:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
 c001776:	683b      	ldr	r3, [r7, #0]
 c001778:	2b00      	cmp	r3, #0
 c00177a:	d00d      	beq.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
  {
    switch(CallbackId)
 c00177c:	79fb      	ldrb	r3, [r7, #7]
 c00177e:	2b00      	cmp	r3, #0
 c001780:	d002      	beq.n	c001788 <__acle_se_SECURE_RegisterCallback+0x20>
 c001782:	2b01      	cmp	r3, #1
 c001784:	d004      	beq.n	c001790 <__acle_se_SECURE_RegisterCallback+0x28>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
 c001786:	e007      	b.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
        pSecureFaultCallback = func;
 c001788:	4a20      	ldr	r2, [pc, #128]	@ (c00180c <__acle_se_SECURE_RegisterCallback+0xa4>)
 c00178a:	683b      	ldr	r3, [r7, #0]
 c00178c:	6013      	str	r3, [r2, #0]
        break;
 c00178e:	e003      	b.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
        pSecureErrorCallback = func;
 c001790:	4a1f      	ldr	r2, [pc, #124]	@ (c001810 <__acle_se_SECURE_RegisterCallback+0xa8>)
 c001792:	683b      	ldr	r3, [r7, #0]
 c001794:	6013      	str	r3, [r2, #0]
        break;
 c001796:	bf00      	nop
    }
  }
}
 c001798:	bf00      	nop
 c00179a:	370c      	adds	r7, #12
 c00179c:	46bd      	mov	sp, r7
 c00179e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0017a2:	4670      	mov	r0, lr
 c0017a4:	4671      	mov	r1, lr
 c0017a6:	4672      	mov	r2, lr
 c0017a8:	4673      	mov	r3, lr
 c0017aa:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0017ae:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0017b2:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0017b6:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0017ba:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0017be:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0017c2:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0017c6:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0017ca:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0017ce:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0017d2:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0017d6:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0017da:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0017de:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0017e2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0017e6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0017ea:	f38e 8c00 	msr	CPSR_fs, lr
 c0017ee:	b410      	push	{r4}
 c0017f0:	eef1 ca10 	vmrs	ip, fpscr
 c0017f4:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0017f8:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0017fc:	ea0c 0c04 	and.w	ip, ip, r4
 c001800:	eee1 ca10 	vmsr	fpscr, ip
 c001804:	bc10      	pop	{r4}
 c001806:	46f4      	mov	ip, lr
 c001808:	4774      	bxns	lr
 c00180a:	bf00      	nop
 c00180c:	300000bc 	.word	0x300000bc
 c001810:	300000c0 	.word	0x300000c0

0c001814 <__acle_se_SECURE_LEDToggle>:
/**
  * @brief  Secure treatment of non-secure push button interrupt.
  * @retval None
  */
/*CMSE_NS_ENTRY*/secureportNON_SECURE_CALLABLE void SECURE_LEDToggle(void)
{
 c001814:	b580      	push	{r7, lr}
 c001816:	af00      	add	r7, sp, #0
  BSP_LED_Toggle(LED1);
 c001818:	2000      	movs	r0, #0
 c00181a:	f002 f845 	bl	c0038a8 <BSP_LED_Toggle>
}
 c00181e:	bf00      	nop
 c001820:	46bd      	mov	sp, r7
 c001822:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c001826:	4670      	mov	r0, lr
 c001828:	4671      	mov	r1, lr
 c00182a:	4672      	mov	r2, lr
 c00182c:	4673      	mov	r3, lr
 c00182e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001832:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001836:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00183a:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00183e:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001842:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001846:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00184a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00184e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001852:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001856:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00185a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00185e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001862:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001866:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c00186a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00186e:	f38e 8c00 	msr	CPSR_fs, lr
 c001872:	b410      	push	{r4}
 c001874:	eef1 ca10 	vmrs	ip, fpscr
 c001878:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c00187c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001880:	ea0c 0c04 	and.w	ip, ip, r4
 c001884:	eee1 ca10 	vmsr	fpscr, ip
 c001888:	bc10      	pop	{r4}
 c00188a:	46f4      	mov	ip, lr
 c00188c:	4774      	bxns	lr
	...

0c001890 <__acle_se_SECURE_CopyMessage>:



__attribute__((cmse_nonsecure_entry))
void SECURE_CopyMessage(char* buffer, size_t maxlen)
{
 c001890:	b580      	push	{r7, lr}
 c001892:	b084      	sub	sp, #16
 c001894:	af00      	add	r7, sp, #0
 c001896:	6078      	str	r0, [r7, #4]
 c001898:	6039      	str	r1, [r7, #0]
    if (!buffer || maxlen == 0) return;
 c00189a:	687b      	ldr	r3, [r7, #4]
 c00189c:	2b00      	cmp	r3, #0
 c00189e:	d012      	beq.n	c0018c6 <__acle_se_SECURE_CopyMessage+0x36>
 c0018a0:	683b      	ldr	r3, [r7, #0]
 c0018a2:	2b00      	cmp	r3, #0
 c0018a4:	d00f      	beq.n	c0018c6 <__acle_se_SECURE_CopyMessage+0x36>
    const char* secure_msg = "AAA test in secure";
 c0018a6:	4b24      	ldr	r3, [pc, #144]	@ (c001938 <__acle_se_SECURE_CopyMessage+0xa8>)
 c0018a8:	60fb      	str	r3, [r7, #12]
    strncpy(buffer, secure_msg, maxlen - 1);
 c0018aa:	683b      	ldr	r3, [r7, #0]
 c0018ac:	3b01      	subs	r3, #1
 c0018ae:	461a      	mov	r2, r3
 c0018b0:	68f9      	ldr	r1, [r7, #12]
 c0018b2:	6878      	ldr	r0, [r7, #4]
 c0018b4:	f004 f908 	bl	c005ac8 <strncpy>
    buffer[maxlen - 1] = '\0';
 c0018b8:	683b      	ldr	r3, [r7, #0]
 c0018ba:	3b01      	subs	r3, #1
 c0018bc:	687a      	ldr	r2, [r7, #4]
 c0018be:	4413      	add	r3, r2
 c0018c0:	2200      	movs	r2, #0
 c0018c2:	701a      	strb	r2, [r3, #0]
 c0018c4:	e000      	b.n	c0018c8 <__acle_se_SECURE_CopyMessage+0x38>
    if (!buffer || maxlen == 0) return;
 c0018c6:	bf00      	nop
}
 c0018c8:	3710      	adds	r7, #16
 c0018ca:	46bd      	mov	sp, r7
 c0018cc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0018d0:	4670      	mov	r0, lr
 c0018d2:	4671      	mov	r1, lr
 c0018d4:	4672      	mov	r2, lr
 c0018d6:	4673      	mov	r3, lr
 c0018d8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0018dc:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0018e0:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0018e4:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0018e8:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0018ec:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0018f0:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0018f4:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0018f8:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0018fc:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001900:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001904:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001908:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00190c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001910:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001914:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001918:	f38e 8c00 	msr	CPSR_fs, lr
 c00191c:	b410      	push	{r4}
 c00191e:	eef1 ca10 	vmrs	ip, fpscr
 c001922:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001926:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00192a:	ea0c 0c04 	and.w	ip, ip, r4
 c00192e:	eee1 ca10 	vmsr	fpscr, ip
 c001932:	bc10      	pop	{r4}
 c001934:	46f4      	mov	ip, lr
 c001936:	4774      	bxns	lr
 c001938:	0c0066d8 	.word	0x0c0066d8

0c00193c <__acle_se_SECURE_ComputeHMAC>:
static uint8_t secure_digest[SHA256_DIGEST_SIZE];


__attribute__((cmse_nonsecure_entry))
void SECURE_ComputeHMAC(uint8_t *output_digest, size_t maxlen)
{
 c00193c:	b5b0      	push	{r4, r5, r7, lr}
 c00193e:	b08c      	sub	sp, #48	@ 0x30
 c001940:	af00      	add	r7, sp, #0
 c001942:	6078      	str	r0, [r7, #4]
 c001944:	6039      	str	r1, [r7, #0]

    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001946:	687b      	ldr	r3, [r7, #4]
 c001948:	2b00      	cmp	r3, #0
 c00194a:	d047      	beq.n	c0019dc <__acle_se_SECURE_ComputeHMAC+0xa0>
 c00194c:	683b      	ldr	r3, [r7, #0]
 c00194e:	2b1f      	cmp	r3, #31
 c001950:	d944      	bls.n	c0019dc <__acle_se_SECURE_ComputeHMAC+0xa0>
  __ASM volatile ("cpsid i" : : : "memory");
 c001952:	b672      	cpsid	i
}
 c001954:	bf00      	nop

    __disable_irq();

    for (volatile uint32_t i = 0; i < 10000000; i++);
 c001956:	2300      	movs	r3, #0
 c001958:	60fb      	str	r3, [r7, #12]
 c00195a:	e002      	b.n	c001962 <__acle_se_SECURE_ComputeHMAC+0x26>
 c00195c:	68fb      	ldr	r3, [r7, #12]
 c00195e:	3301      	adds	r3, #1
 c001960:	60fb      	str	r3, [r7, #12]
 c001962:	68fb      	ldr	r3, [r7, #12]
 c001964:	4a3a      	ldr	r2, [pc, #232]	@ (c001a50 <__acle_se_SECURE_ComputeHMAC+0x114>)
 c001966:	4293      	cmp	r3, r2
 c001968:	d3f8      	bcc.n	c00195c <__acle_se_SECURE_ComputeHMAC+0x20>
  __ASM volatile ("cpsie i" : : : "memory");
 c00196a:	b662      	cpsie	i
}
 c00196c:	bf00      	nop
	__enable_irq();

    const uint8_t message[] = "Temp Temp from Secure World!";
 c00196e:	4b39      	ldr	r3, [pc, #228]	@ (c001a54 <__acle_se_SECURE_ComputeHMAC+0x118>)
 c001970:	f107 0410 	add.w	r4, r7, #16
 c001974:	461d      	mov	r5, r3
 c001976:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001978:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c00197a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c00197e:	c407      	stmia	r4!, {r0, r1, r2}
 c001980:	7023      	strb	r3, [r4, #0]

    hmac_sha256_initialize(&secure_hmac_ctx, secure_key, strlen((const char*)secure_key));
 c001982:	220b      	movs	r2, #11
 c001984:	4934      	ldr	r1, [pc, #208]	@ (c001a58 <__acle_se_SECURE_ComputeHMAC+0x11c>)
 c001986:	4835      	ldr	r0, [pc, #212]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c001988:	f7ff fbc0 	bl	c00110c <hmac_sha256_initialize>
//    hmac_sha256_update(&secure_hmac_ctx, message, strlen((const char*)message));
    hmac_sha256_finalize(&secure_hmac_ctx, NULL, 0);
 c00198c:	2200      	movs	r2, #0
 c00198e:	2100      	movs	r1, #0
 c001990:	4832      	ldr	r0, [pc, #200]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c001992:	f7ff fc3c 	bl	c00120e <hmac_sha256_finalize>

    for (volatile uint32_t i = 0; i < 10000000; i++);
 c001996:	2300      	movs	r3, #0
 c001998:	60bb      	str	r3, [r7, #8]
 c00199a:	e002      	b.n	c0019a2 <__acle_se_SECURE_ComputeHMAC+0x66>
 c00199c:	68bb      	ldr	r3, [r7, #8]
 c00199e:	3301      	adds	r3, #1
 c0019a0:	60bb      	str	r3, [r7, #8]
 c0019a2:	68bb      	ldr	r3, [r7, #8]
 c0019a4:	4a2a      	ldr	r2, [pc, #168]	@ (c001a50 <__acle_se_SECURE_ComputeHMAC+0x114>)
 c0019a6:	4293      	cmp	r3, r2
 c0019a8:	d3f8      	bcc.n	c00199c <__acle_se_SECURE_ComputeHMAC+0x60>

    memcpy(secure_digest, secure_hmac_ctx.digest, SHA256_DIGEST_SIZE);
 c0019aa:	4a2d      	ldr	r2, [pc, #180]	@ (c001a60 <__acle_se_SECURE_ComputeHMAC+0x124>)
 c0019ac:	4b2b      	ldr	r3, [pc, #172]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c0019ae:	4614      	mov	r4, r2
 c0019b0:	461d      	mov	r5, r3
 c0019b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0019b6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c0019ba:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}


	memcpy(output_digest, secure_digest, SHA256_DIGEST_SIZE);
 c0019be:	687b      	ldr	r3, [r7, #4]
 c0019c0:	4a27      	ldr	r2, [pc, #156]	@ (c001a60 <__acle_se_SECURE_ComputeHMAC+0x124>)
 c0019c2:	461c      	mov	r4, r3
 c0019c4:	4615      	mov	r5, r2
 c0019c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019c8:	6020      	str	r0, [r4, #0]
 c0019ca:	6061      	str	r1, [r4, #4]
 c0019cc:	60a2      	str	r2, [r4, #8]
 c0019ce:	60e3      	str	r3, [r4, #12]
 c0019d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019d2:	6120      	str	r0, [r4, #16]
 c0019d4:	6161      	str	r1, [r4, #20]
 c0019d6:	61a2      	str	r2, [r4, #24]
 c0019d8:	61e3      	str	r3, [r4, #28]
 c0019da:	e000      	b.n	c0019de <__acle_se_SECURE_ComputeHMAC+0xa2>
    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c0019dc:	bf00      	nop


}
 c0019de:	3730      	adds	r7, #48	@ 0x30
 c0019e0:	46bd      	mov	sp, r7
 c0019e2:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c0019e6:	4670      	mov	r0, lr
 c0019e8:	4671      	mov	r1, lr
 c0019ea:	4672      	mov	r2, lr
 c0019ec:	4673      	mov	r3, lr
 c0019ee:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0019f2:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0019f6:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0019fa:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0019fe:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001a02:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001a06:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001a0a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001a0e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001a12:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001a16:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001a1a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001a1e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001a22:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001a26:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001a2a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001a2e:	f38e 8c00 	msr	CPSR_fs, lr
 c001a32:	b410      	push	{r4}
 c001a34:	eef1 ca10 	vmrs	ip, fpscr
 c001a38:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001a3c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001a40:	ea0c 0c04 	and.w	ip, ip, r4
 c001a44:	eee1 ca10 	vmsr	fpscr, ip
 c001a48:	bc10      	pop	{r4}
 c001a4a:	46f4      	mov	ip, lr
 c001a4c:	4774      	bxns	lr
 c001a4e:	bf00      	nop
 c001a50:	00989680 	.word	0x00989680
 c001a54:	0c0066ec 	.word	0x0c0066ec
 c001a58:	0c006c70 	.word	0x0c006c70
 c001a5c:	300000c8 	.word	0x300000c8
 c001a60:	300001b0 	.word	0x300001b0

0c001a64 <__acle_se_SECURE_LinearHMAC>:



__attribute__((cmse_nonsecure_entry))
void SECURE_LinearHMAC(uint8_t *output_digest, size_t maxlen)
{
 c001a64:	b5b0      	push	{r4, r5, r7, lr}
 c001a66:	b084      	sub	sp, #16
 c001a68:	af00      	add	r7, sp, #0
 c001a6a:	6078      	str	r0, [r7, #4]
 c001a6c:	6039      	str	r1, [r7, #0]


//    __disable_irq();
    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) {
 c001a6e:	687b      	ldr	r3, [r7, #4]
 c001a70:	2b00      	cmp	r3, #0
 c001a72:	d034      	beq.n	c001ade <__acle_se_SECURE_LinearHMAC+0x7a>
 c001a74:	683b      	ldr	r3, [r7, #0]
 c001a76:	2b1f      	cmp	r3, #31
 c001a78:	d931      	bls.n	c001ade <__acle_se_SECURE_LinearHMAC+0x7a>
        return;
    }

    // Optional: Fill real_memory with known data for consistent testing
    for (int i = 0; i < TOTAL_SIZE; i++) {
 c001a7a:	2300      	movs	r3, #0
 c001a7c:	60fb      	str	r3, [r7, #12]
 c001a7e:	e009      	b.n	c001a94 <__acle_se_SECURE_LinearHMAC+0x30>
        real_memory[i] = i & 0xFF;  // test pattern
 c001a80:	4b33      	ldr	r3, [pc, #204]	@ (c001b50 <__acle_se_SECURE_LinearHMAC+0xec>)
 c001a82:	681a      	ldr	r2, [r3, #0]
 c001a84:	68fb      	ldr	r3, [r7, #12]
 c001a86:	4413      	add	r3, r2
 c001a88:	68fa      	ldr	r2, [r7, #12]
 c001a8a:	b2d2      	uxtb	r2, r2
 c001a8c:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < TOTAL_SIZE; i++) {
 c001a8e:	68fb      	ldr	r3, [r7, #12]
 c001a90:	3301      	adds	r3, #1
 c001a92:	60fb      	str	r3, [r7, #12]
 c001a94:	68fb      	ldr	r3, [r7, #12]
 c001a96:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 c001a9a:	dbf1      	blt.n	c001a80 <__acle_se_SECURE_LinearHMAC+0x1c>
    }

//    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
    hmac_sha256_initialize(&hmac, key, sizeof(key));
 c001a9c:	220f      	movs	r2, #15
 c001a9e:	492d      	ldr	r1, [pc, #180]	@ (c001b54 <__acle_se_SECURE_LinearHMAC+0xf0>)
 c001aa0:	482d      	ldr	r0, [pc, #180]	@ (c001b58 <__acle_se_SECURE_LinearHMAC+0xf4>)
 c001aa2:	f7ff fb33 	bl	c00110c <hmac_sha256_initialize>


    // Process blocks sequentially (not shuffled)
    hmac_sha256_update(&hmac, real_memory, TOTAL_SIZE);
 c001aa6:	4b2a      	ldr	r3, [pc, #168]	@ (c001b50 <__acle_se_SECURE_LinearHMAC+0xec>)
 c001aa8:	681b      	ldr	r3, [r3, #0]
 c001aaa:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 c001aae:	4619      	mov	r1, r3
 c001ab0:	4829      	ldr	r0, [pc, #164]	@ (c001b58 <__acle_se_SECURE_LinearHMAC+0xf4>)
 c001ab2:	f7ff fb9b 	bl	c0011ec <hmac_sha256_update>
//    for (int i = 0; i < BLOCKS; i++) {
//        const uint8_t *block = &real_memory[i * BLOCK_SIZE];
//        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
//    }

    hmac_sha256_finalize(&hmac, NULL, 0);
 c001ab6:	2200      	movs	r2, #0
 c001ab8:	2100      	movs	r1, #0
 c001aba:	4827      	ldr	r0, [pc, #156]	@ (c001b58 <__acle_se_SECURE_LinearHMAC+0xf4>)
 c001abc:	f7ff fba7 	bl	c00120e <hmac_sha256_finalize>
    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c001ac0:	687b      	ldr	r3, [r7, #4]
 c001ac2:	4a25      	ldr	r2, [pc, #148]	@ (c001b58 <__acle_se_SECURE_LinearHMAC+0xf4>)
 c001ac4:	461c      	mov	r4, r3
 c001ac6:	4615      	mov	r5, r2
 c001ac8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001aca:	6020      	str	r0, [r4, #0]
 c001acc:	6061      	str	r1, [r4, #4]
 c001ace:	60a2      	str	r2, [r4, #8]
 c001ad0:	60e3      	str	r3, [r4, #12]
 c001ad2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001ad4:	6120      	str	r0, [r4, #16]
 c001ad6:	6161      	str	r1, [r4, #20]
 c001ad8:	61a2      	str	r2, [r4, #24]
 c001ada:	61e3      	str	r3, [r4, #28]
 c001adc:	e000      	b.n	c001ae0 <__acle_se_SECURE_LinearHMAC+0x7c>
        return;
 c001ade:	bf00      	nop


}
 c001ae0:	3710      	adds	r7, #16
 c001ae2:	46bd      	mov	sp, r7
 c001ae4:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c001ae8:	4670      	mov	r0, lr
 c001aea:	4671      	mov	r1, lr
 c001aec:	4672      	mov	r2, lr
 c001aee:	4673      	mov	r3, lr
 c001af0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001af4:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001af8:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001afc:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001b00:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001b04:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001b08:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001b0c:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001b10:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001b14:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001b18:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001b1c:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001b20:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001b24:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001b28:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001b2c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001b30:	f38e 8c00 	msr	CPSR_fs, lr
 c001b34:	b410      	push	{r4}
 c001b36:	eef1 ca10 	vmrs	ip, fpscr
 c001b3a:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001b3e:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001b42:	ea0c 0c04 	and.w	ip, ip, r4
 c001b46:	eee1 ca10 	vmsr	fpscr, ip
 c001b4a:	bc10      	pop	{r4}
 c001b4c:	46f4      	mov	ip, lr
 c001b4e:	4774      	bxns	lr
 c001b50:	30000000 	.word	0x30000000
 c001b54:	0c006c7c 	.word	0x0c006c7c
 c001b58:	300001d0 	.word	0x300001d0

0c001b5c <__acle_se_SECURE_ShuffledHMAC>:



__attribute__((cmse_nonsecure_entry))
void SECURE_ShuffledHMAC(uint8_t *output_digest, size_t maxlen)
{
 c001b5c:	b5b0      	push	{r4, r5, r7, lr}
 c001b5e:	b088      	sub	sp, #32
 c001b60:	af00      	add	r7, sp, #0
 c001b62:	6078      	str	r0, [r7, #4]
 c001b64:	6039      	str	r1, [r7, #0]

	  if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001b66:	687b      	ldr	r3, [r7, #4]
 c001b68:	2b00      	cmp	r3, #0
 c001b6a:	d06a      	beq.n	c001c42 <__acle_se_SECURE_ShuffledHMAC+0xe6>
 c001b6c:	683b      	ldr	r3, [r7, #0]
 c001b6e:	2b1f      	cmp	r3, #31
 c001b70:	d967      	bls.n	c001c42 <__acle_se_SECURE_ShuffledHMAC+0xe6>

	    static int indices[BLOCKS];
	    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c001b72:	2300      	movs	r3, #0
 c001b74:	61fb      	str	r3, [r7, #28]
 c001b76:	e007      	b.n	c001b88 <__acle_se_SECURE_ShuffledHMAC+0x2c>
 c001b78:	494e      	ldr	r1, [pc, #312]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001b7a:	69fb      	ldr	r3, [r7, #28]
 c001b7c:	69fa      	ldr	r2, [r7, #28]
 c001b7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 c001b82:	69fb      	ldr	r3, [r7, #28]
 c001b84:	3301      	adds	r3, #1
 c001b86:	61fb      	str	r3, [r7, #28]
 c001b88:	69fb      	ldr	r3, [r7, #28]
 c001b8a:	2b3f      	cmp	r3, #63	@ 0x3f
 c001b8c:	ddf4      	ble.n	c001b78 <__acle_se_SECURE_ShuffledHMAC+0x1c>
	    // Simple shuffle without srand for now


	      srand(42);
 c001b8e:	202a      	movs	r0, #42	@ 0x2a
 c001b90:	f003 fd1c 	bl	c0055cc <srand>

	      for (int i = BLOCKS - 1; i > 0; i--) {
 c001b94:	233f      	movs	r3, #63	@ 0x3f
 c001b96:	61bb      	str	r3, [r7, #24]
 c001b98:	e01f      	b.n	c001bda <__acle_se_SECURE_ShuffledHMAC+0x7e>
	          int j = rand() % (i + 1);
 c001b9a:	f003 fd45 	bl	c005628 <rand>
 c001b9e:	4602      	mov	r2, r0
 c001ba0:	69bb      	ldr	r3, [r7, #24]
 c001ba2:	3301      	adds	r3, #1
 c001ba4:	fb92 f1f3 	sdiv	r1, r2, r3
 c001ba8:	fb01 f303 	mul.w	r3, r1, r3
 c001bac:	1ad3      	subs	r3, r2, r3
 c001bae:	60fb      	str	r3, [r7, #12]
	          int tmp = indices[i];
 c001bb0:	4a40      	ldr	r2, [pc, #256]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bb2:	69bb      	ldr	r3, [r7, #24]
 c001bb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c001bb8:	60bb      	str	r3, [r7, #8]
	          indices[i] = indices[j];
 c001bba:	4a3e      	ldr	r2, [pc, #248]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bbc:	68fb      	ldr	r3, [r7, #12]
 c001bbe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 c001bc2:	493c      	ldr	r1, [pc, #240]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bc4:	69bb      	ldr	r3, [r7, #24]
 c001bc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	          indices[j] = tmp;
 c001bca:	493a      	ldr	r1, [pc, #232]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bcc:	68fb      	ldr	r3, [r7, #12]
 c001bce:	68ba      	ldr	r2, [r7, #8]
 c001bd0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	      for (int i = BLOCKS - 1; i > 0; i--) {
 c001bd4:	69bb      	ldr	r3, [r7, #24]
 c001bd6:	3b01      	subs	r3, #1
 c001bd8:	61bb      	str	r3, [r7, #24]
 c001bda:	69bb      	ldr	r3, [r7, #24]
 c001bdc:	2b00      	cmp	r3, #0
 c001bde:	dcdc      	bgt.n	c001b9a <__acle_se_SECURE_ShuffledHMAC+0x3e>
	      }

	    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
 c001be0:	220e      	movs	r2, #14
 c001be2:	4935      	ldr	r1, [pc, #212]	@ (c001cb8 <__acle_se_SECURE_ShuffledHMAC+0x15c>)
 c001be4:	4835      	ldr	r0, [pc, #212]	@ (c001cbc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001be6:	f7ff fa91 	bl	c00110c <hmac_sha256_initialize>
	    for (int i = 0; i < BLOCKS; i++) {
 c001bea:	2300      	movs	r3, #0
 c001bec:	617b      	str	r3, [r7, #20]
 c001bee:	e011      	b.n	c001c14 <__acle_se_SECURE_ShuffledHMAC+0xb8>
	        const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c001bf0:	4b33      	ldr	r3, [pc, #204]	@ (c001cc0 <__acle_se_SECURE_ShuffledHMAC+0x164>)
 c001bf2:	681b      	ldr	r3, [r3, #0]
 c001bf4:	492f      	ldr	r1, [pc, #188]	@ (c001cb4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bf6:	697a      	ldr	r2, [r7, #20]
 c001bf8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c001bfc:	0312      	lsls	r2, r2, #12
 c001bfe:	4413      	add	r3, r2
 c001c00:	613b      	str	r3, [r7, #16]
//	        __disable_irq();
	        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c001c02:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 c001c06:	6939      	ldr	r1, [r7, #16]
 c001c08:	482c      	ldr	r0, [pc, #176]	@ (c001cbc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c0a:	f7ff faef 	bl	c0011ec <hmac_sha256_update>
	    for (int i = 0; i < BLOCKS; i++) {
 c001c0e:	697b      	ldr	r3, [r7, #20]
 c001c10:	3301      	adds	r3, #1
 c001c12:	617b      	str	r3, [r7, #20]
 c001c14:	697b      	ldr	r3, [r7, #20]
 c001c16:	2b3f      	cmp	r3, #63	@ 0x3f
 c001c18:	ddea      	ble.n	c001bf0 <__acle_se_SECURE_ShuffledHMAC+0x94>
//	        __enable_irq();
	    }
	    hmac_sha256_finalize(&hmac, NULL, 0);
 c001c1a:	2200      	movs	r2, #0
 c001c1c:	2100      	movs	r1, #0
 c001c1e:	4827      	ldr	r0, [pc, #156]	@ (c001cbc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c20:	f7ff faf5 	bl	c00120e <hmac_sha256_finalize>
	    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c001c24:	687b      	ldr	r3, [r7, #4]
 c001c26:	4a25      	ldr	r2, [pc, #148]	@ (c001cbc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c28:	461c      	mov	r4, r3
 c001c2a:	4615      	mov	r5, r2
 c001c2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001c2e:	6020      	str	r0, [r4, #0]
 c001c30:	6061      	str	r1, [r4, #4]
 c001c32:	60a2      	str	r2, [r4, #8]
 c001c34:	60e3      	str	r3, [r4, #12]
 c001c36:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001c38:	6120      	str	r0, [r4, #16]
 c001c3a:	6161      	str	r1, [r4, #20]
 c001c3c:	61a2      	str	r2, [r4, #24]
 c001c3e:	61e3      	str	r3, [r4, #28]
 c001c40:	e000      	b.n	c001c44 <__acle_se_SECURE_ShuffledHMAC+0xe8>
	  if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001c42:	bf00      	nop



}
 c001c44:	3720      	adds	r7, #32
 c001c46:	46bd      	mov	sp, r7
 c001c48:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c001c4c:	4670      	mov	r0, lr
 c001c4e:	4671      	mov	r1, lr
 c001c50:	4672      	mov	r2, lr
 c001c52:	4673      	mov	r3, lr
 c001c54:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001c58:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001c5c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001c60:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001c64:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001c68:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001c6c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001c70:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001c74:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001c78:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001c7c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001c80:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001c84:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001c88:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001c8c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001c90:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001c94:	f38e 8c00 	msr	CPSR_fs, lr
 c001c98:	b410      	push	{r4}
 c001c9a:	eef1 ca10 	vmrs	ip, fpscr
 c001c9e:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001ca2:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001ca6:	ea0c 0c04 	and.w	ip, ip, r4
 c001caa:	eee1 ca10 	vmsr	fpscr, ip
 c001cae:	bc10      	pop	{r4}
 c001cb0:	46f4      	mov	ip, lr
 c001cb2:	4774      	bxns	lr
 c001cb4:	300002b8 	.word	0x300002b8
 c001cb8:	0c006c7c 	.word	0x0c006c7c
 c001cbc:	300001d0 	.word	0x300001d0
 c001cc0:	30000000 	.word	0x30000000

0c001cc4 <derive_aes_key_iv_from_challenge>:
// ---- Key/IV derivation: HMAC(secret, challenge) -> 32B -> 16B key + 16B iv
static void derive_aes_key_iv_from_challenge(uint8_t key16[16],
                                             uint8_t iv16[16],
                                             const uint8_t *challenge,
                                             size_t clen)
{
 c001cc4:	b580      	push	{r7, lr}
 c001cc6:	b086      	sub	sp, #24
 c001cc8:	af00      	add	r7, sp, #0
 c001cca:	60f8      	str	r0, [r7, #12]
 c001ccc:	60b9      	str	r1, [r7, #8]
 c001cce:	607a      	str	r2, [r7, #4]
 c001cd0:	603b      	str	r3, [r7, #0]
    hmac_sha256_initialize(&hmac, (const uint8_t*)key, strlen(key));
 c001cd2:	220e      	movs	r2, #14
 c001cd4:	4917      	ldr	r1, [pc, #92]	@ (c001d34 <derive_aes_key_iv_from_challenge+0x70>)
 c001cd6:	4818      	ldr	r0, [pc, #96]	@ (c001d38 <derive_aes_key_iv_from_challenge+0x74>)
 c001cd8:	f7ff fa18 	bl	c00110c <hmac_sha256_initialize>
    if (challenge && clen) {
 c001cdc:	687b      	ldr	r3, [r7, #4]
 c001cde:	2b00      	cmp	r3, #0
 c001ce0:	d009      	beq.n	c001cf6 <derive_aes_key_iv_from_challenge+0x32>
 c001ce2:	683b      	ldr	r3, [r7, #0]
 c001ce4:	2b00      	cmp	r3, #0
 c001ce6:	d006      	beq.n	c001cf6 <derive_aes_key_iv_from_challenge+0x32>
        hmac_sha256_update(&hmac, challenge, clen);
 c001ce8:	683b      	ldr	r3, [r7, #0]
 c001cea:	461a      	mov	r2, r3
 c001cec:	6879      	ldr	r1, [r7, #4]
 c001cee:	4812      	ldr	r0, [pc, #72]	@ (c001d38 <derive_aes_key_iv_from_challenge+0x74>)
 c001cf0:	f7ff fa7c 	bl	c0011ec <hmac_sha256_update>
 c001cf4:	e009      	b.n	c001d0a <derive_aes_key_iv_from_challenge+0x46>
    } else {
        // fallback entropy so its never constant
        uint32_t tick = (uint32_t)SysTick->VAL;
 c001cf6:	4b11      	ldr	r3, [pc, #68]	@ (c001d3c <derive_aes_key_iv_from_challenge+0x78>)
 c001cf8:	689b      	ldr	r3, [r3, #8]
 c001cfa:	617b      	str	r3, [r7, #20]
        hmac_sha256_update(&hmac, (uint8_t*)&tick, sizeof(tick));
 c001cfc:	f107 0314 	add.w	r3, r7, #20
 c001d00:	2204      	movs	r2, #4
 c001d02:	4619      	mov	r1, r3
 c001d04:	480c      	ldr	r0, [pc, #48]	@ (c001d38 <derive_aes_key_iv_from_challenge+0x74>)
 c001d06:	f7ff fa71 	bl	c0011ec <hmac_sha256_update>
    }
    hmac_sha256_finalize(&hmac, NULL, 0);
 c001d0a:	2200      	movs	r2, #0
 c001d0c:	2100      	movs	r1, #0
 c001d0e:	480a      	ldr	r0, [pc, #40]	@ (c001d38 <derive_aes_key_iv_from_challenge+0x74>)
 c001d10:	f7ff fa7d 	bl	c00120e <hmac_sha256_finalize>
    memcpy(key16, hmac.digest, 16);
 c001d14:	2210      	movs	r2, #16
 c001d16:	4908      	ldr	r1, [pc, #32]	@ (c001d38 <derive_aes_key_iv_from_challenge+0x74>)
 c001d18:	68f8      	ldr	r0, [r7, #12]
 c001d1a:	f003 ff6c 	bl	c005bf6 <memcpy>
    memcpy(iv16,  hmac.digest + 16, 16);
 c001d1e:	4b08      	ldr	r3, [pc, #32]	@ (c001d40 <derive_aes_key_iv_from_challenge+0x7c>)
 c001d20:	2210      	movs	r2, #16
 c001d22:	4619      	mov	r1, r3
 c001d24:	68b8      	ldr	r0, [r7, #8]
 c001d26:	f003 ff66 	bl	c005bf6 <memcpy>
}
 c001d2a:	bf00      	nop
 c001d2c:	3718      	adds	r7, #24
 c001d2e:	46bd      	mov	sp, r7
 c001d30:	bd80      	pop	{r7, pc}
 c001d32:	bf00      	nop
 c001d34:	0c006c7c 	.word	0x0c006c7c
 c001d38:	300001d0 	.word	0x300001d0
 c001d3c:	e000e010 	.word	0xe000e010
 c001d40:	300001e0 	.word	0x300001e0

0c001d44 <prng_init>:
    uint8_t  buf[16];
    int      idx;   // next unread byte in buf (0..16)
} ctr_prng_t;

static void prng_init(ctr_prng_t *p, const uint8_t key16[16], const uint8_t iv16[16])
{
 c001d44:	b580      	push	{r7, lr}
 c001d46:	b084      	sub	sp, #16
 c001d48:	af00      	add	r7, sp, #0
 c001d4a:	60f8      	str	r0, [r7, #12]
 c001d4c:	60b9      	str	r1, [r7, #8]
 c001d4e:	607a      	str	r2, [r7, #4]
    AES_init_ctx_iv(&p->ctx, key16, iv16);
 c001d50:	68fb      	ldr	r3, [r7, #12]
 c001d52:	687a      	ldr	r2, [r7, #4]
 c001d54:	68b9      	ldr	r1, [r7, #8]
 c001d56:	4618      	mov	r0, r3
 c001d58:	f7fe fb9e 	bl	c000498 <AES_init_ctx_iv>
    memset(p->buf, 0, sizeof(p->buf));
 c001d5c:	68fb      	ldr	r3, [r7, #12]
 c001d5e:	33c0      	adds	r3, #192	@ 0xc0
 c001d60:	2210      	movs	r2, #16
 c001d62:	2100      	movs	r1, #0
 c001d64:	4618      	mov	r0, r3
 c001d66:	f003 fea7 	bl	c005ab8 <memset>
    p->idx = 16; // force refill on first use
 c001d6a:	68fb      	ldr	r3, [r7, #12]
 c001d6c:	2210      	movs	r2, #16
 c001d6e:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
 c001d72:	bf00      	nop
 c001d74:	3710      	adds	r7, #16
 c001d76:	46bd      	mov	sp, r7
 c001d78:	bd80      	pop	{r7, pc}

0c001d7a <prng_refill_block>:

static void prng_refill_block(ctr_prng_t *p)
{
 c001d7a:	b5b0      	push	{r4, r5, r7, lr}
 c001d7c:	b086      	sub	sp, #24
 c001d7e:	af00      	add	r7, sp, #0
 c001d80:	6078      	str	r0, [r7, #4]
    // encrypt zero block  keystream, tiny-AES increments IV internally
    uint8_t zero[16] = {0};
 c001d82:	f107 0308 	add.w	r3, r7, #8
 c001d86:	2200      	movs	r2, #0
 c001d88:	601a      	str	r2, [r3, #0]
 c001d8a:	605a      	str	r2, [r3, #4]
 c001d8c:	609a      	str	r2, [r3, #8]
 c001d8e:	60da      	str	r2, [r3, #12]
    memcpy(p->buf, zero, 16);
 c001d90:	687b      	ldr	r3, [r7, #4]
 c001d92:	33c0      	adds	r3, #192	@ 0xc0
 c001d94:	461d      	mov	r5, r3
 c001d96:	f107 0408 	add.w	r4, r7, #8
 c001d9a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 c001d9c:	6028      	str	r0, [r5, #0]
 c001d9e:	6069      	str	r1, [r5, #4]
 c001da0:	60aa      	str	r2, [r5, #8]
 c001da2:	60eb      	str	r3, [r5, #12]
    AES_CTR_xcrypt_buffer(&p->ctx, p->buf, 16); // p->ctx.Iv auto-increments
 c001da4:	6878      	ldr	r0, [r7, #4]
 c001da6:	687b      	ldr	r3, [r7, #4]
 c001da8:	33c0      	adds	r3, #192	@ 0xc0
 c001daa:	2210      	movs	r2, #16
 c001dac:	4619      	mov	r1, r3
 c001dae:	f7fe fd3b 	bl	c000828 <AES_CTR_xcrypt_buffer>
    p->idx = 0;
 c001db2:	687b      	ldr	r3, [r7, #4]
 c001db4:	2200      	movs	r2, #0
 c001db6:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
 c001dba:	bf00      	nop
 c001dbc:	3718      	adds	r7, #24
 c001dbe:	46bd      	mov	sp, r7
 c001dc0:	bdb0      	pop	{r4, r5, r7, pc}

0c001dc2 <prng_next_u32>:

static uint32_t prng_next_u32(ctr_prng_t *p)
{
 c001dc2:	b580      	push	{r7, lr}
 c001dc4:	b084      	sub	sp, #16
 c001dc6:	af00      	add	r7, sp, #0
 c001dc8:	6078      	str	r0, [r7, #4]
    if (p->idx > 12) {           // not enough bytes left  refill
 c001dca:	687b      	ldr	r3, [r7, #4]
 c001dcc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001dd0:	2b0c      	cmp	r3, #12
 c001dd2:	dd02      	ble.n	c001dda <prng_next_u32+0x18>
        prng_refill_block(p);
 c001dd4:	6878      	ldr	r0, [r7, #4]
 c001dd6:	f7ff ffd0 	bl	c001d7a <prng_refill_block>
    }
    uint32_t v;
    memcpy(&v, &p->buf[p->idx], 4);
 c001dda:	687b      	ldr	r3, [r7, #4]
 c001ddc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001de0:	33c0      	adds	r3, #192	@ 0xc0
 c001de2:	687a      	ldr	r2, [r7, #4]
 c001de4:	4413      	add	r3, r2
 c001de6:	681b      	ldr	r3, [r3, #0]
 c001de8:	60fb      	str	r3, [r7, #12]
    p->idx += 4;
 c001dea:	687b      	ldr	r3, [r7, #4]
 c001dec:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001df0:	1d1a      	adds	r2, r3, #4
 c001df2:	687b      	ldr	r3, [r7, #4]
 c001df4:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
    return v;
 c001df8:	68fb      	ldr	r3, [r7, #12]
}
 c001dfa:	4618      	mov	r0, r3
 c001dfc:	3710      	adds	r7, #16
 c001dfe:	46bd      	mov	sp, r7
 c001e00:	bd80      	pop	{r7, pc}

0c001e02 <prng_uniform_u32>:

// unbiased integer in [0, n)
static int prng_uniform_u32(ctr_prng_t *p, int n)
{
 c001e02:	b580      	push	{r7, lr}
 c001e04:	b084      	sub	sp, #16
 c001e06:	af00      	add	r7, sp, #0
 c001e08:	6078      	str	r0, [r7, #4]
 c001e0a:	6039      	str	r1, [r7, #0]
    // rejection sampling to avoid modulo bias
    const uint32_t lim = 0xFFFFFFFFu - (0xFFFFFFFFu % (uint32_t)n);
 c001e0c:	683b      	ldr	r3, [r7, #0]
 c001e0e:	f04f 32ff 	mov.w	r2, #4294967295
 c001e12:	fbb2 f1f3 	udiv	r1, r2, r3
 c001e16:	fb01 f303 	mul.w	r3, r1, r3
 c001e1a:	1ad3      	subs	r3, r2, r3
 c001e1c:	43db      	mvns	r3, r3
 c001e1e:	60fb      	str	r3, [r7, #12]
    for (;;) {
        uint32_t r = prng_next_u32(p);
 c001e20:	6878      	ldr	r0, [r7, #4]
 c001e22:	f7ff ffce 	bl	c001dc2 <prng_next_u32>
 c001e26:	60b8      	str	r0, [r7, #8]
        if (r < lim) return (int)(r % (uint32_t)n);
 c001e28:	68ba      	ldr	r2, [r7, #8]
 c001e2a:	68fb      	ldr	r3, [r7, #12]
 c001e2c:	429a      	cmp	r2, r3
 c001e2e:	d2f7      	bcs.n	c001e20 <prng_uniform_u32+0x1e>
 c001e30:	683a      	ldr	r2, [r7, #0]
 c001e32:	68bb      	ldr	r3, [r7, #8]
 c001e34:	fbb3 f1f2 	udiv	r1, r3, r2
 c001e38:	fb01 f202 	mul.w	r2, r1, r2
 c001e3c:	1a9b      	subs	r3, r3, r2
 c001e3e:	bf00      	nop
    }
}
 c001e40:	4618      	mov	r0, r3
 c001e42:	3710      	adds	r7, #16
 c001e44:	46bd      	mov	sp, r7
 c001e46:	bd80      	pop	{r7, pc}

0c001e48 <shuffle_secure_aes_ctr>:

// ---- FisherYates using the PRNG above
static void shuffle_secure_aes_ctr(int *arr, int n,
                                   const uint8_t key16[16],
                                   const uint8_t iv16[16])
{
 c001e48:	b580      	push	{r7, lr}
 c001e4a:	b0bc      	sub	sp, #240	@ 0xf0
 c001e4c:	af00      	add	r7, sp, #0
 c001e4e:	60f8      	str	r0, [r7, #12]
 c001e50:	60b9      	str	r1, [r7, #8]
 c001e52:	607a      	str	r2, [r7, #4]
 c001e54:	603b      	str	r3, [r7, #0]
    ctr_prng_t prng;
    prng_init(&prng, key16, iv16);
 c001e56:	f107 0310 	add.w	r3, r7, #16
 c001e5a:	683a      	ldr	r2, [r7, #0]
 c001e5c:	6879      	ldr	r1, [r7, #4]
 c001e5e:	4618      	mov	r0, r3
 c001e60:	f7ff ff70 	bl	c001d44 <prng_init>

    for (int i = n - 1; i > 0; i--) {
 c001e64:	68bb      	ldr	r3, [r7, #8]
 c001e66:	3b01      	subs	r3, #1
 c001e68:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 c001e6c:	e02b      	b.n	c001ec6 <shuffle_secure_aes_ctr+0x7e>
        int j = prng_uniform_u32(&prng, i + 1);
 c001e6e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001e72:	1c5a      	adds	r2, r3, #1
 c001e74:	f107 0310 	add.w	r3, r7, #16
 c001e78:	4611      	mov	r1, r2
 c001e7a:	4618      	mov	r0, r3
 c001e7c:	f7ff ffc1 	bl	c001e02 <prng_uniform_u32>
 c001e80:	f8c7 00e8 	str.w	r0, [r7, #232]	@ 0xe8
        int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
 c001e84:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001e88:	009b      	lsls	r3, r3, #2
 c001e8a:	68fa      	ldr	r2, [r7, #12]
 c001e8c:	4413      	add	r3, r2
 c001e8e:	681b      	ldr	r3, [r3, #0]
 c001e90:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 c001e94:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 c001e98:	009b      	lsls	r3, r3, #2
 c001e9a:	68fa      	ldr	r2, [r7, #12]
 c001e9c:	441a      	add	r2, r3
 c001e9e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001ea2:	009b      	lsls	r3, r3, #2
 c001ea4:	68f9      	ldr	r1, [r7, #12]
 c001ea6:	440b      	add	r3, r1
 c001ea8:	6812      	ldr	r2, [r2, #0]
 c001eaa:	601a      	str	r2, [r3, #0]
 c001eac:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 c001eb0:	009b      	lsls	r3, r3, #2
 c001eb2:	68fa      	ldr	r2, [r7, #12]
 c001eb4:	4413      	add	r3, r2
 c001eb6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 c001eba:	601a      	str	r2, [r3, #0]
    for (int i = n - 1; i > 0; i--) {
 c001ebc:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001ec0:	3b01      	subs	r3, #1
 c001ec2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 c001ec6:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001eca:	2b00      	cmp	r3, #0
 c001ecc:	dccf      	bgt.n	c001e6e <shuffle_secure_aes_ctr+0x26>
    }
}
 c001ece:	bf00      	nop
 c001ed0:	bf00      	nop
 c001ed2:	37f0      	adds	r7, #240	@ 0xf0
 c001ed4:	46bd      	mov	sp, r7
 c001ed6:	bd80      	pop	{r7, pc}

0c001ed8 <__acle_se_SECURE_ShuffledHMAC_secure>:

// ---- Non-secure callable: secure shuffle + HMAC over blocks
__attribute__((cmse_nonsecure_entry))
void SECURE_ShuffledHMAC_secure(uint8_t *out_digest, size_t out_len,
                                const uint8_t *challenge, size_t challenge_len)
{
 c001ed8:	b5b0      	push	{r4, r5, r7, lr}
 c001eda:	f5ad 5d82 	sub.w	sp, sp, #4160	@ 0x1040
 c001ede:	af00      	add	r7, sp, #0
 c001ee0:	f107 0440 	add.w	r4, r7, #64	@ 0x40
 c001ee4:	f844 0c34 	str.w	r0, [r4, #-52]
 c001ee8:	f107 0040 	add.w	r0, r7, #64	@ 0x40
 c001eec:	f840 1c38 	str.w	r1, [r0, #-56]
 c001ef0:	f107 0140 	add.w	r1, r7, #64	@ 0x40
 c001ef4:	f841 2c3c 	str.w	r2, [r1, #-60]
 c001ef8:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 c001efc:	f842 3c40 	str.w	r3, [r2, #-64]
    if (!out_digest || out_len < SHA256_DIGEST_SIZE) return;
 c001f00:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 c001f04:	f853 3c34 	ldr.w	r3, [r3, #-52]
 c001f08:	2b00      	cmp	r3, #0
 c001f0a:	f000 80ac 	beq.w	c002066 <__acle_se_SECURE_ShuffledHMAC_secure+0x18e>
 c001f0e:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 c001f12:	f853 3c38 	ldr.w	r3, [r3, #-56]
 c001f16:	2b1f      	cmp	r3, #31
 c001f18:	f240 80a5 	bls.w	c002066 <__acle_se_SECURE_ShuffledHMAC_secure+0x18e>

    // 1) indices = 0..BLOCKS-1
    static int indices[BLOCKS];
    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c001f1c:	2300      	movs	r3, #0
 c001f1e:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001f22:	f102 021c 	add.w	r2, r2, #28
 c001f26:	6013      	str	r3, [r2, #0]
 c001f28:	e017      	b.n	c001f5a <__acle_se_SECURE_ShuffledHMAC_secure+0x82>
 c001f2a:	496c      	ldr	r1, [pc, #432]	@ (c0020dc <__acle_se_SECURE_ShuffledHMAC_secure+0x204>)
 c001f2c:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c001f30:	f103 031c 	add.w	r3, r3, #28
 c001f34:	681b      	ldr	r3, [r3, #0]
 c001f36:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001f3a:	f102 021c 	add.w	r2, r2, #28
 c001f3e:	6812      	ldr	r2, [r2, #0]
 c001f40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 c001f44:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c001f48:	f103 031c 	add.w	r3, r3, #28
 c001f4c:	681b      	ldr	r3, [r3, #0]
 c001f4e:	3301      	adds	r3, #1
 c001f50:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001f54:	f102 021c 	add.w	r2, r2, #28
 c001f58:	6013      	str	r3, [r2, #0]
 c001f5a:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c001f5e:	f103 031c 	add.w	r3, r3, #28
 c001f62:	681b      	ldr	r3, [r3, #0]
 c001f64:	2b3f      	cmp	r3, #63	@ 0x3f
 c001f66:	dde0      	ble.n	c001f2a <__acle_se_SECURE_ShuffledHMAC_secure+0x52>

    // 2) derive AES key/IV from challenge
    uint8_t key16[16], iv16[16];
    derive_aes_key_iv_from_challenge(key16, iv16, challenge, challenge_len);
 c001f68:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 c001f6c:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 c001f70:	f507 5180 	add.w	r1, r7, #4096	@ 0x1000
 c001f74:	f101 0114 	add.w	r1, r1, #20
 c001f78:	f507 5081 	add.w	r0, r7, #4128	@ 0x1020
 c001f7c:	f100 0004 	add.w	r0, r0, #4
 c001f80:	f853 3c40 	ldr.w	r3, [r3, #-64]
 c001f84:	f852 2c3c 	ldr.w	r2, [r2, #-60]
 c001f88:	f7ff fe9c 	bl	c001cc4 <derive_aes_key_iv_from_challenge>

    // 3) secure shuffle
    shuffle_secure_aes_ctr(indices, BLOCKS, key16, iv16);
 c001f8c:	f507 5380 	add.w	r3, r7, #4096	@ 0x1000
 c001f90:	f103 0314 	add.w	r3, r3, #20
 c001f94:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001f98:	f102 0204 	add.w	r2, r2, #4
 c001f9c:	2140      	movs	r1, #64	@ 0x40
 c001f9e:	484f      	ldr	r0, [pc, #316]	@ (c0020dc <__acle_se_SECURE_ShuffledHMAC_secure+0x204>)
 c001fa0:	f7ff ff52 	bl	c001e48 <shuffle_secure_aes_ctr>

    // 4) HMAC over shuffled blocks
    hmac_sha256_initialize(&hmac, (const uint8_t*)key, strlen(key));
 c001fa4:	220e      	movs	r2, #14
 c001fa6:	494e      	ldr	r1, [pc, #312]	@ (c0020e0 <__acle_se_SECURE_ShuffledHMAC_secure+0x208>)
 c001fa8:	484e      	ldr	r0, [pc, #312]	@ (c0020e4 <__acle_se_SECURE_ShuffledHMAC_secure+0x20c>)
 c001faa:	f7ff f8af 	bl	c00110c <hmac_sha256_initialize>
    uint8_t copy[BLOCK_SIZE];
    for (int i = 0; i < BLOCKS; i++) {
 c001fae:	2300      	movs	r3, #0
 c001fb0:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001fb4:	f102 0218 	add.w	r2, r2, #24
 c001fb8:	6013      	str	r3, [r2, #0]
 c001fba:	e036      	b.n	c00202a <__acle_se_SECURE_ShuffledHMAC_secure+0x152>
        const uint8_t *blk = &real_memory[(size_t)indices[i] * BLOCK_SIZE];
 c001fbc:	4b4a      	ldr	r3, [pc, #296]	@ (c0020e8 <__acle_se_SECURE_ShuffledHMAC_secure+0x210>)
 c001fbe:	681a      	ldr	r2, [r3, #0]
 c001fc0:	4946      	ldr	r1, [pc, #280]	@ (c0020dc <__acle_se_SECURE_ShuffledHMAC_secure+0x204>)
 c001fc2:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c001fc6:	f103 0318 	add.w	r3, r3, #24
 c001fca:	681b      	ldr	r3, [r3, #0]
 c001fcc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c001fd0:	031b      	lsls	r3, r3, #12
 c001fd2:	4413      	add	r3, r2
 c001fd4:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001fd8:	f102 0214 	add.w	r2, r2, #20
 c001fdc:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 c001fde:	b672      	cpsid	i
}
 c001fe0:	bf00      	nop
        __disable_irq();
        memcpy(copy, blk, BLOCK_SIZE);
 c001fe2:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 c001fe6:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c001fea:	f102 0214 	add.w	r2, r2, #20
 c001fee:	6812      	ldr	r2, [r2, #0]
 c001ff0:	3b2c      	subs	r3, #44	@ 0x2c
 c001ff2:	4611      	mov	r1, r2
 c001ff4:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 c001ff8:	4618      	mov	r0, r3
 c001ffa:	f003 fdfc 	bl	c005bf6 <memcpy>
  __ASM volatile ("cpsie i" : : : "memory");
 c001ffe:	b662      	cpsie	i
}
 c002000:	bf00      	nop
//        hmac_sha256_update(&hmac, blk, BLOCK_SIZE);
        __enable_irq();
        hmac_sha256_update(&hmac, copy, BLOCK_SIZE);
 c002002:	f107 0320 	add.w	r3, r7, #32
 c002006:	3b0c      	subs	r3, #12
 c002008:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 c00200c:	4619      	mov	r1, r3
 c00200e:	4835      	ldr	r0, [pc, #212]	@ (c0020e4 <__acle_se_SECURE_ShuffledHMAC_secure+0x20c>)
 c002010:	f7ff f8ec 	bl	c0011ec <hmac_sha256_update>
    for (int i = 0; i < BLOCKS; i++) {
 c002014:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c002018:	f103 0318 	add.w	r3, r3, #24
 c00201c:	681b      	ldr	r3, [r3, #0]
 c00201e:	3301      	adds	r3, #1
 c002020:	f507 5281 	add.w	r2, r7, #4128	@ 0x1020
 c002024:	f102 0218 	add.w	r2, r2, #24
 c002028:	6013      	str	r3, [r2, #0]
 c00202a:	f507 5381 	add.w	r3, r7, #4128	@ 0x1020
 c00202e:	f103 0318 	add.w	r3, r3, #24
 c002032:	681b      	ldr	r3, [r3, #0]
 c002034:	2b3f      	cmp	r3, #63	@ 0x3f
 c002036:	ddc1      	ble.n	c001fbc <__acle_se_SECURE_ShuffledHMAC_secure+0xe4>
    }
    hmac_sha256_finalize(&hmac, NULL, 0);
 c002038:	2200      	movs	r2, #0
 c00203a:	2100      	movs	r1, #0
 c00203c:	4829      	ldr	r0, [pc, #164]	@ (c0020e4 <__acle_se_SECURE_ShuffledHMAC_secure+0x20c>)
 c00203e:	f7ff f8e6 	bl	c00120e <hmac_sha256_finalize>
    memcpy(out_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c002042:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 c002046:	f853 3c34 	ldr.w	r3, [r3, #-52]
 c00204a:	4a26      	ldr	r2, [pc, #152]	@ (c0020e4 <__acle_se_SECURE_ShuffledHMAC_secure+0x20c>)
 c00204c:	461c      	mov	r4, r3
 c00204e:	4615      	mov	r5, r2
 c002050:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002052:	6020      	str	r0, [r4, #0]
 c002054:	6061      	str	r1, [r4, #4]
 c002056:	60a2      	str	r2, [r4, #8]
 c002058:	60e3      	str	r3, [r4, #12]
 c00205a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c00205c:	6120      	str	r0, [r4, #16]
 c00205e:	6161      	str	r1, [r4, #20]
 c002060:	61a2      	str	r2, [r4, #24]
 c002062:	61e3      	str	r3, [r4, #28]
 c002064:	e000      	b.n	c002068 <__acle_se_SECURE_ShuffledHMAC_secure+0x190>
    if (!out_digest || out_len < SHA256_DIGEST_SIZE) return;
 c002066:	bf00      	nop
}
 c002068:	f507 5782 	add.w	r7, r7, #4160	@ 0x1040
 c00206c:	46bd      	mov	sp, r7
 c00206e:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c002072:	4670      	mov	r0, lr
 c002074:	4671      	mov	r1, lr
 c002076:	4672      	mov	r2, lr
 c002078:	4673      	mov	r3, lr
 c00207a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c00207e:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002082:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002086:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00208a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00208e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002092:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002096:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00209a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00209e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0020a2:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0020a6:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0020aa:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0020ae:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0020b2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0020b6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0020ba:	f38e 8c00 	msr	CPSR_fs, lr
 c0020be:	b410      	push	{r4}
 c0020c0:	eef1 ca10 	vmrs	ip, fpscr
 c0020c4:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0020c8:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0020cc:	ea0c 0c04 	and.w	ip, ip, r4
 c0020d0:	eee1 ca10 	vmsr	fpscr, ip
 c0020d4:	bc10      	pop	{r4}
 c0020d6:	46f4      	mov	ip, lr
 c0020d8:	4774      	bxns	lr
 c0020da:	bf00      	nop
 c0020dc:	300003b8 	.word	0x300003b8
 c0020e0:	0c006c7c 	.word	0x0c006c7c
 c0020e4:	300001d0 	.word	0x300001d0
 c0020e8:	30000000 	.word	0x30000000

0c0020ec <__acle_se_SECURE_SMARM>:


__attribute__((cmse_nonsecure_entry))
void SECURE_SMARM(uint8_t *output_digest, size_t maxlen)
{
 c0020ec:	b5b0      	push	{r4, r5, r7, lr}
 c0020ee:	f5ad 1d80 	sub.w	sp, sp, #1048576	@ 0x100000
 c0020f2:	b088      	sub	sp, #32
 c0020f4:	af00      	add	r7, sp, #0
 c0020f6:	f107 0320 	add.w	r3, r7, #32
 c0020fa:	f843 0c1c 	str.w	r0, [r3, #-28]
 c0020fe:	f107 0320 	add.w	r3, r7, #32
 c002102:	f843 1c20 	str.w	r1, [r3, #-32]
	if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c002106:	f107 0320 	add.w	r3, r7, #32
 c00210a:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 c00210e:	2b00      	cmp	r3, #0
 c002110:	f000 80c8 	beq.w	c0022a4 <__acle_se_SECURE_SMARM+0x1b8>
 c002114:	f107 0320 	add.w	r3, r7, #32
 c002118:	f853 3c20 	ldr.w	r3, [r3, #-32]
 c00211c:	2b1f      	cmp	r3, #31
 c00211e:	f240 80c1 	bls.w	c0022a4 <__acle_se_SECURE_SMARM+0x1b8>

    srand(42);  // Use fixed seed or hardware-derived one like SysTick->VAL
 c002122:	202a      	movs	r0, #42	@ 0x2a
 c002124:	f003 fa52 	bl	c0055cc <srand>

	// note #include <aes/aes_cbc.h>  lib

	// ben shuffle_aes_ctr  main.c -> shuffle.c

	for (int i = TOTAL_SIZE - 1; i > 0; i--) {
 c002128:	4b7c      	ldr	r3, [pc, #496]	@ (c00231c <__acle_se_SECURE_SMARM+0x230>)
 c00212a:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c00212e:	f102 021c 	add.w	r2, r2, #28
 c002132:	6013      	str	r3, [r2, #0]
 c002134:	e051      	b.n	c0021da <__acle_se_SECURE_SMARM+0xee>

	int j = rand() % (i + 1);
 c002136:	f003 fa77 	bl	c005628 <rand>
 c00213a:	4602      	mov	r2, r0
 c00213c:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002140:	f103 031c 	add.w	r3, r3, #28
 c002144:	681b      	ldr	r3, [r3, #0]
 c002146:	3301      	adds	r3, #1
 c002148:	fb92 f1f3 	sdiv	r1, r2, r3
 c00214c:	fb01 f303 	mul.w	r3, r1, r3
 c002150:	1ad3      	subs	r3, r2, r3
 c002152:	f107 1210 	add.w	r2, r7, #1048592	@ 0x100010
 c002156:	6013      	str	r3, [r2, #0]

	int tmp = indices[i];
 c002158:	f107 0320 	add.w	r3, r7, #32
 c00215c:	461a      	mov	r2, r3
 c00215e:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002162:	f103 031c 	add.w	r3, r3, #28
 c002166:	681b      	ldr	r3, [r3, #0]
 c002168:	009b      	lsls	r3, r3, #2
 c00216a:	4413      	add	r3, r2
 c00216c:	f853 3c14 	ldr.w	r3, [r3, #-20]
 c002170:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002174:	f102 020c 	add.w	r2, r2, #12
 c002178:	6013      	str	r3, [r2, #0]

	indices[i] = indices[j];
 c00217a:	f107 0320 	add.w	r3, r7, #32
 c00217e:	461a      	mov	r2, r3
 c002180:	f107 1310 	add.w	r3, r7, #1048592	@ 0x100010
 c002184:	681b      	ldr	r3, [r3, #0]
 c002186:	009b      	lsls	r3, r3, #2
 c002188:	4413      	add	r3, r2
 c00218a:	f853 2c14 	ldr.w	r2, [r3, #-20]
 c00218e:	f107 0320 	add.w	r3, r7, #32
 c002192:	4619      	mov	r1, r3
 c002194:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002198:	f103 031c 	add.w	r3, r3, #28
 c00219c:	681b      	ldr	r3, [r3, #0]
 c00219e:	009b      	lsls	r3, r3, #2
 c0021a0:	440b      	add	r3, r1
 c0021a2:	f843 2c14 	str.w	r2, [r3, #-20]

	indices[j] = tmp;
 c0021a6:	f107 0320 	add.w	r3, r7, #32
 c0021aa:	461a      	mov	r2, r3
 c0021ac:	f107 1310 	add.w	r3, r7, #1048592	@ 0x100010
 c0021b0:	681b      	ldr	r3, [r3, #0]
 c0021b2:	009b      	lsls	r3, r3, #2
 c0021b4:	4413      	add	r3, r2
 c0021b6:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c0021ba:	f102 020c 	add.w	r2, r2, #12
 c0021be:	6812      	ldr	r2, [r2, #0]
 c0021c0:	f843 2c14 	str.w	r2, [r3, #-20]
	for (int i = TOTAL_SIZE - 1; i > 0; i--) {
 c0021c4:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c0021c8:	f103 031c 	add.w	r3, r3, #28
 c0021cc:	681b      	ldr	r3, [r3, #0]
 c0021ce:	3b01      	subs	r3, #1
 c0021d0:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c0021d4:	f102 021c 	add.w	r2, r2, #28
 c0021d8:	6013      	str	r3, [r2, #0]
 c0021da:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c0021de:	f103 031c 	add.w	r3, r3, #28
 c0021e2:	681b      	ldr	r3, [r3, #0]
 c0021e4:	2b00      	cmp	r3, #0
 c0021e6:	dca6      	bgt.n	c002136 <__acle_se_SECURE_SMARM+0x4a>

	}

	hmac_sha256_initialize(&hmac, key, strlen((const char )key));
 c0021e8:	4b4d      	ldr	r3, [pc, #308]	@ (c002320 <__acle_se_SECURE_SMARM+0x234>)
 c0021ea:	b2db      	uxtb	r3, r3
 c0021ec:	4618      	mov	r0, r3
 c0021ee:	f7fe f823 	bl	c000238 <strlen>
 c0021f2:	4603      	mov	r3, r0
 c0021f4:	461a      	mov	r2, r3
 c0021f6:	494a      	ldr	r1, [pc, #296]	@ (c002320 <__acle_se_SECURE_SMARM+0x234>)
 c0021f8:	484a      	ldr	r0, [pc, #296]	@ (c002324 <__acle_se_SECURE_SMARM+0x238>)
 c0021fa:	f7fe ff87 	bl	c00110c <hmac_sha256_initialize>

	for (int i = 0; i < BLOCKS; i++) {
 c0021fe:	2300      	movs	r3, #0
 c002200:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002204:	f102 0218 	add.w	r2, r2, #24
 c002208:	6013      	str	r3, [r2, #0]
 c00220a:	e02d      	b.n	c002268 <__acle_se_SECURE_SMARM+0x17c>

	const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c00220c:	4b46      	ldr	r3, [pc, #280]	@ (c002328 <__acle_se_SECURE_SMARM+0x23c>)
 c00220e:	681a      	ldr	r2, [r3, #0]
 c002210:	f107 0320 	add.w	r3, r7, #32
 c002214:	4619      	mov	r1, r3
 c002216:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c00221a:	f103 0318 	add.w	r3, r3, #24
 c00221e:	681b      	ldr	r3, [r3, #0]
 c002220:	009b      	lsls	r3, r3, #2
 c002222:	440b      	add	r3, r1
 c002224:	f853 3c14 	ldr.w	r3, [r3, #-20]
 c002228:	031b      	lsls	r3, r3, #12
 c00222a:	4413      	add	r3, r2
 c00222c:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002230:	f102 0214 	add.w	r2, r2, #20
 c002234:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 c002236:	b672      	cpsid	i
}
 c002238:	bf00      	nop

		__disable_irq();
		hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c00223a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 c00223e:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002242:	f103 0314 	add.w	r3, r3, #20
 c002246:	6819      	ldr	r1, [r3, #0]
 c002248:	4836      	ldr	r0, [pc, #216]	@ (c002324 <__acle_se_SECURE_SMARM+0x238>)
 c00224a:	f7fe ffcf 	bl	c0011ec <hmac_sha256_update>
  __ASM volatile ("cpsie i" : : : "memory");
 c00224e:	b662      	cpsie	i
}
 c002250:	bf00      	nop
	for (int i = 0; i < BLOCKS; i++) {
 c002252:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002256:	f103 0318 	add.w	r3, r3, #24
 c00225a:	681b      	ldr	r3, [r3, #0]
 c00225c:	3301      	adds	r3, #1
 c00225e:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002262:	f102 0218 	add.w	r2, r2, #24
 c002266:	6013      	str	r3, [r2, #0]
 c002268:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c00226c:	f103 0318 	add.w	r3, r3, #24
 c002270:	681b      	ldr	r3, [r3, #0]
 c002272:	2b3f      	cmp	r3, #63	@ 0x3f
 c002274:	ddca      	ble.n	c00220c <__acle_se_SECURE_SMARM+0x120>
		__enable_irq();

	}

	hmac_sha256_finalize(&hmac, NULL, 0);
 c002276:	2200      	movs	r2, #0
 c002278:	2100      	movs	r1, #0
 c00227a:	482a      	ldr	r0, [pc, #168]	@ (c002324 <__acle_se_SECURE_SMARM+0x238>)
 c00227c:	f7fe ffc7 	bl	c00120e <hmac_sha256_finalize>

	memcpy(output_digest,hmac.digest, SHA256_DIGEST_SIZE);
 c002280:	f107 0320 	add.w	r3, r7, #32
 c002284:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 c002288:	4a26      	ldr	r2, [pc, #152]	@ (c002324 <__acle_se_SECURE_SMARM+0x238>)
 c00228a:	461c      	mov	r4, r3
 c00228c:	4615      	mov	r5, r2
 c00228e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002290:	6020      	str	r0, [r4, #0]
 c002292:	6061      	str	r1, [r4, #4]
 c002294:	60a2      	str	r2, [r4, #8]
 c002296:	60e3      	str	r3, [r4, #12]
 c002298:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c00229a:	6120      	str	r0, [r4, #16]
 c00229c:	6161      	str	r1, [r4, #20]
 c00229e:	61a2      	str	r2, [r4, #24]
 c0022a0:	61e3      	str	r3, [r4, #28]
 c0022a2:	e000      	b.n	c0022a6 <__acle_se_SECURE_SMARM+0x1ba>
	if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c0022a4:	bf00      	nop
}
 c0022a6:	f507 1780 	add.w	r7, r7, #1048576	@ 0x100000
 c0022aa:	3720      	adds	r7, #32
 c0022ac:	46bd      	mov	sp, r7
 c0022ae:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c0022b2:	4670      	mov	r0, lr
 c0022b4:	4671      	mov	r1, lr
 c0022b6:	4672      	mov	r2, lr
 c0022b8:	4673      	mov	r3, lr
 c0022ba:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0022be:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0022c2:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0022c6:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0022ca:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0022ce:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0022d2:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0022d6:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0022da:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0022de:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0022e2:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0022e6:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0022ea:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0022ee:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0022f2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0022f6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0022fa:	f38e 8c00 	msr	CPSR_fs, lr
 c0022fe:	b410      	push	{r4}
 c002300:	eef1 ca10 	vmrs	ip, fpscr
 c002304:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002308:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00230c:	ea0c 0c04 	and.w	ip, ip, r4
 c002310:	eee1 ca10 	vmsr	fpscr, ip
 c002314:	bc10      	pop	{r4}
 c002316:	46f4      	mov	ip, lr
 c002318:	4774      	bxns	lr
 c00231a:	bf00      	nop
 c00231c:	0003ffff 	.word	0x0003ffff
 c002320:	0c006c7c 	.word	0x0c006c7c
 c002324:	300001d0 	.word	0x300001d0
 c002328:	30000000 	.word	0x30000000

0c00232c <__acle_se_SECURE_TEST>:



__attribute__((cmse_nonsecure_entry))
void SECURE_TEST(uint8_t *output_digest, size_t maxlen)
{
 c00232c:	b5b0      	push	{r4, r5, r7, lr}
 c00232e:	b0ca      	sub	sp, #296	@ 0x128
 c002330:	af00      	add	r7, sp, #0
 c002332:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c002336:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 c00233a:	6018      	str	r0, [r3, #0]
 c00233c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c002340:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 c002344:	6019      	str	r1, [r3, #0]
	 if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c002346:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c00234a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 c00234e:	681b      	ldr	r3, [r3, #0]
 c002350:	2b00      	cmp	r3, #0
 c002352:	f000 80b6 	beq.w	c0024c2 <__acle_se_SECURE_TEST+0x196>
 c002356:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c00235a:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 c00235e:	681b      	ldr	r3, [r3, #0]
 c002360:	2b1f      	cmp	r3, #31
 c002362:	f240 80ae 	bls.w	c0024c2 <__acle_se_SECURE_TEST+0x196>

	    // Fill real_memory if ( linear)
	    for (int i = 0; i < TOTAL_SIZE * BLOCK_SIZE; i++) {
 c002366:	2300      	movs	r3, #0
 c002368:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 c00236c:	e00d      	b.n	c00238a <__acle_se_SECURE_TEST+0x5e>
	        real_memory[i] = i & 0xFF;
 c00236e:	4b72      	ldr	r3, [pc, #456]	@ (c002538 <__acle_se_SECURE_TEST+0x20c>)
 c002370:	681a      	ldr	r2, [r3, #0]
 c002372:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 c002376:	4413      	add	r3, r2
 c002378:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 c00237c:	b2d2      	uxtb	r2, r2
 c00237e:	701a      	strb	r2, [r3, #0]
	    for (int i = 0; i < TOTAL_SIZE * BLOCK_SIZE; i++) {
 c002380:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 c002384:	3301      	adds	r3, #1
 c002386:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 c00238a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 c00238e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 c002392:	dbec      	blt.n	c00236e <__acle_se_SECURE_TEST+0x42>
	    }

	    // 1. Initialize indices
	    int indices[BLOCKS];
	    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c002394:	2300      	movs	r3, #0
 c002396:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 c00239a:	e00e      	b.n	c0023ba <__acle_se_SECURE_TEST+0x8e>
 c00239c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c0023a0:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 c0023a4:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 c0023a8:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 c0023ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 c0023b0:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 c0023b4:	3301      	adds	r3, #1
 c0023b6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
 c0023ba:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 c0023be:	2b3f      	cmp	r3, #63	@ 0x3f
 c0023c0:	ddec      	ble.n	c00239c <__acle_se_SECURE_TEST+0x70>

	    srand(42);
 c0023c2:	202a      	movs	r0, #42	@ 0x2a
 c0023c4:	f003 f902 	bl	c0055cc <srand>

	    // 2. Shuffle indices
	    for (int i = BLOCKS - 1; i > 0; i--) {
 c0023c8:	233f      	movs	r3, #63	@ 0x3f
 c0023ca:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 c0023ce:	e035      	b.n	c00243c <__acle_se_SECURE_TEST+0x110>
	        int j = rand() % (i + 1);
 c0023d0:	f003 f92a 	bl	c005628 <rand>
 c0023d4:	4602      	mov	r2, r0
 c0023d6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 c0023da:	3301      	adds	r3, #1
 c0023dc:	fb92 f1f3 	sdiv	r1, r2, r3
 c0023e0:	fb01 f303 	mul.w	r3, r1, r3
 c0023e4:	1ad3      	subs	r3, r2, r3
 c0023e6:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
	        int tmp = indices[i];
 c0023ea:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c0023ee:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 c0023f2:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 c0023f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0023fa:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
	        indices[i] = indices[j];
 c0023fe:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c002402:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 c002406:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 c00240a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c00240e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c002412:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 c002416:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 c00241a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	        indices[j] = tmp;
 c00241e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c002422:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 c002426:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 c00242a:	f8d7 110c 	ldr.w	r1, [r7, #268]	@ 0x10c
 c00242e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	    for (int i = BLOCKS - 1; i > 0; i--) {
 c002432:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 c002436:	3b01      	subs	r3, #1
 c002438:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 c00243c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 c002440:	2b00      	cmp	r3, #0
 c002442:	dcc5      	bgt.n	c0023d0 <__acle_se_SECURE_TEST+0xa4>
	    }

	    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
 c002444:	220e      	movs	r2, #14
 c002446:	493d      	ldr	r1, [pc, #244]	@ (c00253c <__acle_se_SECURE_TEST+0x210>)
 c002448:	483d      	ldr	r0, [pc, #244]	@ (c002540 <__acle_se_SECURE_TEST+0x214>)
 c00244a:	f7fe fe5f 	bl	c00110c <hmac_sha256_initialize>

	    for (int i = 0; i < BLOCKS; i++) {
 c00244e:	2300      	movs	r3, #0
 c002450:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 c002454:	e019      	b.n	c00248a <__acle_se_SECURE_TEST+0x15e>
	        const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c002456:	4b38      	ldr	r3, [pc, #224]	@ (c002538 <__acle_se_SECURE_TEST+0x20c>)
 c002458:	681b      	ldr	r3, [r3, #0]
 c00245a:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 c00245e:	f5a2 728e 	sub.w	r2, r2, #284	@ 0x11c
 c002462:	f8d7 1118 	ldr.w	r1, [r7, #280]	@ 0x118
 c002466:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 c00246a:	0312      	lsls	r2, r2, #12
 c00246c:	4413      	add	r3, r2
 c00246e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
	        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c002472:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 c002476:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 c00247a:	4831      	ldr	r0, [pc, #196]	@ (c002540 <__acle_se_SECURE_TEST+0x214>)
 c00247c:	f7fe feb6 	bl	c0011ec <hmac_sha256_update>
	    for (int i = 0; i < BLOCKS; i++) {
 c002480:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 c002484:	3301      	adds	r3, #1
 c002486:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
 c00248a:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 c00248e:	2b3f      	cmp	r3, #63	@ 0x3f
 c002490:	dde1      	ble.n	c002456 <__acle_se_SECURE_TEST+0x12a>
	    }

	    hmac_sha256_finalize(&hmac, NULL, 0);
 c002492:	2200      	movs	r2, #0
 c002494:	2100      	movs	r1, #0
 c002496:	482a      	ldr	r0, [pc, #168]	@ (c002540 <__acle_se_SECURE_TEST+0x214>)
 c002498:	f7fe feb9 	bl	c00120e <hmac_sha256_finalize>
	    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c00249c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 c0024a0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 c0024a4:	681b      	ldr	r3, [r3, #0]
 c0024a6:	4a26      	ldr	r2, [pc, #152]	@ (c002540 <__acle_se_SECURE_TEST+0x214>)
 c0024a8:	461c      	mov	r4, r3
 c0024aa:	4615      	mov	r5, r2
 c0024ac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0024ae:	6020      	str	r0, [r4, #0]
 c0024b0:	6061      	str	r1, [r4, #4]
 c0024b2:	60a2      	str	r2, [r4, #8]
 c0024b4:	60e3      	str	r3, [r4, #12]
 c0024b6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0024b8:	6120      	str	r0, [r4, #16]
 c0024ba:	6161      	str	r1, [r4, #20]
 c0024bc:	61a2      	str	r2, [r4, #24]
 c0024be:	61e3      	str	r3, [r4, #28]
 c0024c0:	e000      	b.n	c0024c4 <__acle_se_SECURE_TEST+0x198>
	 if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c0024c2:	bf00      	nop
}
 c0024c4:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 c0024c8:	46bd      	mov	sp, r7
 c0024ca:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c0024ce:	4670      	mov	r0, lr
 c0024d0:	4671      	mov	r1, lr
 c0024d2:	4672      	mov	r2, lr
 c0024d4:	4673      	mov	r3, lr
 c0024d6:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0024da:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0024de:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0024e2:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0024e6:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0024ea:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0024ee:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0024f2:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0024f6:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0024fa:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0024fe:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002502:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002506:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00250a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00250e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002512:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002516:	f38e 8c00 	msr	CPSR_fs, lr
 c00251a:	b410      	push	{r4}
 c00251c:	eef1 ca10 	vmrs	ip, fpscr
 c002520:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002524:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002528:	ea0c 0c04 	and.w	ip, ip, r4
 c00252c:	eee1 ca10 	vmsr	fpscr, ip
 c002530:	bc10      	pop	{r4}
 c002532:	46f4      	mov	ip, lr
 c002534:	4774      	bxns	lr
 c002536:	bf00      	nop
 c002538:	30000000 	.word	0x30000000
 c00253c:	0c006c7c 	.word	0x0c006c7c
 c002540:	300001d0 	.word	0x300001d0
 c002544:	00000000 	.word	0x00000000

0c002548 <__acle_se_Secure_FlashTest>:
//
//}

__attribute__((cmse_nonsecure_entry))
void Secure_FlashTest(void)
{
 c002548:	b580      	push	{r7, lr}
 c00254a:	b098      	sub	sp, #96	@ 0x60
 c00254c:	af00      	add	r7, sp, #0
	 	HAL_StatusTypeDef status;
	    FLASH_EraseInitTypeDef EraseInitStruct = {0};
 c00254e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 c002552:	2200      	movs	r2, #0
 c002554:	601a      	str	r2, [r3, #0]
 c002556:	605a      	str	r2, [r3, #4]
 c002558:	609a      	str	r2, [r3, #8]
 c00255a:	60da      	str	r2, [r3, #12]
	    FLASH_BBAttributesTypeDef flash_bb_attr = {0};
 c00255c:	f107 0314 	add.w	r3, r7, #20
 c002560:	2200      	movs	r2, #0
 c002562:	601a      	str	r2, [r3, #0]
 c002564:	605a      	str	r2, [r3, #4]
 c002566:	609a      	str	r2, [r3, #8]
 c002568:	60da      	str	r2, [r3, #12]
 c00256a:	611a      	str	r2, [r3, #16]
 c00256c:	615a      	str	r2, [r3, #20]
	    uint32_t PageError = 0;
 c00256e:	2300      	movs	r3, #0
 c002570:	613b      	str	r3, [r7, #16]
	    uint64_t test_data = FLASH_TEST_DATA;
 c002572:	a3d4      	add	r3, pc, #848	@ (adr r3, c0028c4 <__acle_se_Secure_FlashTest+0x37c>)
 c002574:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002578:	e9c7 2302 	strd	r2, r3, [r7, #8]
	    uint32_t saved_attr = 0;
 c00257c:	2300      	movs	r3, #0
 c00257e:	65fb      	str	r3, [r7, #92]	@ 0x5c

	    printf("[Secure] === Flash Test (with BB Attributes) ===\r\n");
 c002580:	48b1      	ldr	r0, [pc, #708]	@ (c002848 <__acle_se_Secure_FlashTest+0x300>)
 c002582:	f003 f9b9 	bl	c0058f8 <puts>

	    // ========== Step 1: Get Current BB Attributes ==========
	    flash_bb_attr.Bank = FLASH_TEST_BANK;
 c002586:	2302      	movs	r3, #2
 c002588:	617b      	str	r3, [r7, #20]
	    flash_bb_attr.BBAttributesType = FLASH_BB_SEC;
 c00258a:	2301      	movs	r3, #1
 c00258c:	61bb      	str	r3, [r7, #24]

	    HAL_FLASHEx_GetConfigBBAttributes(&flash_bb_attr);
 c00258e:	f107 0314 	add.w	r3, r7, #20
 c002592:	4618      	mov	r0, r3
 c002594:	f001 fed4 	bl	c004340 <HAL_FLASHEx_GetConfigBBAttributes>

	    uint32_t attr_index = FLASH_TEST_PAGE / 32;  // 120/32 = 3
 c002598:	2303      	movs	r3, #3
 c00259a:	65bb      	str	r3, [r7, #88]	@ 0x58
	    uint32_t attr_bit = FLASH_TEST_PAGE % 32;    // 120%32 = 24
 c00259c:	2318      	movs	r3, #24
 c00259e:	657b      	str	r3, [r7, #84]	@ 0x54

	    saved_attr = flash_bb_attr.BBAttributes_array[attr_index];
 c0025a0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c0025a2:	3302      	adds	r3, #2
 c0025a4:	009b      	lsls	r3, r3, #2
 c0025a6:	3360      	adds	r3, #96	@ 0x60
 c0025a8:	443b      	add	r3, r7
 c0025aa:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 c0025ae:	65fb      	str	r3, [r7, #92]	@ 0x5c
	    uint32_t page_is_secure = (saved_attr >> attr_bit) & 0x1;
 c0025b0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c0025b2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c0025b4:	fa22 f303 	lsr.w	r3, r2, r3
 c0025b8:	f003 0301 	and.w	r3, r3, #1
 c0025bc:	653b      	str	r3, [r7, #80]	@ 0x50

	    printf("[Secure] Page %d current: %s\r\n",
 c0025be:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c0025c0:	2b00      	cmp	r3, #0
 c0025c2:	d001      	beq.n	c0025c8 <__acle_se_Secure_FlashTest+0x80>
 c0025c4:	4ba1      	ldr	r3, [pc, #644]	@ (c00284c <__acle_se_Secure_FlashTest+0x304>)
 c0025c6:	e000      	b.n	c0025ca <__acle_se_Secure_FlashTest+0x82>
 c0025c8:	4ba1      	ldr	r3, [pc, #644]	@ (c002850 <__acle_se_Secure_FlashTest+0x308>)
 c0025ca:	461a      	mov	r2, r3
 c0025cc:	2178      	movs	r1, #120	@ 0x78
 c0025ce:	48a1      	ldr	r0, [pc, #644]	@ (c002854 <__acle_se_Secure_FlashTest+0x30c>)
 c0025d0:	f003 f92a 	bl	c005828 <iprintf>
	           FLASH_TEST_PAGE,
	           page_is_secure ? "SECURE" : "NON-SECURE");

	    // ========== Step 2: Promote Page to SECURE ==========
	    printf("[Secure] Promoting to SECURE...\r\n");
 c0025d4:	48a0      	ldr	r0, [pc, #640]	@ (c002858 <__acle_se_Secure_FlashTest+0x310>)
 c0025d6:	f003 f98f 	bl	c0058f8 <puts>

	    // Set bit to make page Secure
	    flash_bb_attr.BBAttributes_array[attr_index] |= (1U << attr_bit);
 c0025da:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c0025dc:	3302      	adds	r3, #2
 c0025de:	009b      	lsls	r3, r3, #2
 c0025e0:	3360      	adds	r3, #96	@ 0x60
 c0025e2:	443b      	add	r3, r7
 c0025e4:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 c0025e8:	2101      	movs	r1, #1
 c0025ea:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c0025ec:	fa01 f303 	lsl.w	r3, r1, r3
 c0025f0:	431a      	orrs	r2, r3
 c0025f2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c0025f4:	3302      	adds	r3, #2
 c0025f6:	009b      	lsls	r3, r3, #2
 c0025f8:	3360      	adds	r3, #96	@ 0x60
 c0025fa:	443b      	add	r3, r7
 c0025fc:	f843 2c4c 	str.w	r2, [r3, #-76]

	    status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c002600:	f107 0314 	add.w	r3, r7, #20
 c002604:	4618      	mov	r0, r3
 c002606:	f001 fe51 	bl	c0042ac <HAL_FLASHEx_ConfigBBAttributes>
 c00260a:	4603      	mov	r3, r0
 c00260c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c002610:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c002614:	2b00      	cmp	r3, #0
 c002616:	d006      	beq.n	c002626 <__acle_se_Secure_FlashTest+0xde>
	    {
	        printf("[Secure]  Promote FAILED: %d\r\n", status);
 c002618:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00261c:	4619      	mov	r1, r3
 c00261e:	488f      	ldr	r0, [pc, #572]	@ (c00285c <__acle_se_Secure_FlashTest+0x314>)
 c002620:	f003 f902 	bl	c005828 <iprintf>
 c002624:	e0d6      	b.n	c0027d4 <__acle_se_Secure_FlashTest+0x28c>
	        return;
	    }

	    printf("[Secure]  Promoted to SECURE\r\n");
 c002626:	488e      	ldr	r0, [pc, #568]	@ (c002860 <__acle_se_Secure_FlashTest+0x318>)
 c002628:	f003 f966 	bl	c0058f8 <puts>

	    // Small delay for attribute change to take effect
//	    for (volatile int i = 0; i < 1000; i++);

	    // ========== Step 3: Unlock Flash ==========
	    status = HAL_FLASH_Unlock();
 c00262c:	f001 fcbc 	bl	c003fa8 <HAL_FLASH_Unlock>
 c002630:	4603      	mov	r3, r0
 c002632:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c002636:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00263a:	2b00      	cmp	r3, #0
 c00263c:	d006      	beq.n	c00264c <__acle_se_Secure_FlashTest+0x104>
	    {
	        printf("[Secure]  Unlock FAILED: %d\r\n", status);
 c00263e:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c002642:	4619      	mov	r1, r3
 c002644:	4887      	ldr	r0, [pc, #540]	@ (c002864 <__acle_se_Secure_FlashTest+0x31c>)
 c002646:	f003 f8ef 	bl	c005828 <iprintf>
	        goto restore_attributes;
 c00264a:	e096      	b.n	c00277a <__acle_se_Secure_FlashTest+0x232>
	    }
	    printf("[Secure]  Unlocked\r\n");
 c00264c:	4886      	ldr	r0, [pc, #536]	@ (c002868 <__acle_se_Secure_FlashTest+0x320>)
 c00264e:	f003 f953 	bl	c0058f8 <puts>

	    // ========== Step 4: Erase Page ==========
	    EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;
 c002652:	2302      	movs	r3, #2
 c002654:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    EraseInitStruct.Page = FLASH_TEST_PAGE;
 c002656:	2378      	movs	r3, #120	@ 0x78
 c002658:	637b      	str	r3, [r7, #52]	@ 0x34
	    EraseInitStruct.NbPages = 1;
 c00265a:	2301      	movs	r3, #1
 c00265c:	63bb      	str	r3, [r7, #56]	@ 0x38
	    EraseInitStruct.Banks = FLASH_TEST_BANK;
 c00265e:	2302      	movs	r3, #2
 c002660:	633b      	str	r3, [r7, #48]	@ 0x30

	    status = HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);
 c002662:	f107 0210 	add.w	r2, r7, #16
 c002666:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 c00266a:	4611      	mov	r1, r2
 c00266c:	4618      	mov	r0, r3
 c00266e:	f001 fda5 	bl	c0041bc <HAL_FLASHEx_Erase>
 c002672:	4603      	mov	r3, r0
 c002674:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

	    if (status != HAL_OK || PageError != 0xFFFFFFFF)
 c002678:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00267c:	2b00      	cmp	r3, #0
 c00267e:	d103      	bne.n	c002688 <__acle_se_Secure_FlashTest+0x140>
 c002680:	693b      	ldr	r3, [r7, #16]
 c002682:	f1b3 3fff 	cmp.w	r3, #4294967295
 c002686:	d009      	beq.n	c00269c <__acle_se_Secure_FlashTest+0x154>
	    {
	        printf("[Secure]  Erase FAILED: status=%d, PageError=0x%08lX\r\n",
 c002688:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00268c:	693a      	ldr	r2, [r7, #16]
 c00268e:	4619      	mov	r1, r3
 c002690:	4876      	ldr	r0, [pc, #472]	@ (c00286c <__acle_se_Secure_FlashTest+0x324>)
 c002692:	f003 f8c9 	bl	c005828 <iprintf>
	               status, PageError);
	        HAL_FLASH_Lock();
 c002696:	f001 fcbd 	bl	c004014 <HAL_FLASH_Lock>
	        goto restore_attributes;
 c00269a:	e06e      	b.n	c00277a <__acle_se_Secure_FlashTest+0x232>
	    }
	    printf("[Secure]  Erase OK\r\n");
 c00269c:	4874      	ldr	r0, [pc, #464]	@ (c002870 <__acle_se_Secure_FlashTest+0x328>)
 c00269e:	f003 f92b 	bl	c0058f8 <puts>

	    // ========== Step 5: Prepare Data in Work Buffer ==========
	    // Copy data to NS work buffer (required by some HAL implementations)
	    memcpy(ns_work_buffer, &test_data, sizeof(test_data));
 c0026a2:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c0026a6:	4973      	ldr	r1, [pc, #460]	@ (c002874 <__acle_se_Secure_FlashTest+0x32c>)
 c0026a8:	e9c1 2300 	strd	r2, r3, [r1]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 c0026ac:	f3bf 8f4f 	dsb	sy
}
 c0026b0:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0026b2:	f3bf 8f6f 	isb	sy
}
 c0026b6:	bf00      	nop
	    // Memory barrier
	    __DSB();
	    __ISB();

	    // ========== Step 6: Program via Secure Address ==========
	    printf("[Secure] Programming...\r\n");
 c0026b8:	486f      	ldr	r0, [pc, #444]	@ (c002878 <__acle_se_Secure_FlashTest+0x330>)
 c0026ba:	f003 f91d 	bl	c0058f8 <puts>

	    // Use Secure alias address (0x0C...)
	    uint64_t data_to_write;
	    memcpy(&data_to_write, ns_work_buffer, sizeof(data_to_write));
 c0026be:	4b6d      	ldr	r3, [pc, #436]	@ (c002874 <__acle_se_Secure_FlashTest+0x32c>)
 c0026c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0026c4:	e9c7 2300 	strd	r2, r3, [r7]

	    status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 c0026c8:	e9d7 2300 	ldrd	r2, r3, [r7]
 c0026cc:	496b      	ldr	r1, [pc, #428]	@ (c00287c <__acle_se_Secure_FlashTest+0x334>)
 c0026ce:	2001      	movs	r0, #1
 c0026d0:	f001 fc20 	bl	c003f14 <HAL_FLASH_Program>
 c0026d4:	4603      	mov	r3, r0
 c0026d6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	                                FLASH_TEST_ADDR_SECURE,  // Secure alias
	                                data_to_write);

	    if (status != HAL_OK)
 c0026da:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0026de:	2b00      	cmp	r3, #0
 c0026e0:	d018      	beq.n	c002714 <__acle_se_Secure_FlashTest+0x1cc>
	    {
	        uint32_t flash_error = HAL_FLASH_GetError();
 c0026e2:	f001 fcc1 	bl	c004068 <HAL_FLASH_GetError>
 c0026e6:	63f8      	str	r0, [r7, #60]	@ 0x3c
	        printf("[Secure]  Program FAILED\r\n");
 c0026e8:	4865      	ldr	r0, [pc, #404]	@ (c002880 <__acle_se_Secure_FlashTest+0x338>)
 c0026ea:	f003 f905 	bl	c0058f8 <puts>
	        printf("[Secure]    Status: %d\r\n", status);
 c0026ee:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0026f2:	4619      	mov	r1, r3
 c0026f4:	4863      	ldr	r0, [pc, #396]	@ (c002884 <__acle_se_Secure_FlashTest+0x33c>)
 c0026f6:	f003 f897 	bl	c005828 <iprintf>
	        printf("[Secure]    Error: 0x%08lX\r\n", flash_error);
 c0026fa:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 c0026fc:	4862      	ldr	r0, [pc, #392]	@ (c002888 <__acle_se_Secure_FlashTest+0x340>)
 c0026fe:	f003 f893 	bl	c005828 <iprintf>
	        printf("[Secure]    SECSR: 0x%08lX\r\n", FLASH->SECSR);
 c002702:	4b62      	ldr	r3, [pc, #392]	@ (c00288c <__acle_se_Secure_FlashTest+0x344>)
 c002704:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c002706:	4619      	mov	r1, r3
 c002708:	4861      	ldr	r0, [pc, #388]	@ (c002890 <__acle_se_Secure_FlashTest+0x348>)
 c00270a:	f003 f88d 	bl	c005828 <iprintf>
	        HAL_FLASH_Lock();
 c00270e:	f001 fc81 	bl	c004014 <HAL_FLASH_Lock>
	        goto restore_attributes;
 c002712:	e032      	b.n	c00277a <__acle_se_Secure_FlashTest+0x232>
	    }

	    printf("[Secure]  Program OK\r\n");
 c002714:	485f      	ldr	r0, [pc, #380]	@ (c002894 <__acle_se_Secure_FlashTest+0x34c>)
 c002716:	f003 f8ef 	bl	c0058f8 <puts>

	    // ========== Step 7: Lock Flash ==========
	    HAL_FLASH_Lock();
 c00271a:	f001 fc7b 	bl	c004014 <HAL_FLASH_Lock>
  __ASM volatile ("dsb 0xF":::"memory");
 c00271e:	f3bf 8f4f 	dsb	sy
}
 c002722:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002724:	f3bf 8f6f 	isb	sy
}
 c002728:	bf00      	nop
	    // ========== Step 8: Verify (while still Secure) ==========
	    // Clean and invalidate cache
	    __DSB();
	    __ISB();

	    uint64_t verify_value = *(volatile uint64_t*)FLASH_TEST_ADDR_SECURE;
 c00272a:	4b54      	ldr	r3, [pc, #336]	@ (c00287c <__acle_se_Secure_FlashTest+0x334>)
 c00272c:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002730:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40

	    if (verify_value == test_data)
 c002734:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c002738:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 c00273c:	4299      	cmp	r1, r3
 c00273e:	bf08      	it	eq
 c002740:	4290      	cmpeq	r0, r2
 c002742:	d10d      	bne.n	c002760 <__acle_se_Secure_FlashTest+0x218>
	    {
	        printf("[Secure]  Verify OK!\r\n");
 c002744:	4854      	ldr	r0, [pc, #336]	@ (c002898 <__acle_se_Secure_FlashTest+0x350>)
 c002746:	f003 f8d7 	bl	c0058f8 <puts>
	        printf("[Secure]    Written:  0x%016llX\r\n", test_data);
 c00274a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c00274e:	4853      	ldr	r0, [pc, #332]	@ (c00289c <__acle_se_Secure_FlashTest+0x354>)
 c002750:	f003 f86a 	bl	c005828 <iprintf>
	        printf("[Secure]    Read:     0x%016llX\r\n", verify_value);
 c002754:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002758:	4851      	ldr	r0, [pc, #324]	@ (c0028a0 <__acle_se_Secure_FlashTest+0x358>)
 c00275a:	f003 f865 	bl	c005828 <iprintf>
 c00275e:	e00c      	b.n	c00277a <__acle_se_Secure_FlashTest+0x232>
	    }
	    else
	    {
	        printf("[Secure]  Verify FAILED!\r\n");
 c002760:	4850      	ldr	r0, [pc, #320]	@ (c0028a4 <__acle_se_Secure_FlashTest+0x35c>)
 c002762:	f003 f8c9 	bl	c0058f8 <puts>
	        printf("[Secure]    Expected: 0x%016llX\r\n", test_data);
 c002766:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c00276a:	484f      	ldr	r0, [pc, #316]	@ (c0028a8 <__acle_se_Secure_FlashTest+0x360>)
 c00276c:	f003 f85c 	bl	c005828 <iprintf>
	        printf("[Secure]    Got:      0x%016llX\r\n", verify_value);
 c002770:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002774:	484d      	ldr	r0, [pc, #308]	@ (c0028ac <__acle_se_Secure_FlashTest+0x364>)
 c002776:	f003 f857 	bl	c005828 <iprintf>
	    }

	restore_attributes:
	    // ========== Step 9: Demote back to Original Attributes ==========
	    printf("[Secure] Restoring attributes...\r\n");
 c00277a:	484d      	ldr	r0, [pc, #308]	@ (c0028b0 <__acle_se_Secure_FlashTest+0x368>)
 c00277c:	f003 f8bc 	bl	c0058f8 <puts>

	    // Restore original attribute
	    flash_bb_attr.BBAttributes_array[attr_index] = saved_attr;
 c002780:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c002782:	3302      	adds	r3, #2
 c002784:	009b      	lsls	r3, r3, #2
 c002786:	3360      	adds	r3, #96	@ 0x60
 c002788:	443b      	add	r3, r7
 c00278a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c00278c:	f843 2c4c 	str.w	r2, [r3, #-76]

	    status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c002790:	f107 0314 	add.w	r3, r7, #20
 c002794:	4618      	mov	r0, r3
 c002796:	f001 fd89 	bl	c0042ac <HAL_FLASHEx_ConfigBBAttributes>
 c00279a:	4603      	mov	r3, r0
 c00279c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c0027a0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0027a4:	2b00      	cmp	r3, #0
 c0027a6:	d009      	beq.n	c0027bc <__acle_se_Secure_FlashTest+0x274>
	    {
	        printf("[Secure]   WARNING: Failed to restore: %d\r\n", status);
 c0027a8:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0027ac:	4619      	mov	r1, r3
 c0027ae:	4841      	ldr	r0, [pc, #260]	@ (c0028b4 <__acle_se_Secure_FlashTest+0x36c>)
 c0027b0:	f003 f83a 	bl	c005828 <iprintf>
	        printf("[Secure]   Page may remain SECURE!\r\n");
 c0027b4:	4840      	ldr	r0, [pc, #256]	@ (c0028b8 <__acle_se_Secure_FlashTest+0x370>)
 c0027b6:	f003 f89f 	bl	c0058f8 <puts>
 c0027ba:	e002      	b.n	c0027c2 <__acle_se_Secure_FlashTest+0x27a>
	    }
	    else
	    {
	        printf("[Secure]  Attributes restored\r\n");
 c0027bc:	483f      	ldr	r0, [pc, #252]	@ (c0028bc <__acle_se_Secure_FlashTest+0x374>)
 c0027be:	f003 f89b 	bl	c0058f8 <puts>
  __ASM volatile ("dsb 0xF":::"memory");
 c0027c2:	f3bf 8f4f 	dsb	sy
}
 c0027c6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0027c8:	f3bf 8f6f 	isb	sy
}
 c0027cc:	bf00      	nop

	    // ========== Step 10: Invalidate Caches ==========
	    __DSB();
	    __ISB();

	    printf("[Secure]  Flash Test Complete!\r\n");
 c0027ce:	483c      	ldr	r0, [pc, #240]	@ (c0028c0 <__acle_se_Secure_FlashTest+0x378>)
 c0027d0:	f003 f892 	bl	c0058f8 <puts>
}
 c0027d4:	3760      	adds	r7, #96	@ 0x60
 c0027d6:	46bd      	mov	sp, r7
 c0027d8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0027dc:	4670      	mov	r0, lr
 c0027de:	4671      	mov	r1, lr
 c0027e0:	4672      	mov	r2, lr
 c0027e2:	4673      	mov	r3, lr
 c0027e4:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0027e8:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0027ec:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0027f0:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0027f4:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0027f8:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0027fc:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002800:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002804:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002808:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00280c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002810:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002814:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002818:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00281c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002820:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002824:	f38e 8c00 	msr	CPSR_fs, lr
 c002828:	b410      	push	{r4}
 c00282a:	eef1 ca10 	vmrs	ip, fpscr
 c00282e:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002832:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002836:	ea0c 0c04 	and.w	ip, ip, r4
 c00283a:	eee1 ca10 	vmsr	fpscr, ip
 c00283e:	bc10      	pop	{r4}
 c002840:	46f4      	mov	ip, lr
 c002842:	4774      	bxns	lr
 c002844:	f3af 8000 	nop.w
 c002848:	0c006758 	.word	0x0c006758
 c00284c:	0c00678c 	.word	0x0c00678c
 c002850:	0c006794 	.word	0x0c006794
 c002854:	0c0067a0 	.word	0x0c0067a0
 c002858:	0c0067c0 	.word	0x0c0067c0
 c00285c:	0c0067e4 	.word	0x0c0067e4
 c002860:	0c006808 	.word	0x0c006808
 c002864:	0c00682c 	.word	0x0c00682c
 c002868:	0c006850 	.word	0x0c006850
 c00286c:	0c006868 	.word	0x0c006868
 c002870:	0c0068a4 	.word	0x0c0068a4
 c002874:	30002e28 	.word	0x30002e28
 c002878:	0c0068bc 	.word	0x0c0068bc
 c00287c:	0c0be000 	.word	0x0c0be000
 c002880:	0c0068d8 	.word	0x0c0068d8
 c002884:	0c0068f8 	.word	0x0c0068f8
 c002888:	0c006914 	.word	0x0c006914
 c00288c:	50022000 	.word	0x50022000
 c002890:	0c006934 	.word	0x0c006934
 c002894:	0c006954 	.word	0x0c006954
 c002898:	0c006970 	.word	0x0c006970
 c00289c:	0c00698c 	.word	0x0c00698c
 c0028a0:	0c0069b0 	.word	0x0c0069b0
 c0028a4:	0c0069d4 	.word	0x0c0069d4
 c0028a8:	0c0069f4 	.word	0x0c0069f4
 c0028ac:	0c006a18 	.word	0x0c006a18
 c0028b0:	0c006a3c 	.word	0x0c006a3c
 c0028b4:	0c006a60 	.word	0x0c006a60
 c0028b8:	0c006a94 	.word	0x0c006a94
 c0028bc:	0c006ac0 	.word	0x0c006ac0
 c0028c0:	0c006ae4 	.word	0x0c006ae4
 c0028c4:	12345678 	.word	0x12345678
 c0028c8:	12345678 	.word	0x12345678
 c0028cc:	00000000 	.word	0x00000000

0c0028d0 <__acle_se_Secure_EraseWriteVerify>:


//Ben try to delete direcly
__attribute__((cmse_nonsecure_entry))
void Secure_EraseWriteVerify(void)
{
 c0028d0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c0028d4:	b09c      	sub	sp, #112	@ 0x70
 c0028d6:	af00      	add	r7, sp, #0
    HAL_StatusTypeDef status;
    FLASH_EraseInitTypeDef EraseInitStruct = {0};
 c0028d8:	f107 0318 	add.w	r3, r7, #24
 c0028dc:	2200      	movs	r2, #0
 c0028de:	601a      	str	r2, [r3, #0]
 c0028e0:	605a      	str	r2, [r3, #4]
 c0028e2:	609a      	str	r2, [r3, #8]
 c0028e4:	60da      	str	r2, [r3, #12]
    uint32_t PageError = 0;
 c0028e6:	2300      	movs	r3, #0
 c0028e8:	667b      	str	r3, [r7, #100]	@ 0x64
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c0028ea:	a38e      	add	r3, pc, #568	@ (adr r3, c002b24 <__acle_se_Secure_EraseWriteVerify+0x254>)
 c0028ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0028f0:	e9c7 2316 	strd	r2, r3, [r7, #88]	@ 0x58

    uint32_t target_page = 127;
 c0028f4:	237f      	movs	r3, #127	@ 0x7f
 c0028f6:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t target_addr = 0x0807F800;
 c0028f8:	4b85      	ldr	r3, [pc, #532]	@ (c002b10 <__acle_se_Secure_EraseWriteVerify+0x240>)
 c0028fa:	653b      	str	r3, [r7, #80]	@ 0x50

    volatile uint32_t debug_step = 0;
 c0028fc:	2300      	movs	r3, #0
 c0028fe:	617b      	str	r3, [r7, #20]
    volatile uint32_t debug_match = 0;
 c002900:	2300      	movs	r3, #0
 c002902:	613b      	str	r3, [r7, #16]
    volatile uint32_t debug_notmatch = 0;
 c002904:	2300      	movs	r3, #0
 c002906:	60fb      	str	r3, [r7, #12]

    HAL_ICACHE_Disable();
 c002908:	f002 f908 	bl	c004b1c <HAL_ICACHE_Disable>
    debug_step = 1;
 c00290c:	2301      	movs	r3, #1
 c00290e:	617b      	str	r3, [r7, #20]

    // ========== Unlock NS ==========
    FLASH->NSKEYR = FLASH_KEY1;
 c002910:	4b80      	ldr	r3, [pc, #512]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002912:	4a81      	ldr	r2, [pc, #516]	@ (c002b18 <__acle_se_Secure_EraseWriteVerify+0x248>)
 c002914:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c002916:	4b7f      	ldr	r3, [pc, #508]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002918:	4a80      	ldr	r2, [pc, #512]	@ (c002b1c <__acle_se_Secure_EraseWriteVerify+0x24c>)
 c00291a:	609a      	str	r2, [r3, #8]

    if (HAL_FLASH_Unlock() != HAL_OK) {
 c00291c:	f001 fb44 	bl	c003fa8 <HAL_FLASH_Unlock>
 c002920:	4603      	mov	r3, r0
 c002922:	2b00      	cmp	r3, #0
 c002924:	d004      	beq.n	c002930 <__acle_se_Secure_EraseWriteVerify+0x60>
        debug_step = 10; // Unlock failed
 c002926:	230a      	movs	r3, #10
 c002928:	617b      	str	r3, [r7, #20]
        HAL_ICACHE_Enable();
 c00292a:	f002 f8e7 	bl	c004afc <HAL_ICACHE_Enable>
 c00292e:	e0b5      	b.n	c002a9c <__acle_se_Secure_EraseWriteVerify+0x1cc>
        return;
    }

    // ==========   HAL  Non-Secure operation ==========
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;  // Non-Secure operation
 c002930:	4b7b      	ldr	r3, [pc, #492]	@ (c002b20 <__acle_se_Secure_EraseWriteVerify+0x250>)
 c002932:	2202      	movs	r2, #2
 c002934:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;  // Clear all flags
 c002936:	4b77      	ldr	r3, [pc, #476]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002938:	f04f 32ff 	mov.w	r2, #4294967295
 c00293c:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c00293e:	f3bf 8f4f 	dsb	sy
}
 c002942:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002944:	f3bf 8f6f 	isb	sy
}
 c002948:	bf00      	nop
//        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
//        HAL_ICACHE_Enable();
//        return;
//    }

    debug_step = 3;  // Erase OK
 c00294a:	2303      	movs	r3, #3
 c00294c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 c00294e:	f3bf 8f4f 	dsb	sy
}
 c002952:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002954:	f3bf 8f6f 	isb	sy
}
 c002958:	bf00      	nop

    __DSB();
    __ISB();

    // ========== Program 256 words ==========
    debug_step = 4;
 c00295a:	2304      	movs	r3, #4
 c00295c:	617b      	str	r3, [r7, #20]

    for (uint32_t i = 0; i < 256; i++) {
 c00295e:	2300      	movs	r3, #0
 c002960:	66fb      	str	r3, [r7, #108]	@ 0x6c
 c002962:	e047      	b.n	c0029f4 <__acle_se_Secure_EraseWriteVerify+0x124>
        uint32_t addr = target_addr + (i * 8);
 c002964:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c002966:	00db      	lsls	r3, r3, #3
 c002968:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c00296a:	4413      	add	r3, r2
 c00296c:	637b      	str	r3, [r7, #52]	@ 0x34
        uint64_t value = test_value + i;
 c00296e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c002970:	2200      	movs	r2, #0
 c002972:	4698      	mov	r8, r3
 c002974:	4691      	mov	r9, r2
 c002976:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 c00297a:	eb12 0108 	adds.w	r1, r2, r8
 c00297e:	6039      	str	r1, [r7, #0]
 c002980:	eb43 0309 	adc.w	r3, r3, r9
 c002984:	607b      	str	r3, [r7, #4]
 c002986:	e9d7 2300 	ldrd	r2, r3, [r7]
 c00298a:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c00298e:	bf00      	nop
 c002990:	4b60      	ldr	r3, [pc, #384]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002992:	6a1b      	ldr	r3, [r3, #32]
 c002994:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002998:	2b00      	cmp	r3, #0
 c00299a:	d1f9      	bne.n	c002990 <__acle_se_Secure_EraseWriteVerify+0xc0>

        // Clear any errors
        FLASH->NSSR = 0xFFFFFFFF;
 c00299c:	4b5d      	ldr	r3, [pc, #372]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c00299e:	f04f 32ff 	mov.w	r2, #4294967295
 c0029a2:	621a      	str	r2, [r3, #32]

        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c0029a4:	4b5b      	ldr	r3, [pc, #364]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c0029a8:	4a5a      	ldr	r2, [pc, #360]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029aa:	f043 0301 	orr.w	r3, r3, #1
 c0029ae:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(value);
 c0029b0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c0029b2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 c0029b4:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c0029b6:	f3bf 8f6f 	isb	sy
}
 c0029ba:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(value >> 32);
 c0029bc:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 c0029c0:	f04f 0200 	mov.w	r2, #0
 c0029c4:	f04f 0300 	mov.w	r3, #0
 c0029c8:	000a      	movs	r2, r1
 c0029ca:	2300      	movs	r3, #0
 c0029cc:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 c0029ce:	3104      	adds	r1, #4
 c0029d0:	4613      	mov	r3, r2
 c0029d2:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c0029d4:	bf00      	nop
 c0029d6:	4b4f      	ldr	r3, [pc, #316]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029d8:	6a1b      	ldr	r3, [r3, #32]
 c0029da:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c0029de:	2b00      	cmp	r3, #0
 c0029e0:	d1f9      	bne.n	c0029d6 <__acle_se_Secure_EraseWriteVerify+0x106>

        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c0029e2:	4b4c      	ldr	r3, [pc, #304]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029e4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c0029e6:	4a4b      	ldr	r2, [pc, #300]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029e8:	f023 0301 	bic.w	r3, r3, #1
 c0029ec:	6293      	str	r3, [r2, #40]	@ 0x28
    for (uint32_t i = 0; i < 256; i++) {
 c0029ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c0029f0:	3301      	adds	r3, #1
 c0029f2:	66fb      	str	r3, [r7, #108]	@ 0x6c
 c0029f4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c0029f6:	2bff      	cmp	r3, #255	@ 0xff
 c0029f8:	d9b4      	bls.n	c002964 <__acle_se_Secure_EraseWriteVerify+0x94>
  __ASM volatile ("dsb 0xF":::"memory");
 c0029fa:	f3bf 8f4f 	dsb	sy
}
 c0029fe:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002a00:	f3bf 8f6f 	isb	sy
}
 c002a04:	bf00      	nop

    __DSB();
    __ISB();

    // ========== Invalidate Cache ==========
    debug_step = 5;
 c002a06:	2305      	movs	r3, #5
 c002a08:	617b      	str	r3, [r7, #20]
    HAL_ICACHE_Invalidate();
 c002a0a:	f002 f8b7 	bl	c004b7c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c002a0e:	f3bf 8f4f 	dsb	sy
}
 c002a12:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002a14:	f3bf 8f6f 	isb	sy
}
 c002a18:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    debug_step = 6;
 c002a1a:	2306      	movs	r3, #6
 c002a1c:	617b      	str	r3, [r7, #20]

    for (uint32_t j = 0; j < 256; j++) {
 c002a1e:	2300      	movs	r3, #0
 c002a20:	66bb      	str	r3, [r7, #104]	@ 0x68
 c002a22:	e027      	b.n	c002a74 <__acle_se_Secure_EraseWriteVerify+0x1a4>
        uint32_t addr = target_addr + (j * 8);
 c002a24:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a26:	00db      	lsls	r3, r3, #3
 c002a28:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c002a2a:	4413      	add	r3, r2
 c002a2c:	64fb      	str	r3, [r7, #76]	@ 0x4c
        uint64_t expected = test_value + j;
 c002a2e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a30:	2200      	movs	r2, #0
 c002a32:	461c      	mov	r4, r3
 c002a34:	4615      	mov	r5, r2
 c002a36:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 c002a3a:	eb12 0a04 	adds.w	sl, r2, r4
 c002a3e:	eb43 0b05 	adc.w	fp, r3, r5
 c002a42:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
        uint64_t actual = *(volatile uint64_t*)addr;
 c002a46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002a48:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002a4c:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

        if (actual == expected) {
 c002a50:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 c002a54:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002a58:	4299      	cmp	r1, r3
 c002a5a:	bf08      	it	eq
 c002a5c:	4290      	cmpeq	r0, r2
 c002a5e:	d103      	bne.n	c002a68 <__acle_se_Secure_EraseWriteVerify+0x198>
            debug_match++;
 c002a60:	693b      	ldr	r3, [r7, #16]
 c002a62:	3301      	adds	r3, #1
 c002a64:	613b      	str	r3, [r7, #16]
 c002a66:	e002      	b.n	c002a6e <__acle_se_Secure_EraseWriteVerify+0x19e>
        } else {
            debug_notmatch++;
 c002a68:	68fb      	ldr	r3, [r7, #12]
 c002a6a:	3301      	adds	r3, #1
 c002a6c:	60fb      	str	r3, [r7, #12]
    for (uint32_t j = 0; j < 256; j++) {
 c002a6e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a70:	3301      	adds	r3, #1
 c002a72:	66bb      	str	r3, [r7, #104]	@ 0x68
 c002a74:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a76:	2bff      	cmp	r3, #255	@ 0xff
 c002a78:	d9d4      	bls.n	c002a24 <__acle_se_Secure_EraseWriteVerify+0x154>
        }
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002a7a:	4b26      	ldr	r3, [pc, #152]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002a7c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002a7e:	4a25      	ldr	r2, [pc, #148]	@ (c002b14 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002a80:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002a84:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002a86:	f002 f839 	bl	c004afc <HAL_ICACHE_Enable>

    if (debug_match == 256) {
 c002a8a:	693b      	ldr	r3, [r7, #16]
 c002a8c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c002a90:	d102      	bne.n	c002a98 <__acle_se_Secure_EraseWriteVerify+0x1c8>
        debug_step = 100;  //  Success
 c002a92:	2364      	movs	r3, #100	@ 0x64
 c002a94:	617b      	str	r3, [r7, #20]
 c002a96:	e001      	b.n	c002a9c <__acle_se_Secure_EraseWriteVerify+0x1cc>
    } else {
        debug_step = 101;  //  Failed
 c002a98:	2365      	movs	r3, #101	@ 0x65
 c002a9a:	617b      	str	r3, [r7, #20]
    }
}
 c002a9c:	3770      	adds	r7, #112	@ 0x70
 c002a9e:	46bd      	mov	sp, r7
 c002aa0:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002aa4:	4670      	mov	r0, lr
 c002aa6:	4671      	mov	r1, lr
 c002aa8:	4672      	mov	r2, lr
 c002aaa:	4673      	mov	r3, lr
 c002aac:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002ab0:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002ab4:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002ab8:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002abc:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002ac0:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002ac4:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002ac8:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002acc:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002ad0:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002ad4:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002ad8:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002adc:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002ae0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002ae4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002ae8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002aec:	f38e 8c00 	msr	CPSR_fs, lr
 c002af0:	b410      	push	{r4}
 c002af2:	eef1 ca10 	vmrs	ip, fpscr
 c002af6:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002afa:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002afe:	ea0c 0c04 	and.w	ip, ip, r4
 c002b02:	eee1 ca10 	vmsr	fpscr, ip
 c002b06:	bc10      	pop	{r4}
 c002b08:	46f4      	mov	ip, lr
 c002b0a:	4774      	bxns	lr
 c002b0c:	f3af 8000 	nop.w
 c002b10:	0807f800 	.word	0x0807f800
 c002b14:	50022000 	.word	0x50022000
 c002b18:	45670123 	.word	0x45670123
 c002b1c:	cdef89ab 	.word	0xcdef89ab
 c002b20:	30000024 	.word	0x30000024
 c002b24:	9abcdef0 	.word	0x9abcdef0
 c002b28:	12345678 	.word	0x12345678
 c002b2c:	00000000 	.word	0x00000000

0c002b30 <__acle_se_Secure_WriteFlash_128KB>:

__attribute__((cmse_nonsecure_entry))
void Secure_WriteFlash_128KB(uint32_t *success_words, uint32_t *failed_words)
{
 c002b30:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002b34:	b096      	sub	sp, #88	@ 0x58
 c002b36:	af00      	add	r7, sp, #0
 c002b38:	60f8      	str	r0, [r7, #12]
 c002b3a:	60b9      	str	r1, [r7, #8]
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c002b3c:	a38a      	add	r3, pc, #552	@ (adr r3, c002d68 <__acle_se_Secure_WriteFlash_128KB+0x238>)
 c002b3e:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002b42:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

    //  Pages 64-127 (128KB)
    uint32_t start_addr = 0x08060000;  // Page 64
 c002b46:	4b82      	ldr	r3, [pc, #520]	@ (c002d50 <__acle_se_Secure_WriteFlash_128KB+0x220>)
 c002b48:	637b      	str	r3, [r7, #52]	@ 0x34
    uint32_t end_addr   = 0x0807FFFF;  // Page 127
 c002b4a:	4b82      	ldr	r3, [pc, #520]	@ (c002d54 <__acle_se_Secure_WriteFlash_128KB+0x224>)
 c002b4c:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t total_words = (end_addr - start_addr + 1) / 8;  // 16,384 words
 c002b4e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 c002b50:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002b52:	1ad3      	subs	r3, r2, r3
 c002b54:	3301      	adds	r3, #1
 c002b56:	08db      	lsrs	r3, r3, #3
 c002b58:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t success = 0;
 c002b5a:	2300      	movs	r3, #0
 c002b5c:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t failed = 0;
 c002b5e:	2300      	movs	r3, #0
 c002b60:	653b      	str	r3, [r7, #80]	@ 0x50

    HAL_ICACHE_Disable();
 c002b62:	f001 ffdb 	bl	c004b1c <HAL_ICACHE_Disable>

    // Unlock NS Flash
    FLASH->NSKEYR = FLASH_KEY1;
 c002b66:	4b7c      	ldr	r3, [pc, #496]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b68:	4a7c      	ldr	r2, [pc, #496]	@ (c002d5c <__acle_se_Secure_WriteFlash_128KB+0x22c>)
 c002b6a:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c002b6c:	4b7a      	ldr	r3, [pc, #488]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b6e:	4a7c      	ldr	r2, [pc, #496]	@ (c002d60 <__acle_se_Secure_WriteFlash_128KB+0x230>)
 c002b70:	609a      	str	r2, [r3, #8]

    if (FLASH->NSCR & FLASH_NSCR_NSLOCK) {
 c002b72:	4b79      	ldr	r3, [pc, #484]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b74:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002b76:	2b00      	cmp	r3, #0
 c002b78:	da08      	bge.n	c002b8c <__acle_se_Secure_WriteFlash_128KB+0x5c>
        HAL_ICACHE_Enable();
 c002b7a:	f001 ffbf 	bl	c004afc <HAL_ICACHE_Enable>
        *success_words = 0;
 c002b7e:	68fb      	ldr	r3, [r7, #12]
 c002b80:	2200      	movs	r2, #0
 c002b82:	601a      	str	r2, [r3, #0]
        *failed_words = total_words;
 c002b84:	68bb      	ldr	r3, [r7, #8]
 c002b86:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 c002b88:	601a      	str	r2, [r3, #0]
        return;
 c002b8a:	e0a6      	b.n	c002cda <__acle_se_Secure_WriteFlash_128KB+0x1aa>
    }

    // Force Non-Secure operation
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;
 c002b8c:	4b75      	ldr	r3, [pc, #468]	@ (c002d64 <__acle_se_Secure_WriteFlash_128KB+0x234>)
 c002b8e:	2202      	movs	r2, #2
 c002b90:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;
 c002b92:	4b71      	ldr	r3, [pc, #452]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b94:	f04f 32ff 	mov.w	r2, #4294967295
 c002b98:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c002b9a:	f3bf 8f4f 	dsb	sy
}
 c002b9e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002ba0:	f3bf 8f6f 	isb	sy
}
 c002ba4:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Write 128KB ==========
    uint32_t word_index = 0;
 c002ba6:	2300      	movs	r3, #0
 c002ba8:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002baa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002bac:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002bae:	e045      	b.n	c002c3c <__acle_se_Secure_WriteFlash_128KB+0x10c>
        uint64_t value = test_value + word_index;
 c002bb0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002bb2:	2200      	movs	r2, #0
 c002bb4:	4698      	mov	r8, r3
 c002bb6:	4691      	mov	r9, r2
 c002bb8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002bbc:	eb12 0108 	adds.w	r1, r2, r8
 c002bc0:	6039      	str	r1, [r7, #0]
 c002bc2:	eb43 0309 	adc.w	r3, r3, r9
 c002bc6:	607b      	str	r3, [r7, #4]
 c002bc8:	e9d7 2300 	ldrd	r2, r3, [r7]
 c002bcc:	e9c7 2304 	strd	r2, r3, [r7, #16]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002bd0:	bf00      	nop
 c002bd2:	4b61      	ldr	r3, [pc, #388]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bd4:	6a1b      	ldr	r3, [r3, #32]
 c002bd6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002bda:	2b00      	cmp	r3, #0
 c002bdc:	d1f9      	bne.n	c002bd2 <__acle_se_Secure_WriteFlash_128KB+0xa2>
        FLASH->NSSR = 0xFFFFFFFF;
 c002bde:	4b5e      	ldr	r3, [pc, #376]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002be0:	f04f 32ff 	mov.w	r2, #4294967295
 c002be4:	621a      	str	r2, [r3, #32]
        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002be6:	4b5c      	ldr	r3, [pc, #368]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002be8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002bea:	4a5b      	ldr	r2, [pc, #364]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bec:	f043 0301 	orr.w	r3, r3, #1
 c002bf0:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(value);
 c002bf2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002bf4:	693a      	ldr	r2, [r7, #16]
 c002bf6:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002bf8:	f3bf 8f6f 	isb	sy
}
 c002bfc:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(value >> 32);
 c002bfe:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 c002c02:	f04f 0200 	mov.w	r2, #0
 c002c06:	f04f 0300 	mov.w	r3, #0
 c002c0a:	000a      	movs	r2, r1
 c002c0c:	2300      	movs	r3, #0
 c002c0e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 c002c10:	3104      	adds	r1, #4
 c002c12:	4613      	mov	r3, r2
 c002c14:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002c16:	bf00      	nop
 c002c18:	4b4f      	ldr	r3, [pc, #316]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002c1a:	6a1b      	ldr	r3, [r3, #32]
 c002c1c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002c20:	2b00      	cmp	r3, #0
 c002c22:	d1f9      	bne.n	c002c18 <__acle_se_Secure_WriteFlash_128KB+0xe8>
        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002c24:	4b4c      	ldr	r3, [pc, #304]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002c26:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002c28:	4a4b      	ldr	r2, [pc, #300]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002c2a:	f023 0301 	bic.w	r3, r3, #1
 c002c2e:	6293      	str	r3, [r2, #40]	@ 0x28

        word_index++;
 c002c30:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002c32:	3301      	adds	r3, #1
 c002c34:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002c36:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002c38:	3308      	adds	r3, #8
 c002c3a:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002c3c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 c002c3e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002c40:	429a      	cmp	r2, r3
 c002c42:	d9b5      	bls.n	c002bb0 <__acle_se_Secure_WriteFlash_128KB+0x80>
  __ASM volatile ("dsb 0xF":::"memory");
 c002c44:	f3bf 8f4f 	dsb	sy
}
 c002c48:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002c4a:	f3bf 8f6f 	isb	sy
}
 c002c4e:	bf00      	nop

    __DSB();
    __ISB();

    // Invalidate Cache
    HAL_ICACHE_Invalidate();
 c002c50:	f001 ff94 	bl	c004b7c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c002c54:	f3bf 8f4f 	dsb	sy
}
 c002c58:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002c5a:	f3bf 8f6f 	isb	sy
}
 c002c5e:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    word_index = 0;
 c002c60:	2300      	movs	r3, #0
 c002c62:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002c64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002c66:	647b      	str	r3, [r7, #68]	@ 0x44
 c002c68:	e025      	b.n	c002cb6 <__acle_se_Secure_WriteFlash_128KB+0x186>
        uint64_t expected = test_value + word_index;
 c002c6a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002c6c:	2200      	movs	r2, #0
 c002c6e:	461c      	mov	r4, r3
 c002c70:	4615      	mov	r5, r2
 c002c72:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002c76:	eb12 0a04 	adds.w	sl, r2, r4
 c002c7a:	eb43 0b05 	adc.w	fp, r3, r5
 c002c7e:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        uint64_t actual = *(volatile uint64_t*)addr;
 c002c82:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002c84:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002c88:	e9c7 2306 	strd	r2, r3, [r7, #24]

        if (actual == expected) {
 c002c8c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 c002c90:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 c002c94:	4299      	cmp	r1, r3
 c002c96:	bf08      	it	eq
 c002c98:	4290      	cmpeq	r0, r2
 c002c9a:	d103      	bne.n	c002ca4 <__acle_se_Secure_WriteFlash_128KB+0x174>
            success++;
 c002c9c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c002c9e:	3301      	adds	r3, #1
 c002ca0:	657b      	str	r3, [r7, #84]	@ 0x54
 c002ca2:	e002      	b.n	c002caa <__acle_se_Secure_WriteFlash_128KB+0x17a>
        } else {
            failed++;
 c002ca4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c002ca6:	3301      	adds	r3, #1
 c002ca8:	653b      	str	r3, [r7, #80]	@ 0x50
        }

        word_index++;
 c002caa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002cac:	3301      	adds	r3, #1
 c002cae:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002cb0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002cb2:	3308      	adds	r3, #8
 c002cb4:	647b      	str	r3, [r7, #68]	@ 0x44
 c002cb6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 c002cb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002cba:	429a      	cmp	r2, r3
 c002cbc:	d9d5      	bls.n	c002c6a <__acle_se_Secure_WriteFlash_128KB+0x13a>
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002cbe:	4b26      	ldr	r3, [pc, #152]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002cc0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002cc2:	4a25      	ldr	r2, [pc, #148]	@ (c002d58 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002cc4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002cc8:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002cca:	f001 ff17 	bl	c004afc <HAL_ICACHE_Enable>

    *success_words = success;
 c002cce:	68fb      	ldr	r3, [r7, #12]
 c002cd0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 c002cd2:	601a      	str	r2, [r3, #0]
    *failed_words = failed;
 c002cd4:	68bb      	ldr	r3, [r7, #8]
 c002cd6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c002cd8:	601a      	str	r2, [r3, #0]
}
 c002cda:	3758      	adds	r7, #88	@ 0x58
 c002cdc:	46bd      	mov	sp, r7
 c002cde:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002ce2:	4670      	mov	r0, lr
 c002ce4:	4671      	mov	r1, lr
 c002ce6:	4672      	mov	r2, lr
 c002ce8:	4673      	mov	r3, lr
 c002cea:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002cee:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002cf2:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002cf6:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002cfa:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002cfe:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002d02:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002d06:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002d0a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002d0e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002d12:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002d16:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002d1a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002d1e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002d22:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002d26:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002d2a:	f38e 8c00 	msr	CPSR_fs, lr
 c002d2e:	b410      	push	{r4}
 c002d30:	eef1 ca10 	vmrs	ip, fpscr
 c002d34:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002d38:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002d3c:	ea0c 0c04 	and.w	ip, ip, r4
 c002d40:	eee1 ca10 	vmsr	fpscr, ip
 c002d44:	bc10      	pop	{r4}
 c002d46:	46f4      	mov	ip, lr
 c002d48:	4774      	bxns	lr
 c002d4a:	bf00      	nop
 c002d4c:	f3af 8000 	nop.w
 c002d50:	08060000 	.word	0x08060000
 c002d54:	0807ffff 	.word	0x0807ffff
 c002d58:	50022000 	.word	0x50022000
 c002d5c:	45670123 	.word	0x45670123
 c002d60:	cdef89ab 	.word	0xcdef89ab
 c002d64:	30000024 	.word	0x30000024
 c002d68:	9abcdef0 	.word	0x9abcdef0
 c002d6c:	12345678 	.word	0x12345678

0c002d70 <__acle_se_Secure_WriteFlash_128KB_2>:


__attribute__((cmse_nonsecure_entry))
void Secure_WriteFlash_128KB_2(uint32_t *success_words, uint32_t *failed_words)
{
 c002d70:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002d74:	b096      	sub	sp, #88	@ 0x58
 c002d76:	af00      	add	r7, sp, #0
 c002d78:	60f8      	str	r0, [r7, #12]
 c002d7a:	60b9      	str	r1, [r7, #8]
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c002d7c:	a38a      	add	r3, pc, #552	@ (adr r3, c002fa8 <__acle_se_Secure_WriteFlash_128KB_2+0x238>)
 c002d7e:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002d82:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

    //  Pages 64-127 (128KB)
    uint32_t start_addr = 0x08060000;  // Page 64
 c002d86:	4b82      	ldr	r3, [pc, #520]	@ (c002f90 <__acle_se_Secure_WriteFlash_128KB_2+0x220>)
 c002d88:	637b      	str	r3, [r7, #52]	@ 0x34
    uint32_t end_addr   = 0x0807FFFF;  // Page 127
 c002d8a:	4b82      	ldr	r3, [pc, #520]	@ (c002f94 <__acle_se_Secure_WriteFlash_128KB_2+0x224>)
 c002d8c:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t total_words = (end_addr - start_addr + 1) / 8;  // 16,384 words
 c002d8e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 c002d90:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002d92:	1ad3      	subs	r3, r2, r3
 c002d94:	3301      	adds	r3, #1
 c002d96:	08db      	lsrs	r3, r3, #3
 c002d98:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t success = 0;
 c002d9a:	2300      	movs	r3, #0
 c002d9c:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t failed = 0;
 c002d9e:	2300      	movs	r3, #0
 c002da0:	653b      	str	r3, [r7, #80]	@ 0x50

    HAL_ICACHE_Disable();
 c002da2:	f001 febb 	bl	c004b1c <HAL_ICACHE_Disable>

    // Unlock NS Flash
    FLASH->NSKEYR = FLASH_KEY1;
 c002da6:	4b7c      	ldr	r3, [pc, #496]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002da8:	4a7c      	ldr	r2, [pc, #496]	@ (c002f9c <__acle_se_Secure_WriteFlash_128KB_2+0x22c>)
 c002daa:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c002dac:	4b7a      	ldr	r3, [pc, #488]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002dae:	4a7c      	ldr	r2, [pc, #496]	@ (c002fa0 <__acle_se_Secure_WriteFlash_128KB_2+0x230>)
 c002db0:	609a      	str	r2, [r3, #8]

    if (FLASH->NSCR & FLASH_NSCR_NSLOCK) {
 c002db2:	4b79      	ldr	r3, [pc, #484]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002db4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002db6:	2b00      	cmp	r3, #0
 c002db8:	da08      	bge.n	c002dcc <__acle_se_Secure_WriteFlash_128KB_2+0x5c>
        HAL_ICACHE_Enable();
 c002dba:	f001 fe9f 	bl	c004afc <HAL_ICACHE_Enable>
        *success_words = 0;
 c002dbe:	68fb      	ldr	r3, [r7, #12]
 c002dc0:	2200      	movs	r2, #0
 c002dc2:	601a      	str	r2, [r3, #0]
        *failed_words = total_words;
 c002dc4:	68bb      	ldr	r3, [r7, #8]
 c002dc6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 c002dc8:	601a      	str	r2, [r3, #0]
        return;
 c002dca:	e0a6      	b.n	c002f1a <__acle_se_Secure_WriteFlash_128KB_2+0x1aa>
    }

    // Force Non-Secure operation
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;
 c002dcc:	4b75      	ldr	r3, [pc, #468]	@ (c002fa4 <__acle_se_Secure_WriteFlash_128KB_2+0x234>)
 c002dce:	2202      	movs	r2, #2
 c002dd0:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;
 c002dd2:	4b71      	ldr	r3, [pc, #452]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002dd4:	f04f 32ff 	mov.w	r2, #4294967295
 c002dd8:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c002dda:	f3bf 8f4f 	dsb	sy
}
 c002dde:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002de0:	f3bf 8f6f 	isb	sy
}
 c002de4:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Write 128KB ==========
    uint32_t word_index = 0;
 c002de6:	2300      	movs	r3, #0
 c002de8:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002dea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002dec:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002dee:	e045      	b.n	c002e7c <__acle_se_Secure_WriteFlash_128KB_2+0x10c>
        uint64_t value = test_value + word_index;
 c002df0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002df2:	2200      	movs	r2, #0
 c002df4:	4698      	mov	r8, r3
 c002df6:	4691      	mov	r9, r2
 c002df8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002dfc:	eb12 0108 	adds.w	r1, r2, r8
 c002e00:	6039      	str	r1, [r7, #0]
 c002e02:	eb43 0309 	adc.w	r3, r3, r9
 c002e06:	607b      	str	r3, [r7, #4]
 c002e08:	e9d7 2300 	ldrd	r2, r3, [r7]
 c002e0c:	e9c7 2304 	strd	r2, r3, [r7, #16]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002e10:	bf00      	nop
 c002e12:	4b61      	ldr	r3, [pc, #388]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e14:	6a1b      	ldr	r3, [r3, #32]
 c002e16:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002e1a:	2b00      	cmp	r3, #0
 c002e1c:	d1f9      	bne.n	c002e12 <__acle_se_Secure_WriteFlash_128KB_2+0xa2>
        FLASH->NSSR = 0xFFFFFFFF;
 c002e1e:	4b5e      	ldr	r3, [pc, #376]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e20:	f04f 32ff 	mov.w	r2, #4294967295
 c002e24:	621a      	str	r2, [r3, #32]
        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002e26:	4b5c      	ldr	r3, [pc, #368]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e28:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002e2a:	4a5b      	ldr	r2, [pc, #364]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e2c:	f043 0301 	orr.w	r3, r3, #1
 c002e30:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(test_value);
 c002e32:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002e34:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 c002e36:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002e38:	f3bf 8f6f 	isb	sy
}
 c002e3c:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(test_value >> 32);
 c002e3e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 c002e42:	f04f 0200 	mov.w	r2, #0
 c002e46:	f04f 0300 	mov.w	r3, #0
 c002e4a:	000a      	movs	r2, r1
 c002e4c:	2300      	movs	r3, #0
 c002e4e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 c002e50:	3104      	adds	r1, #4
 c002e52:	4613      	mov	r3, r2
 c002e54:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002e56:	bf00      	nop
 c002e58:	4b4f      	ldr	r3, [pc, #316]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e5a:	6a1b      	ldr	r3, [r3, #32]
 c002e5c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002e60:	2b00      	cmp	r3, #0
 c002e62:	d1f9      	bne.n	c002e58 <__acle_se_Secure_WriteFlash_128KB_2+0xe8>
        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002e64:	4b4c      	ldr	r3, [pc, #304]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e66:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002e68:	4a4b      	ldr	r2, [pc, #300]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e6a:	f023 0301 	bic.w	r3, r3, #1
 c002e6e:	6293      	str	r3, [r2, #40]	@ 0x28

        word_index++;
 c002e70:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002e72:	3301      	adds	r3, #1
 c002e74:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002e76:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002e78:	3308      	adds	r3, #8
 c002e7a:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002e7c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 c002e7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002e80:	429a      	cmp	r2, r3
 c002e82:	d9b5      	bls.n	c002df0 <__acle_se_Secure_WriteFlash_128KB_2+0x80>
  __ASM volatile ("dsb 0xF":::"memory");
 c002e84:	f3bf 8f4f 	dsb	sy
}
 c002e88:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002e8a:	f3bf 8f6f 	isb	sy
}
 c002e8e:	bf00      	nop

    __DSB();
    __ISB();

    // Invalidate Cache
    HAL_ICACHE_Invalidate();
 c002e90:	f001 fe74 	bl	c004b7c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c002e94:	f3bf 8f4f 	dsb	sy
}
 c002e98:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002e9a:	f3bf 8f6f 	isb	sy
}
 c002e9e:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    word_index = 0;
 c002ea0:	2300      	movs	r3, #0
 c002ea2:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002ea4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002ea6:	647b      	str	r3, [r7, #68]	@ 0x44
 c002ea8:	e025      	b.n	c002ef6 <__acle_se_Secure_WriteFlash_128KB_2+0x186>
        uint64_t expected = test_value + word_index;
 c002eaa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002eac:	2200      	movs	r2, #0
 c002eae:	461c      	mov	r4, r3
 c002eb0:	4615      	mov	r5, r2
 c002eb2:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002eb6:	eb12 0a04 	adds.w	sl, r2, r4
 c002eba:	eb43 0b05 	adc.w	fp, r3, r5
 c002ebe:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        uint64_t actual = *(volatile uint64_t*)addr;
 c002ec2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002ec4:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002ec8:	e9c7 2306 	strd	r2, r3, [r7, #24]

        if (actual == expected) {
 c002ecc:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 c002ed0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 c002ed4:	4299      	cmp	r1, r3
 c002ed6:	bf08      	it	eq
 c002ed8:	4290      	cmpeq	r0, r2
 c002eda:	d103      	bne.n	c002ee4 <__acle_se_Secure_WriteFlash_128KB_2+0x174>
            success++;
 c002edc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c002ede:	3301      	adds	r3, #1
 c002ee0:	657b      	str	r3, [r7, #84]	@ 0x54
 c002ee2:	e002      	b.n	c002eea <__acle_se_Secure_WriteFlash_128KB_2+0x17a>
        } else {
            failed++;
 c002ee4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c002ee6:	3301      	adds	r3, #1
 c002ee8:	653b      	str	r3, [r7, #80]	@ 0x50
        }

        word_index++;
 c002eea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002eec:	3301      	adds	r3, #1
 c002eee:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002ef0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002ef2:	3308      	adds	r3, #8
 c002ef4:	647b      	str	r3, [r7, #68]	@ 0x44
 c002ef6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 c002ef8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002efa:	429a      	cmp	r2, r3
 c002efc:	d9d5      	bls.n	c002eaa <__acle_se_Secure_WriteFlash_128KB_2+0x13a>
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002efe:	4b26      	ldr	r3, [pc, #152]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002f00:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002f02:	4a25      	ldr	r2, [pc, #148]	@ (c002f98 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002f04:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002f08:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002f0a:	f001 fdf7 	bl	c004afc <HAL_ICACHE_Enable>

    *success_words = success;
 c002f0e:	68fb      	ldr	r3, [r7, #12]
 c002f10:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 c002f12:	601a      	str	r2, [r3, #0]
    *failed_words = failed;
 c002f14:	68bb      	ldr	r3, [r7, #8]
 c002f16:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c002f18:	601a      	str	r2, [r3, #0]
}
 c002f1a:	3758      	adds	r7, #88	@ 0x58
 c002f1c:	46bd      	mov	sp, r7
 c002f1e:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002f22:	4670      	mov	r0, lr
 c002f24:	4671      	mov	r1, lr
 c002f26:	4672      	mov	r2, lr
 c002f28:	4673      	mov	r3, lr
 c002f2a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002f2e:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002f32:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002f36:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002f3a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002f3e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002f42:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002f46:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002f4a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002f4e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002f52:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002f56:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002f5a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002f5e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002f62:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002f66:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002f6a:	f38e 8c00 	msr	CPSR_fs, lr
 c002f6e:	b410      	push	{r4}
 c002f70:	eef1 ca10 	vmrs	ip, fpscr
 c002f74:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002f78:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002f7c:	ea0c 0c04 	and.w	ip, ip, r4
 c002f80:	eee1 ca10 	vmsr	fpscr, ip
 c002f84:	bc10      	pop	{r4}
 c002f86:	46f4      	mov	ip, lr
 c002f88:	4774      	bxns	lr
 c002f8a:	bf00      	nop
 c002f8c:	f3af 8000 	nop.w
 c002f90:	08060000 	.word	0x08060000
 c002f94:	0807ffff 	.word	0x0807ffff
 c002f98:	50022000 	.word	0x50022000
 c002f9c:	45670123 	.word	0x45670123
 c002fa0:	cdef89ab 	.word	0xcdef89ab
 c002fa4:	30000024 	.word	0x30000024
 c002fa8:	9abcdef0 	.word	0x9abcdef0
 c002fac:	12345678 	.word	0x12345678

0c002fb0 <__acle_se_Secure_Flash256KB>:
//    }
//}

__attribute__((cmse_nonsecure_entry))
void Secure_Flash256KB(FlashResult_t *result)
{
 c002fb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c002fb4:	b0b7      	sub	sp, #220	@ 0xdc
 c002fb6:	af02      	add	r7, sp, #8
 c002fb8:	61f8      	str	r0, [r7, #28]
 c002fba:	466b      	mov	r3, sp
 c002fbc:	461e      	mov	r6, r3
	// just run 10 pages
    if (!result) return;
 c002fbe:	69fb      	ldr	r3, [r7, #28]
 c002fc0:	2b00      	cmp	r3, #0
 c002fc2:	f000 8229 	beq.w	c003418 <__acle_se_Secure_Flash256KB+0x468>

    //   Pages 128-137 (Non-secure area,  Secure World )
    const uint32_t START_PAGE = 246;
 c002fc6:	23f6      	movs	r3, #246	@ 0xf6
 c002fc8:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    const uint32_t TOTAL_PAGES = 10;   //  10 pages = 20 KB
 c002fcc:	230a      	movs	r3, #10
 c002fce:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    const uint32_t PAGE_SIZE = 0x800;
 c002fd2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 c002fd6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    const uint32_t BANK2_BASE = 0x08040000;
 c002fda:	4bbb      	ldr	r3, [pc, #748]	@ (c0032c8 <__acle_se_Secure_Flash256KB+0x318>)
 c002fdc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    const uint32_t DW_PER_PAGE = 256;
 c002fe0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c002fe4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    const uint64_t FLASH_TEST_DATA_BASE = 0x1234567890ABCDEFULL;
 c002fe8:	a3b5      	add	r3, pc, #724	@ (adr r3, c0032c0 <__acle_se_Secure_Flash256KB+0x310>)
 c002fea:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002fee:	e9c7 2328 	strd	r2, r3, [r7, #160]	@ 0xa0

    HAL_StatusTypeDef status;
    uint32_t PageError = 0;
 c002ff2:	2300      	movs	r3, #0
 c002ff4:	65fb      	str	r3, [r7, #92]	@ 0x5c

    result->total_pages = TOTAL_PAGES;
 c002ff6:	69fa      	ldr	r2, [r7, #28]
 c002ff8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c002ffc:	6013      	str	r3, [r2, #0]
    result->success_pages = 0;
 c002ffe:	69fa      	ldr	r2, [r7, #28]
 c003000:	2300      	movs	r3, #0
 c003002:	6053      	str	r3, [r2, #4]
    result->failed_pages = 0;
 c003004:	69fa      	ldr	r2, [r7, #28]
 c003006:	2300      	movs	r3, #0
 c003008:	6093      	str	r3, [r2, #8]
    result->total_words = 0;
 c00300a:	69fa      	ldr	r2, [r7, #28]
 c00300c:	2300      	movs	r3, #0
 c00300e:	60d3      	str	r3, [r2, #12]
    result->success_words = 0;
 c003010:	69fa      	ldr	r2, [r7, #28]
 c003012:	2300      	movs	r3, #0
 c003014:	6113      	str	r3, [r2, #16]
    result->failed_words = 0;
 c003016:	69fa      	ldr	r2, [r7, #28]
 c003018:	2300      	movs	r3, #0
 c00301a:	6153      	str	r3, [r2, #20]

    // --- BB Attribute Management Variables ---
    FLASH_BBAttributesTypeDef flash_bb_attr = {0};
 c00301c:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 c003020:	2300      	movs	r3, #0
 c003022:	6013      	str	r3, [r2, #0]
 c003024:	6053      	str	r3, [r2, #4]
 c003026:	6093      	str	r3, [r2, #8]
 c003028:	60d3      	str	r3, [r2, #12]
 c00302a:	6113      	str	r3, [r2, #16]
 c00302c:	6153      	str	r3, [r2, #20]
    uint32_t saved_attr_array[4] = {0}; // Bank 2 has 128 pages, 128/32 = 4 uint32_t values
 c00302e:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 c003032:	2300      	movs	r3, #0
 c003034:	6013      	str	r3, [r2, #0]
 c003036:	6053      	str	r3, [r2, #4]
 c003038:	6093      	str	r3, [r2, #8]
 c00303a:	60d3      	str	r3, [r2, #12]
    uint8_t original_page_is_secure[TOTAL_PAGES];
 c00303c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003040:	3b01      	subs	r3, #1
 c003042:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 c003046:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c00304a:	2200      	movs	r2, #0
 c00304c:	461c      	mov	r4, r3
 c00304e:	4615      	mov	r5, r2
 c003050:	f04f 0200 	mov.w	r2, #0
 c003054:	f04f 0300 	mov.w	r3, #0
 c003058:	00eb      	lsls	r3, r5, #3
 c00305a:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 c00305e:	00e2      	lsls	r2, r4, #3
 c003060:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003064:	2200      	movs	r2, #0
 c003066:	469a      	mov	sl, r3
 c003068:	4693      	mov	fp, r2
 c00306a:	f04f 0200 	mov.w	r2, #0
 c00306e:	f04f 0300 	mov.w	r3, #0
 c003072:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 c003076:	ea43 735a 	orr.w	r3, r3, sl, lsr #29
 c00307a:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 c00307e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003082:	3307      	adds	r3, #7
 c003084:	08db      	lsrs	r3, r3, #3
 c003086:	00db      	lsls	r3, r3, #3
 c003088:	ebad 0d03 	sub.w	sp, sp, r3
 c00308c:	ab02      	add	r3, sp, #8
 c00308e:	3300      	adds	r3, #0
 c003090:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

    flash_bb_attr.Bank = FLASH_BANK_2;
 c003094:	2302      	movs	r3, #2
 c003096:	647b      	str	r3, [r7, #68]	@ 0x44
    flash_bb_attr.BBAttributesType = FLASH_BB_SEC;
 c003098:	2301      	movs	r3, #1
 c00309a:	64bb      	str	r3, [r7, #72]	@ 0x48
    HAL_FLASHEx_GetConfigBBAttributes(&flash_bb_attr);
 c00309c:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 c0030a0:	4618      	mov	r0, r3
 c0030a2:	f001 f94d 	bl	c004340 <HAL_FLASHEx_GetConfigBBAttributes>

    if (status != HAL_OK) {
 c0030a6:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c0030aa:	2b00      	cmp	r3, #0
 c0030ac:	f040 81b1 	bne.w	c003412 <__acle_se_Secure_Flash256KB+0x462>
            // Cannot proceed if we can't read attributes
        return;
    }

    memcpy(saved_attr_array, flash_bb_attr.BBAttributes_array, sizeof(saved_attr_array));
 c0030b0:	f107 0434 	add.w	r4, r7, #52	@ 0x34
 c0030b4:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 c0030b8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 c0030ba:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}


    // --- Step 2: Promote all target pages to SECURE ---
       for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c0030be:	2300      	movs	r3, #0
 c0030c0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 c0030c4:	e047      	b.n	c003156 <__acle_se_Secure_Flash256KB+0x1a6>
           uint32_t page = START_PAGE + i;
 c0030c6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 c0030ca:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c0030ce:	4413      	add	r3, r2
 c0030d0:	66bb      	str	r3, [r7, #104]	@ 0x68
           uint32_t attr_index = page / 32;
 c0030d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c0030d4:	095b      	lsrs	r3, r3, #5
 c0030d6:	667b      	str	r3, [r7, #100]	@ 0x64
           uint32_t attr_bit = page % 32;
 c0030d8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c0030da:	f003 031f 	and.w	r3, r3, #31
 c0030de:	663b      	str	r3, [r7, #96]	@ 0x60

           // Check if it's already secure
           if (flash_bb_attr.BBAttributes_array[attr_index] & (1U << attr_bit)) {
 c0030e0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c0030e2:	3302      	adds	r3, #2
 c0030e4:	009b      	lsls	r3, r3, #2
 c0030e6:	33b8      	adds	r3, #184	@ 0xb8
 c0030e8:	f107 0218 	add.w	r2, r7, #24
 c0030ec:	4413      	add	r3, r2
 c0030ee:	f853 2c8c 	ldr.w	r2, [r3, #-140]
 c0030f2:	2101      	movs	r1, #1
 c0030f4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 c0030f6:	fa01 f303 	lsl.w	r3, r1, r3
 c0030fa:	4013      	ands	r3, r2
 c0030fc:	2b00      	cmp	r3, #0
 c0030fe:	d007      	beq.n	c003110 <__acle_se_Secure_Flash256KB+0x160>
               original_page_is_secure[i] = 1;
 c003100:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 c003104:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c003108:	4413      	add	r3, r2
 c00310a:	2201      	movs	r2, #1
 c00310c:	701a      	strb	r2, [r3, #0]
 c00310e:	e01d      	b.n	c00314c <__acle_se_Secure_Flash256KB+0x19c>
           } else {
               original_page_is_secure[i] = 0;
 c003110:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 c003114:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c003118:	4413      	add	r3, r2
 c00311a:	2200      	movs	r2, #0
 c00311c:	701a      	strb	r2, [r3, #0]
               // Set bit to make page Secure
               flash_bb_attr.BBAttributes_array[attr_index] |= (1U << attr_bit);
 c00311e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c003120:	3302      	adds	r3, #2
 c003122:	009b      	lsls	r3, r3, #2
 c003124:	33b8      	adds	r3, #184	@ 0xb8
 c003126:	f107 0218 	add.w	r2, r7, #24
 c00312a:	4413      	add	r3, r2
 c00312c:	f853 2c8c 	ldr.w	r2, [r3, #-140]
 c003130:	2101      	movs	r1, #1
 c003132:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 c003134:	fa01 f303 	lsl.w	r3, r1, r3
 c003138:	431a      	orrs	r2, r3
 c00313a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c00313c:	3302      	adds	r3, #2
 c00313e:	009b      	lsls	r3, r3, #2
 c003140:	33b8      	adds	r3, #184	@ 0xb8
 c003142:	f107 0118 	add.w	r1, r7, #24
 c003146:	440b      	add	r3, r1
 c003148:	f843 2c8c 	str.w	r2, [r3, #-140]
       for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c00314c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c003150:	3301      	adds	r3, #1
 c003152:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 c003156:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 c00315a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c00315e:	429a      	cmp	r2, r3
 c003160:	d3b1      	bcc.n	c0030c6 <__acle_se_Secure_Flash256KB+0x116>
           }
       }

       // Apply the new (all-secure) attributes
          status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c003162:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 c003166:	4618      	mov	r0, r3
 c003168:	f001 f8a0 	bl	c0042ac <HAL_FLASHEx_ConfigBBAttributes>
 c00316c:	4603      	mov	r3, r0
 c00316e:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
          if (status != HAL_OK) {
 c003172:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c003176:	2b00      	cmp	r3, #0
 c003178:	f040 814d 	bne.w	c003416 <__acle_se_Secure_Flash256KB+0x466>
              // Failed to promote pages, cannot proceed
              return;
          }

    uint32_t start_time = HAL_GetTick();
 c00317c:	f000 fd9e 	bl	c003cbc <HAL_GetTick>
 c003180:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90

    status = HAL_FLASH_Unlock();
 c003184:	f000 ff10 	bl	c003fa8 <HAL_FLASH_Unlock>
 c003188:	4603      	mov	r3, r0
 c00318a:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
    if (status != HAL_OK) {
 c00318e:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c003192:	2b00      	cmp	r3, #0
 c003194:	d008      	beq.n	c0031a8 <__acle_se_Secure_Flash256KB+0x1f8>
        result->time_ms = HAL_GetTick() - start_time;
 c003196:	f000 fd91 	bl	c003cbc <HAL_GetTick>
 c00319a:	4602      	mov	r2, r0
 c00319c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 c0031a0:	1ad2      	subs	r2, r2, r3
 c0031a2:	69fb      	ldr	r3, [r7, #28]
 c0031a4:	619a      	str	r2, [r3, #24]
        return;
 c0031a6:	e137      	b.n	c003418 <__acle_se_Secure_Flash256KB+0x468>
    }

    //  Loop Pages 128-137
    for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c0031a8:	2300      	movs	r3, #0
 c0031aa:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 c0031ae:	e11d      	b.n	c0033ec <__acle_se_Secure_Flash256KB+0x43c>
        uint32_t page = START_PAGE + i;
 c0031b0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 c0031b4:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 c0031b8:	4413      	add	r3, r2
 c0031ba:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        uint32_t page_addr = BANK2_BASE + (page * PAGE_SIZE);
 c0031be:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c0031c2:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 c0031c6:	fb02 f303 	mul.w	r3, r2, r3
 c0031ca:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 c0031ce:	4413      	add	r3, r2
 c0031d0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        uint8_t page_ok = 1;
 c0031d4:	2301      	movs	r3, #1
 c0031d6:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7


        // Erase page

        //  Flash 
        while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {};
 c0031da:	bf00      	nop
 c0031dc:	4b3b      	ldr	r3, [pc, #236]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c0031de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0031e0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c0031e4:	2b00      	cmp	r3, #0
 c0031e6:	d1f9      	bne.n	c0031dc <__acle_se_Secure_Flash256KB+0x22c>

        //  Error Flag 
        if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS)) {
 c0031e8:	4b38      	ldr	r3, [pc, #224]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c0031ea:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 c0031ec:	4b38      	ldr	r3, [pc, #224]	@ (c0032d0 <__acle_se_Secure_Flash256KB+0x320>)
 c0031ee:	4013      	ands	r3, r2
 c0031f0:	2b00      	cmp	r3, #0
 c0031f2:	d00e      	beq.n	c003212 <__acle_se_Secure_Flash256KB+0x262>
            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 c0031f4:	4b35      	ldr	r3, [pc, #212]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c0031f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c0031f8:	4a34      	ldr	r2, [pc, #208]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c0031fa:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 c0031fe:	6313      	str	r3, [r2, #48]	@ 0x30
 c003200:	4b32      	ldr	r3, [pc, #200]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003202:	6a1b      	ldr	r3, [r3, #32]
 c003204:	4a31      	ldr	r2, [pc, #196]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003206:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 c00320a:	6213      	str	r3, [r2, #32]
 c00320c:	4b2f      	ldr	r3, [pc, #188]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c00320e:	22fa      	movs	r2, #250	@ 0xfa
 c003210:	625a      	str	r2, [r3, #36]	@ 0x24
        }


        FLASH_EraseInitTypeDef EraseInit = {0};
 c003212:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 c003216:	2200      	movs	r2, #0
 c003218:	601a      	str	r2, [r3, #0]
 c00321a:	605a      	str	r2, [r3, #4]
 c00321c:	609a      	str	r2, [r3, #8]
 c00321e:	60da      	str	r2, [r3, #12]
        EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 c003220:	2302      	movs	r3, #2
 c003222:	627b      	str	r3, [r7, #36]	@ 0x24
        EraseInit.Banks = FLASH_BANK_2;
 c003224:	2302      	movs	r3, #2
 c003226:	62bb      	str	r3, [r7, #40]	@ 0x28
        EraseInit.Page = page;
 c003228:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c00322c:	62fb      	str	r3, [r7, #44]	@ 0x2c
        EraseInit.NbPages = 1;
 c00322e:	2301      	movs	r3, #1
 c003230:	633b      	str	r3, [r7, #48]	@ 0x30

        status = HAL_FLASHEx_Erase(&EraseInit, &PageError);
 c003232:	f107 025c 	add.w	r2, r7, #92	@ 0x5c
 c003236:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 c00323a:	4611      	mov	r1, r2
 c00323c:	4618      	mov	r0, r3
 c00323e:	f000 ffbd 	bl	c0041bc <HAL_FLASHEx_Erase>
 c003242:	4603      	mov	r3, r0
 c003244:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
        if (status != HAL_OK || PageError != 0xFFFFFFFF) {
 c003248:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c00324c:	2b00      	cmp	r3, #0
 c00324e:	d103      	bne.n	c003258 <__acle_se_Secure_Flash256KB+0x2a8>
 c003250:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c003252:	f1b3 3fff 	cmp.w	r3, #4294967295
 c003256:	d024      	beq.n	c0032a2 <__acle_se_Secure_Flash256KB+0x2f2>

        	//  Error Flag 
        	    uint32_t flash_error = HAL_FLASH_GetError();
 c003258:	f000 ff06 	bl	c004068 <HAL_FLASH_GetError>
 c00325c:	66f8      	str	r0, [r7, #108]	@ 0x6c
        	    printf(" Erase FAIL on Page %lu! HAL_Status=%d, Flash_Error_Flags=0x%08lX, PageError=0x%08lX\r\n",
 c00325e:	f897 2097 	ldrb.w	r2, [r7, #151]	@ 0x97
 c003262:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c003264:	9300      	str	r3, [sp, #0]
 c003266:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c003268:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 c00326c:	4819      	ldr	r0, [pc, #100]	@ (c0032d4 <__acle_se_Secure_Flash256KB+0x324>)
 c00326e:	f002 fadb 	bl	c005828 <iprintf>
        	           page, status, flash_error, PageError);

        	    //  Flag 
        	    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 c003272:	4b16      	ldr	r3, [pc, #88]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003274:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c003276:	4a15      	ldr	r2, [pc, #84]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003278:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 c00327c:	6313      	str	r3, [r2, #48]	@ 0x30
 c00327e:	4b13      	ldr	r3, [pc, #76]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003280:	6a1b      	ldr	r3, [r3, #32]
 c003282:	4a12      	ldr	r2, [pc, #72]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c003284:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 c003288:	6213      	str	r3, [r2, #32]
 c00328a:	4b10      	ldr	r3, [pc, #64]	@ (c0032cc <__acle_se_Secure_Flash256KB+0x31c>)
 c00328c:	22fa      	movs	r2, #250	@ 0xfa
 c00328e:	625a      	str	r2, [r3, #36]	@ 0x24


            result->failed_pages++;
 c003290:	69fb      	ldr	r3, [r7, #28]
 c003292:	689b      	ldr	r3, [r3, #8]
 c003294:	1c5a      	adds	r2, r3, #1
 c003296:	69fb      	ldr	r3, [r7, #28]
 c003298:	609a      	str	r2, [r3, #8]
            page_ok = 0;
 c00329a:	2300      	movs	r3, #0
 c00329c:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
            continue;
 c0032a0:	e09f      	b.n	c0033e2 <__acle_se_Secure_Flash256KB+0x432>
        }

        InvalidateICache();
 c0032a2:	f7fe f9cb 	bl	c00163c <InvalidateICache>
  __ASM volatile ("dsb 0xF":::"memory");
 c0032a6:	f3bf 8f4f 	dsb	sy
}
 c0032aa:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0032ac:	f3bf 8f6f 	isb	sy
}
 c0032b0:	bf00      	nop
        __DSB();
        __ISB();

        // Program 256 doublewords (2 KB)
        for (uint32_t dw = 0; dw < DW_PER_PAGE; dw++) {
 c0032b2:	2300      	movs	r3, #0
 c0032b4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 c0032b8:	e07e      	b.n	c0033b8 <__acle_se_Secure_Flash256KB+0x408>
 c0032ba:	bf00      	nop
 c0032bc:	f3af 8000 	nop.w
 c0032c0:	90abcdef 	.word	0x90abcdef
 c0032c4:	12345678 	.word	0x12345678
 c0032c8:	08040000 	.word	0x08040000
 c0032cc:	50022000 	.word	0x50022000
 c0032d0:	f00020fa 	.word	0xf00020fa
 c0032d4:	0c006b08 	.word	0x0c006b08

            uint64_t test_value = FLASH_TEST_DATA_BASE + page + dw;
 c0032d8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c0032dc:	2200      	movs	r2, #0
 c0032de:	613b      	str	r3, [r7, #16]
 c0032e0:	617a      	str	r2, [r7, #20]
 c0032e2:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
 c0032e6:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
 c0032ea:	4621      	mov	r1, r4
 c0032ec:	eb11 0802 	adds.w	r8, r1, r2
 c0032f0:	4629      	mov	r1, r5
 c0032f2:	eb41 0903 	adc.w	r9, r1, r3
 c0032f6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c0032fa:	2200      	movs	r2, #0
 c0032fc:	60bb      	str	r3, [r7, #8]
 c0032fe:	60fa      	str	r2, [r7, #12]
 c003300:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 c003304:	460b      	mov	r3, r1
 c003306:	eb18 0303 	adds.w	r3, r8, r3
 c00330a:	603b      	str	r3, [r7, #0]
 c00330c:	4613      	mov	r3, r2
 c00330e:	eb49 0303 	adc.w	r3, r9, r3
 c003312:	607b      	str	r3, [r7, #4]
 c003314:	e9d7 3400 	ldrd	r3, r4, [r7]
 c003318:	e9c7 3420 	strd	r3, r4, [r7, #128]	@ 0x80
            uint32_t target_addr = page_addr + (dw * 8);
 c00331c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c003320:	00db      	lsls	r3, r3, #3
 c003322:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 c003326:	4413      	add	r3, r2
 c003328:	67fb      	str	r3, [r7, #124]	@ 0x7c

            result->total_words++;
 c00332a:	69fb      	ldr	r3, [r7, #28]
 c00332c:	68db      	ldr	r3, [r3, #12]
 c00332e:	1c5a      	adds	r2, r3, #1
 c003330:	69fb      	ldr	r3, [r7, #28]
 c003332:	60da      	str	r2, [r3, #12]

            status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 c003334:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 c003338:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 c00333a:	2001      	movs	r0, #1
 c00333c:	f000 fdea 	bl	c003f14 <HAL_FLASH_Program>
 c003340:	4603      	mov	r3, r0
 c003342:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
                                       target_addr,
                                       test_value);

            if (status != HAL_OK) {
 c003346:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c00334a:	2b00      	cmp	r3, #0
 c00334c:	d008      	beq.n	c003360 <__acle_se_Secure_Flash256KB+0x3b0>
                result->failed_words++;
 c00334e:	69fb      	ldr	r3, [r7, #28]
 c003350:	695b      	ldr	r3, [r3, #20]
 c003352:	1c5a      	adds	r2, r3, #1
 c003354:	69fb      	ldr	r3, [r7, #28]
 c003356:	615a      	str	r2, [r3, #20]
                page_ok = 0;
 c003358:	2300      	movs	r3, #0
 c00335a:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                break;
 c00335e:	e031      	b.n	c0033c4 <__acle_se_Secure_Flash256KB+0x414>
            }


            InvalidateICache();
 c003360:	f7fe f96c 	bl	c00163c <InvalidateICache>
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 c003364:	f3bf 8f5f 	dmb	sy
}
 c003368:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
 c00336a:	f3bf 8f4f 	dsb	sy
}
 c00336e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c003370:	f3bf 8f6f 	isb	sy
}
 c003374:	bf00      	nop
            __DMB();
            __DSB();
            __ISB();

            // Verify
            uint64_t verify_value = *(volatile uint64_t*)target_addr;
 c003376:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 c003378:	e9d3 2300 	ldrd	r2, r3, [r3]
 c00337c:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70

            if (verify_value == test_value) {
 c003380:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 c003384:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 c003388:	4299      	cmp	r1, r3
 c00338a:	bf08      	it	eq
 c00338c:	4290      	cmpeq	r0, r2
 c00338e:	d105      	bne.n	c00339c <__acle_se_Secure_Flash256KB+0x3ec>
                result->success_words++;
 c003390:	69fb      	ldr	r3, [r7, #28]
 c003392:	691b      	ldr	r3, [r3, #16]
 c003394:	1c5a      	adds	r2, r3, #1
 c003396:	69fb      	ldr	r3, [r7, #28]
 c003398:	611a      	str	r2, [r3, #16]
 c00339a:	e008      	b.n	c0033ae <__acle_se_Secure_Flash256KB+0x3fe>
            } else {
                result->failed_words++;
 c00339c:	69fb      	ldr	r3, [r7, #28]
 c00339e:	695b      	ldr	r3, [r3, #20]
 c0033a0:	1c5a      	adds	r2, r3, #1
 c0033a2:	69fb      	ldr	r3, [r7, #28]
 c0033a4:	615a      	str	r2, [r3, #20]
                page_ok = 0;
 c0033a6:	2300      	movs	r3, #0
 c0033a8:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                break;
 c0033ac:	e00a      	b.n	c0033c4 <__acle_se_Secure_Flash256KB+0x414>
        for (uint32_t dw = 0; dw < DW_PER_PAGE; dw++) {
 c0033ae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c0033b2:	3301      	adds	r3, #1
 c0033b4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 c0033b8:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 c0033bc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 c0033c0:	429a      	cmp	r2, r3
 c0033c2:	d389      	bcc.n	c0032d8 <__acle_se_Secure_Flash256KB+0x328>
            }
        }

        if (page_ok) {
 c0033c4:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 c0033c8:	2b00      	cmp	r3, #0
 c0033ca:	d005      	beq.n	c0033d8 <__acle_se_Secure_Flash256KB+0x428>
            result->success_pages++;
 c0033cc:	69fb      	ldr	r3, [r7, #28]
 c0033ce:	685b      	ldr	r3, [r3, #4]
 c0033d0:	1c5a      	adds	r2, r3, #1
 c0033d2:	69fb      	ldr	r3, [r7, #28]
 c0033d4:	605a      	str	r2, [r3, #4]
 c0033d6:	e004      	b.n	c0033e2 <__acle_se_Secure_Flash256KB+0x432>
        } else {
            result->failed_pages++;
 c0033d8:	69fb      	ldr	r3, [r7, #28]
 c0033da:	689b      	ldr	r3, [r3, #8]
 c0033dc:	1c5a      	adds	r2, r3, #1
 c0033de:	69fb      	ldr	r3, [r7, #28]
 c0033e0:	609a      	str	r2, [r3, #8]
    for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c0033e2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 c0033e6:	3301      	adds	r3, #1
 c0033e8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 c0033ec:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 c0033f0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c0033f4:	429a      	cmp	r2, r3
 c0033f6:	f4ff aedb 	bcc.w	c0031b0 <__acle_se_Secure_Flash256KB+0x200>
        }
    }

    HAL_FLASH_Lock();
 c0033fa:	f000 fe0b 	bl	c004014 <HAL_FLASH_Lock>

    result->time_ms = HAL_GetTick() - start_time;
 c0033fe:	f000 fc5d 	bl	c003cbc <HAL_GetTick>
 c003402:	4602      	mov	r2, r0
 c003404:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 c003408:	1ad2      	subs	r2, r2, r3
 c00340a:	69fb      	ldr	r3, [r7, #28]
 c00340c:	619a      	str	r2, [r3, #24]
 c00340e:	46b5      	mov	sp, r6
 c003410:	e003      	b.n	c00341a <__acle_se_Secure_Flash256KB+0x46a>
        return;
 c003412:	bf00      	nop
 c003414:	e000      	b.n	c003418 <__acle_se_Secure_Flash256KB+0x468>
              return;
 c003416:	bf00      	nop
    if (!result) return;
 c003418:	46b5      	mov	sp, r6
}
 c00341a:	37d4      	adds	r7, #212	@ 0xd4
 c00341c:	46bd      	mov	sp, r7
 c00341e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c003422:	4670      	mov	r0, lr
 c003424:	4671      	mov	r1, lr
 c003426:	4672      	mov	r2, lr
 c003428:	4673      	mov	r3, lr
 c00342a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c00342e:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c003432:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003436:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00343a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00343e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c003442:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003446:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00344a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00344e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003452:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003456:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00345a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00345e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003462:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003466:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00346a:	f38e 8c00 	msr	CPSR_fs, lr
 c00346e:	b410      	push	{r4}
 c003470:	eef1 ca10 	vmrs	ip, fpscr
 c003474:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c003478:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00347c:	ea0c 0c04 	and.w	ip, ip, r4
 c003480:	eee1 ca10 	vmsr	fpscr, ip
 c003484:	bc10      	pop	{r4}
 c003486:	46f4      	mov	ip, lr
 c003488:	4774      	bxns	lr
 c00348a:	bf00      	nop

0c00348c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 c00348c:	b580      	push	{r7, lr}
 c00348e:	b084      	sub	sp, #16
 c003490:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c003492:	4b19      	ldr	r3, [pc, #100]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c003494:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c003496:	4a18      	ldr	r2, [pc, #96]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c003498:	f043 0301 	orr.w	r3, r3, #1
 c00349c:	6613      	str	r3, [r2, #96]	@ 0x60
 c00349e:	4b16      	ldr	r3, [pc, #88]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034a0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c0034a2:	f003 0301 	and.w	r3, r3, #1
 c0034a6:	60fb      	str	r3, [r7, #12]
 c0034a8:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_PWR_CLK_ENABLE();
 c0034aa:	4b13      	ldr	r3, [pc, #76]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034ac:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 c0034ae:	4a12      	ldr	r2, [pc, #72]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034b0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 c0034b4:	6593      	str	r3, [r2, #88]	@ 0x58
 c0034b6:	4b10      	ldr	r3, [pc, #64]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 c0034ba:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 c0034be:	60bb      	str	r3, [r7, #8]
 c0034c0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GTZC_CLK_ENABLE();
 c0034c2:	4b0d      	ldr	r3, [pc, #52]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034c4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 c0034c6:	4a0c      	ldr	r2, [pc, #48]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034c8:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 c0034cc:	6493      	str	r3, [r2, #72]	@ 0x48
 c0034ce:	4b0a      	ldr	r3, [pc, #40]	@ (c0034f8 <HAL_MspInit+0x6c>)
 c0034d0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 c0034d2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c0034d6:	607b      	str	r3, [r7, #4]
 c0034d8:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* GTZC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(GTZC_IRQn, 0, 0);
 c0034da:	2200      	movs	r2, #0
 c0034dc:	2100      	movs	r1, #0
 c0034de:	2008      	movs	r0, #8
 c0034e0:	f000 fce3 	bl	c003eaa <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(GTZC_IRQn);
 c0034e4:	2008      	movs	r0, #8
 c0034e6:	f000 fcfa 	bl	c003ede <HAL_NVIC_EnableIRQ>

    /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();
 c0034ea:	f001 fba1 	bl	c004c30 <HAL_PWREx_DisableUCPDDeadBattery>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 c0034ee:	bf00      	nop
 c0034f0:	3710      	adds	r7, #16
 c0034f2:	46bd      	mov	sp, r7
 c0034f4:	bd80      	pop	{r7, pc}
 c0034f6:	bf00      	nop
 c0034f8:	50021000 	.word	0x50021000

0c0034fc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 c0034fc:	b480      	push	{r7}
 c0034fe:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 c003500:	bf00      	nop
 c003502:	46bd      	mov	sp, r7
 c003504:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003508:	4770      	bx	lr

0c00350a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 c00350a:	b480      	push	{r7}
 c00350c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 c00350e:	bf00      	nop
 c003510:	e7fd      	b.n	c00350e <HardFault_Handler+0x4>

0c003512 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 c003512:	b480      	push	{r7}
 c003514:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 c003516:	bf00      	nop
 c003518:	e7fd      	b.n	c003516 <MemManage_Handler+0x4>

0c00351a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 c00351a:	b480      	push	{r7}
 c00351c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 c00351e:	bf00      	nop
 c003520:	e7fd      	b.n	c00351e <BusFault_Handler+0x4>

0c003522 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 c003522:	b480      	push	{r7}
 c003524:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 c003526:	bf00      	nop
 c003528:	e7fd      	b.n	c003526 <UsageFault_Handler+0x4>
	...

0c00352c <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
 c00352c:	b590      	push	{r4, r7, lr}
 c00352e:	b083      	sub	sp, #12
 c003530:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */
  funcptr_NS callback_NS; /* non-secure callback function pointer */

  if(pSecureFaultCallback != (funcptr_NS)NULL)
 c003532:	4b1c      	ldr	r3, [pc, #112]	@ (c0035a4 <SecureFault_Handler+0x78>)
 c003534:	681b      	ldr	r3, [r3, #0]
 c003536:	2b00      	cmp	r3, #0
 c003538:	d02f      	beq.n	c00359a <SecureFault_Handler+0x6e>
  {
   /* return function pointer with cleared LSB */
   callback_NS = (funcptr_NS)cmse_nsfptr_create(pSecureFaultCallback);
 c00353a:	4b1a      	ldr	r3, [pc, #104]	@ (c0035a4 <SecureFault_Handler+0x78>)
 c00353c:	681b      	ldr	r3, [r3, #0]
 c00353e:	f023 0301 	bic.w	r3, r3, #1
 c003542:	607b      	str	r3, [r7, #4]

   callback_NS();
 c003544:	687b      	ldr	r3, [r7, #4]
 c003546:	461c      	mov	r4, r3
 c003548:	0864      	lsrs	r4, r4, #1
 c00354a:	0064      	lsls	r4, r4, #1
 c00354c:	4620      	mov	r0, r4
 c00354e:	4621      	mov	r1, r4
 c003550:	4622      	mov	r2, r4
 c003552:	4623      	mov	r3, r4
 c003554:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c003558:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00355c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003560:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c003564:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c003568:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00356c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003570:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c003574:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003578:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00357c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003580:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c003584:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003588:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00358c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003590:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c003594:	f7fc fe58 	bl	c000248 <__gnu_cmse_nonsecure_call>
   return ;
 c003598:	e000      	b.n	c00359c <SecureFault_Handler+0x70>
  }
  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
 c00359a:	e7fe      	b.n	c00359a <SecureFault_Handler+0x6e>
  {
    /* USER CODE BEGIN W1_SecureFault_IRQn 0 */
    /* USER CODE END W1_SecureFault_IRQn 0 */
  }
}
 c00359c:	370c      	adds	r7, #12
 c00359e:	46bd      	mov	sp, r7
 c0035a0:	bd90      	pop	{r4, r7, pc}
 c0035a2:	bf00      	nop
 c0035a4:	300000bc 	.word	0x300000bc

0c0035a8 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 c0035a8:	b480      	push	{r7}
 c0035aa:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 c0035ac:	bf00      	nop
 c0035ae:	46bd      	mov	sp, r7
 c0035b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0035b4:	4770      	bx	lr

0c0035b6 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 c0035b6:	b480      	push	{r7}
 c0035b8:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 c0035ba:	bf00      	nop
 c0035bc:	46bd      	mov	sp, r7
 c0035be:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0035c2:	4770      	bx	lr

0c0035c4 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 c0035c4:	b480      	push	{r7}
 c0035c6:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 c0035c8:	bf00      	nop
 c0035ca:	46bd      	mov	sp, r7
 c0035cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0035d0:	4770      	bx	lr

0c0035d2 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 c0035d2:	b580      	push	{r7, lr}
 c0035d4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 c0035d6:	f000 fb5d 	bl	c003c94 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 c0035da:	bf00      	nop
 c0035dc:	bd80      	pop	{r7, pc}
	...

0c0035e0 <GTZC_IRQHandler>:

/**
  * @brief This function handles Global TrustZone controller global interrupt.
  */
void GTZC_IRQHandler(void)
{
 c0035e0:	b590      	push	{r4, r7, lr}
 c0035e2:	b083      	sub	sp, #12
 c0035e4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GTZC_IRQn 0 */
  funcptr_NS callback_NS; /* non-secure callback function pointer */
  /* USER CODE END GTZC_IRQn 0 */
  HAL_GTZC_IRQHandler();
 c0035e6:	f001 f9db 	bl	c0049a0 <HAL_GTZC_IRQHandler>
  /* USER CODE BEGIN GTZC_IRQn 1 */
  if(pSecureErrorCallback != (funcptr_NS)NULL)
 c0035ea:	4b1c      	ldr	r3, [pc, #112]	@ (c00365c <GTZC_IRQHandler+0x7c>)
 c0035ec:	681b      	ldr	r3, [r3, #0]
 c0035ee:	2b00      	cmp	r3, #0
 c0035f0:	d02f      	beq.n	c003652 <GTZC_IRQHandler+0x72>
  {
   /* return function pointer with cleared LSB */
   callback_NS = (funcptr_NS)cmse_nsfptr_create(pSecureErrorCallback);
 c0035f2:	4b1a      	ldr	r3, [pc, #104]	@ (c00365c <GTZC_IRQHandler+0x7c>)
 c0035f4:	681b      	ldr	r3, [r3, #0]
 c0035f6:	f023 0301 	bic.w	r3, r3, #1
 c0035fa:	607b      	str	r3, [r7, #4]

   callback_NS();
 c0035fc:	687b      	ldr	r3, [r7, #4]
 c0035fe:	461c      	mov	r4, r3
 c003600:	0864      	lsrs	r4, r4, #1
 c003602:	0064      	lsls	r4, r4, #1
 c003604:	4620      	mov	r0, r4
 c003606:	4621      	mov	r1, r4
 c003608:	4622      	mov	r2, r4
 c00360a:	4623      	mov	r3, r4
 c00360c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c003610:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c003614:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003618:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00361c:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c003620:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c003624:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003628:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00362c:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003630:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003634:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003638:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00363c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003640:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003644:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003648:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00364c:	f7fc fdfc 	bl	c000248 <__gnu_cmse_nonsecure_call>
  {
    /* Something went wrong in test case */
    while(1);
  }
  /* USER CODE END GTZC_IRQn 1 */
}
 c003650:	e000      	b.n	c003654 <GTZC_IRQHandler+0x74>
    while(1);
 c003652:	e7fe      	b.n	c003652 <GTZC_IRQHandler+0x72>
}
 c003654:	370c      	adds	r7, #12
 c003656:	46bd      	mov	sp, r7
 c003658:	bd90      	pop	{r4, r7, pc}
 c00365a:	bf00      	nop
 c00365c:	300000c0 	.word	0x300000c0

0c003660 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 c003660:	b480      	push	{r7}
 c003662:	af00      	add	r7, sp, #0
  return 1;
 c003664:	2301      	movs	r3, #1
}
 c003666:	4618      	mov	r0, r3
 c003668:	46bd      	mov	sp, r7
 c00366a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00366e:	4770      	bx	lr

0c003670 <_kill>:

int _kill(int pid, int sig)
{
 c003670:	b580      	push	{r7, lr}
 c003672:	b082      	sub	sp, #8
 c003674:	af00      	add	r7, sp, #0
 c003676:	6078      	str	r0, [r7, #4]
 c003678:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 c00367a:	f002 fa8f 	bl	c005b9c <__errno>
 c00367e:	4603      	mov	r3, r0
 c003680:	2216      	movs	r2, #22
 c003682:	601a      	str	r2, [r3, #0]
  return -1;
 c003684:	f04f 33ff 	mov.w	r3, #4294967295
}
 c003688:	4618      	mov	r0, r3
 c00368a:	3708      	adds	r7, #8
 c00368c:	46bd      	mov	sp, r7
 c00368e:	bd80      	pop	{r7, pc}

0c003690 <_exit>:

void _exit (int status)
{
 c003690:	b580      	push	{r7, lr}
 c003692:	b082      	sub	sp, #8
 c003694:	af00      	add	r7, sp, #0
 c003696:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 c003698:	f04f 31ff 	mov.w	r1, #4294967295
 c00369c:	6878      	ldr	r0, [r7, #4]
 c00369e:	f7ff ffe7 	bl	c003670 <_kill>
  while (1) {}    /* Make sure we hang here */
 c0036a2:	bf00      	nop
 c0036a4:	e7fd      	b.n	c0036a2 <_exit+0x12>

0c0036a6 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 c0036a6:	b580      	push	{r7, lr}
 c0036a8:	b086      	sub	sp, #24
 c0036aa:	af00      	add	r7, sp, #0
 c0036ac:	60f8      	str	r0, [r7, #12]
 c0036ae:	60b9      	str	r1, [r7, #8]
 c0036b0:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c0036b2:	2300      	movs	r3, #0
 c0036b4:	617b      	str	r3, [r7, #20]
 c0036b6:	e00a      	b.n	c0036ce <_read+0x28>
  {
    *ptr++ = __io_getchar();
 c0036b8:	f3af 8000 	nop.w
 c0036bc:	4601      	mov	r1, r0
 c0036be:	68bb      	ldr	r3, [r7, #8]
 c0036c0:	1c5a      	adds	r2, r3, #1
 c0036c2:	60ba      	str	r2, [r7, #8]
 c0036c4:	b2ca      	uxtb	r2, r1
 c0036c6:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c0036c8:	697b      	ldr	r3, [r7, #20]
 c0036ca:	3301      	adds	r3, #1
 c0036cc:	617b      	str	r3, [r7, #20]
 c0036ce:	697a      	ldr	r2, [r7, #20]
 c0036d0:	687b      	ldr	r3, [r7, #4]
 c0036d2:	429a      	cmp	r2, r3
 c0036d4:	dbf0      	blt.n	c0036b8 <_read+0x12>
  }

  return len;
 c0036d6:	687b      	ldr	r3, [r7, #4]
}
 c0036d8:	4618      	mov	r0, r3
 c0036da:	3718      	adds	r7, #24
 c0036dc:	46bd      	mov	sp, r7
 c0036de:	bd80      	pop	{r7, pc}

0c0036e0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 c0036e0:	b580      	push	{r7, lr}
 c0036e2:	b086      	sub	sp, #24
 c0036e4:	af00      	add	r7, sp, #0
 c0036e6:	60f8      	str	r0, [r7, #12]
 c0036e8:	60b9      	str	r1, [r7, #8]
 c0036ea:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c0036ec:	2300      	movs	r3, #0
 c0036ee:	617b      	str	r3, [r7, #20]
 c0036f0:	e009      	b.n	c003706 <_write+0x26>
  {
    __io_putchar(*ptr++);
 c0036f2:	68bb      	ldr	r3, [r7, #8]
 c0036f4:	1c5a      	adds	r2, r3, #1
 c0036f6:	60ba      	str	r2, [r7, #8]
 c0036f8:	781b      	ldrb	r3, [r3, #0]
 c0036fa:	4618      	mov	r0, r3
 c0036fc:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c003700:	697b      	ldr	r3, [r7, #20]
 c003702:	3301      	adds	r3, #1
 c003704:	617b      	str	r3, [r7, #20]
 c003706:	697a      	ldr	r2, [r7, #20]
 c003708:	687b      	ldr	r3, [r7, #4]
 c00370a:	429a      	cmp	r2, r3
 c00370c:	dbf1      	blt.n	c0036f2 <_write+0x12>
  }
  return len;
 c00370e:	687b      	ldr	r3, [r7, #4]
}
 c003710:	4618      	mov	r0, r3
 c003712:	3718      	adds	r7, #24
 c003714:	46bd      	mov	sp, r7
 c003716:	bd80      	pop	{r7, pc}

0c003718 <_close>:

int _close(int file)
{
 c003718:	b480      	push	{r7}
 c00371a:	b083      	sub	sp, #12
 c00371c:	af00      	add	r7, sp, #0
 c00371e:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 c003720:	f04f 33ff 	mov.w	r3, #4294967295
}
 c003724:	4618      	mov	r0, r3
 c003726:	370c      	adds	r7, #12
 c003728:	46bd      	mov	sp, r7
 c00372a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00372e:	4770      	bx	lr

0c003730 <_fstat>:


int _fstat(int file, struct stat *st)
{
 c003730:	b480      	push	{r7}
 c003732:	b083      	sub	sp, #12
 c003734:	af00      	add	r7, sp, #0
 c003736:	6078      	str	r0, [r7, #4]
 c003738:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 c00373a:	683b      	ldr	r3, [r7, #0]
 c00373c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 c003740:	605a      	str	r2, [r3, #4]
  return 0;
 c003742:	2300      	movs	r3, #0
}
 c003744:	4618      	mov	r0, r3
 c003746:	370c      	adds	r7, #12
 c003748:	46bd      	mov	sp, r7
 c00374a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00374e:	4770      	bx	lr

0c003750 <_isatty>:

int _isatty(int file)
{
 c003750:	b480      	push	{r7}
 c003752:	b083      	sub	sp, #12
 c003754:	af00      	add	r7, sp, #0
 c003756:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 c003758:	2301      	movs	r3, #1
}
 c00375a:	4618      	mov	r0, r3
 c00375c:	370c      	adds	r7, #12
 c00375e:	46bd      	mov	sp, r7
 c003760:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003764:	4770      	bx	lr

0c003766 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 c003766:	b480      	push	{r7}
 c003768:	b085      	sub	sp, #20
 c00376a:	af00      	add	r7, sp, #0
 c00376c:	60f8      	str	r0, [r7, #12]
 c00376e:	60b9      	str	r1, [r7, #8]
 c003770:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 c003772:	2300      	movs	r3, #0
}
 c003774:	4618      	mov	r0, r3
 c003776:	3714      	adds	r7, #20
 c003778:	46bd      	mov	sp, r7
 c00377a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00377e:	4770      	bx	lr

0c003780 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 c003780:	b580      	push	{r7, lr}
 c003782:	b086      	sub	sp, #24
 c003784:	af00      	add	r7, sp, #0
 c003786:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 c003788:	4a14      	ldr	r2, [pc, #80]	@ (c0037dc <_sbrk+0x5c>)
 c00378a:	4b15      	ldr	r3, [pc, #84]	@ (c0037e0 <_sbrk+0x60>)
 c00378c:	1ad3      	subs	r3, r2, r3
 c00378e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 c003790:	697b      	ldr	r3, [r7, #20]
 c003792:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 c003794:	4b13      	ldr	r3, [pc, #76]	@ (c0037e4 <_sbrk+0x64>)
 c003796:	681b      	ldr	r3, [r3, #0]
 c003798:	2b00      	cmp	r3, #0
 c00379a:	d102      	bne.n	c0037a2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 c00379c:	4b11      	ldr	r3, [pc, #68]	@ (c0037e4 <_sbrk+0x64>)
 c00379e:	4a12      	ldr	r2, [pc, #72]	@ (c0037e8 <_sbrk+0x68>)
 c0037a0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 c0037a2:	4b10      	ldr	r3, [pc, #64]	@ (c0037e4 <_sbrk+0x64>)
 c0037a4:	681a      	ldr	r2, [r3, #0]
 c0037a6:	687b      	ldr	r3, [r7, #4]
 c0037a8:	4413      	add	r3, r2
 c0037aa:	693a      	ldr	r2, [r7, #16]
 c0037ac:	429a      	cmp	r2, r3
 c0037ae:	d207      	bcs.n	c0037c0 <_sbrk+0x40>
  {
    errno = ENOMEM;
 c0037b0:	f002 f9f4 	bl	c005b9c <__errno>
 c0037b4:	4603      	mov	r3, r0
 c0037b6:	220c      	movs	r2, #12
 c0037b8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 c0037ba:	f04f 33ff 	mov.w	r3, #4294967295
 c0037be:	e009      	b.n	c0037d4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 c0037c0:	4b08      	ldr	r3, [pc, #32]	@ (c0037e4 <_sbrk+0x64>)
 c0037c2:	681b      	ldr	r3, [r3, #0]
 c0037c4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 c0037c6:	4b07      	ldr	r3, [pc, #28]	@ (c0037e4 <_sbrk+0x64>)
 c0037c8:	681a      	ldr	r2, [r3, #0]
 c0037ca:	687b      	ldr	r3, [r7, #4]
 c0037cc:	4413      	add	r3, r2
 c0037ce:	4a05      	ldr	r2, [pc, #20]	@ (c0037e4 <_sbrk+0x64>)
 c0037d0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 c0037d2:	68fb      	ldr	r3, [r7, #12]
}
 c0037d4:	4618      	mov	r0, r3
 c0037d6:	3718      	adds	r7, #24
 c0037d8:	46bd      	mov	sp, r7
 c0037da:	bd80      	pop	{r7, pc}
 c0037dc:	30018000 	.word	0x30018000
 c0037e0:	00000400 	.word	0x00000400
 c0037e4:	300004b8 	.word	0x300004b8
 c0037e8:	30002f28 	.word	0x30002f28

0c0037ec <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP error code
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 c0037ec:	b580      	push	{r7, lr}
 c0037ee:	b08a      	sub	sp, #40	@ 0x28
 c0037f0:	af00      	add	r7, sp, #0
 c0037f2:	4603      	mov	r3, r0
 c0037f4:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LED1)
 c0037f6:	79fb      	ldrb	r3, [r7, #7]
 c0037f8:	2b00      	cmp	r3, #0
 c0037fa:	d10c      	bne.n	c003816 <BSP_LED_Init+0x2a>
  {
    LED1_GPIO_CLK_ENABLE();
 c0037fc:	4b27      	ldr	r3, [pc, #156]	@ (c00389c <BSP_LED_Init+0xb0>)
 c0037fe:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c003800:	4a26      	ldr	r2, [pc, #152]	@ (c00389c <BSP_LED_Init+0xb0>)
 c003802:	f043 0304 	orr.w	r3, r3, #4
 c003806:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c003808:	4b24      	ldr	r3, [pc, #144]	@ (c00389c <BSP_LED_Init+0xb0>)
 c00380a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00380c:	f003 0304 	and.w	r3, r3, #4
 c003810:	613b      	str	r3, [r7, #16]
 c003812:	693b      	ldr	r3, [r7, #16]
 c003814:	e01b      	b.n	c00384e <BSP_LED_Init+0x62>
  }
  else if (Led == LED2)
 c003816:	79fb      	ldrb	r3, [r7, #7]
 c003818:	2b01      	cmp	r3, #1
 c00381a:	d10c      	bne.n	c003836 <BSP_LED_Init+0x4a>
  {
    LED2_GPIO_CLK_ENABLE();
 c00381c:	4b1f      	ldr	r3, [pc, #124]	@ (c00389c <BSP_LED_Init+0xb0>)
 c00381e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c003820:	4a1e      	ldr	r2, [pc, #120]	@ (c00389c <BSP_LED_Init+0xb0>)
 c003822:	f043 0302 	orr.w	r3, r3, #2
 c003826:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c003828:	4b1c      	ldr	r3, [pc, #112]	@ (c00389c <BSP_LED_Init+0xb0>)
 c00382a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00382c:	f003 0302 	and.w	r3, r3, #2
 c003830:	60fb      	str	r3, [r7, #12]
 c003832:	68fb      	ldr	r3, [r7, #12]
 c003834:	e00b      	b.n	c00384e <BSP_LED_Init+0x62>
  }
  else /* Led = LED3 */
  {
    LED3_GPIO_CLK_ENABLE();
 c003836:	4b19      	ldr	r3, [pc, #100]	@ (c00389c <BSP_LED_Init+0xb0>)
 c003838:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00383a:	4a18      	ldr	r2, [pc, #96]	@ (c00389c <BSP_LED_Init+0xb0>)
 c00383c:	f043 0301 	orr.w	r3, r3, #1
 c003840:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c003842:	4b16      	ldr	r3, [pc, #88]	@ (c00389c <BSP_LED_Init+0xb0>)
 c003844:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c003846:	f003 0301 	and.w	r3, r3, #1
 c00384a:	60bb      	str	r3, [r7, #8]
 c00384c:	68bb      	ldr	r3, [r7, #8]
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
 c00384e:	79fb      	ldrb	r3, [r7, #7]
 c003850:	4a13      	ldr	r2, [pc, #76]	@ (c0038a0 <BSP_LED_Init+0xb4>)
 c003852:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 c003856:	617b      	str	r3, [r7, #20]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 c003858:	2301      	movs	r3, #1
 c00385a:	61bb      	str	r3, [r7, #24]
  GPIO_Init.Pull  = GPIO_PULLUP;
 c00385c:	2301      	movs	r3, #1
 c00385e:	61fb      	str	r3, [r7, #28]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 c003860:	2303      	movs	r3, #3
 c003862:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 c003864:	79fb      	ldrb	r3, [r7, #7]
 c003866:	4a0f      	ldr	r2, [pc, #60]	@ (c0038a4 <BSP_LED_Init+0xb8>)
 c003868:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c00386c:	f107 0214 	add.w	r2, r7, #20
 c003870:	4611      	mov	r1, r2
 c003872:	4618      	mov	r0, r3
 c003874:	f000 fe3e 	bl	c0044f4 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 c003878:	79fb      	ldrb	r3, [r7, #7]
 c00387a:	4a0a      	ldr	r2, [pc, #40]	@ (c0038a4 <BSP_LED_Init+0xb8>)
 c00387c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c003880:	79fb      	ldrb	r3, [r7, #7]
 c003882:	4a07      	ldr	r2, [pc, #28]	@ (c0038a0 <BSP_LED_Init+0xb4>)
 c003884:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 c003888:	2200      	movs	r2, #0
 c00388a:	4619      	mov	r1, r3
 c00388c:	f000 ffb2 	bl	c0047f4 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 c003890:	2300      	movs	r3, #0
}
 c003892:	4618      	mov	r0, r3
 c003894:	3728      	adds	r7, #40	@ 0x28
 c003896:	46bd      	mov	sp, r7
 c003898:	bd80      	pop	{r7, pc}
 c00389a:	bf00      	nop
 c00389c:	50021000 	.word	0x50021000
 c0038a0:	30000004 	.word	0x30000004
 c0038a4:	3000000c 	.word	0x3000000c

0c0038a8 <BSP_LED_Toggle>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP error code
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 c0038a8:	b580      	push	{r7, lr}
 c0038aa:	b082      	sub	sp, #8
 c0038ac:	af00      	add	r7, sp, #0
 c0038ae:	4603      	mov	r3, r0
 c0038b0:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 c0038b2:	79fb      	ldrb	r3, [r7, #7]
 c0038b4:	4a07      	ldr	r2, [pc, #28]	@ (c0038d4 <BSP_LED_Toggle+0x2c>)
 c0038b6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 c0038ba:	79fb      	ldrb	r3, [r7, #7]
 c0038bc:	4906      	ldr	r1, [pc, #24]	@ (c0038d8 <BSP_LED_Toggle+0x30>)
 c0038be:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 c0038c2:	4619      	mov	r1, r3
 c0038c4:	4610      	mov	r0, r2
 c0038c6:	f000 ffad 	bl	c004824 <HAL_GPIO_TogglePin>
  return BSP_ERROR_NONE;
 c0038ca:	2300      	movs	r3, #0
}
 c0038cc:	4618      	mov	r0, r3
 c0038ce:	3708      	adds	r7, #8
 c0038d0:	46bd      	mov	sp, r7
 c0038d2:	bd80      	pop	{r7, pc}
 c0038d4:	3000000c 	.word	0x3000000c
 c0038d8:	30000004 	.word	0x30000004

0c0038dc <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
 c0038dc:	b480      	push	{r7}
 c0038de:	af00      	add	r7, sp, #0

#if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)

  #if defined (SAU_INIT_REGION0) && (SAU_INIT_REGION0 == 1U)
    SAU_INIT_REGION(0);
 c0038e0:	4b30      	ldr	r3, [pc, #192]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c0038e2:	2200      	movs	r2, #0
 c0038e4:	609a      	str	r2, [r3, #8]
 c0038e6:	4b2f      	ldr	r3, [pc, #188]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c0038e8:	4a2f      	ldr	r2, [pc, #188]	@ (c0039a8 <TZ_SAU_Setup+0xcc>)
 c0038ea:	60da      	str	r2, [r3, #12]
 c0038ec:	4b2d      	ldr	r3, [pc, #180]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c0038ee:	4a2f      	ldr	r2, [pc, #188]	@ (c0039ac <TZ_SAU_Setup+0xd0>)
 c0038f0:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION1) && (SAU_INIT_REGION1 == 1U)
    SAU_INIT_REGION(1);
 c0038f2:	4b2c      	ldr	r3, [pc, #176]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c0038f4:	2201      	movs	r2, #1
 c0038f6:	609a      	str	r2, [r3, #8]
 c0038f8:	4b2a      	ldr	r3, [pc, #168]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c0038fa:	4a2d      	ldr	r2, [pc, #180]	@ (c0039b0 <TZ_SAU_Setup+0xd4>)
 c0038fc:	60da      	str	r2, [r3, #12]
 c0038fe:	4b29      	ldr	r3, [pc, #164]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003900:	4a2c      	ldr	r2, [pc, #176]	@ (c0039b4 <TZ_SAU_Setup+0xd8>)
 c003902:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION2) && (SAU_INIT_REGION2 == 1U)
    SAU_INIT_REGION(2);
 c003904:	4b27      	ldr	r3, [pc, #156]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003906:	2202      	movs	r2, #2
 c003908:	609a      	str	r2, [r3, #8]
 c00390a:	4b26      	ldr	r3, [pc, #152]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c00390c:	4a2a      	ldr	r2, [pc, #168]	@ (c0039b8 <TZ_SAU_Setup+0xdc>)
 c00390e:	60da      	str	r2, [r3, #12]
 c003910:	4b24      	ldr	r3, [pc, #144]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003912:	4a2a      	ldr	r2, [pc, #168]	@ (c0039bc <TZ_SAU_Setup+0xe0>)
 c003914:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION3) && (SAU_INIT_REGION3 == 1U)
    SAU_INIT_REGION(3);
 c003916:	4b23      	ldr	r3, [pc, #140]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003918:	2203      	movs	r2, #3
 c00391a:	609a      	str	r2, [r3, #8]
 c00391c:	4b21      	ldr	r3, [pc, #132]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c00391e:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 c003922:	60da      	str	r2, [r3, #12]
 c003924:	4b1f      	ldr	r3, [pc, #124]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003926:	4a26      	ldr	r2, [pc, #152]	@ (c0039c0 <TZ_SAU_Setup+0xe4>)
 c003928:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION4) && (SAU_INIT_REGION4 == 1U)
    SAU_INIT_REGION(4);
 c00392a:	4b1e      	ldr	r3, [pc, #120]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c00392c:	2204      	movs	r2, #4
 c00392e:	609a      	str	r2, [r3, #8]
 c003930:	4b1c      	ldr	r3, [pc, #112]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003932:	f04f 42c0 	mov.w	r2, #1610612736	@ 0x60000000
 c003936:	60da      	str	r2, [r3, #12]
 c003938:	4b1a      	ldr	r3, [pc, #104]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c00393a:	4a22      	ldr	r2, [pc, #136]	@ (c0039c4 <TZ_SAU_Setup+0xe8>)
 c00393c:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION5) && (SAU_INIT_REGION5 == 1U)
    SAU_INIT_REGION(5);
 c00393e:	4b19      	ldr	r3, [pc, #100]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003940:	2205      	movs	r2, #5
 c003942:	609a      	str	r2, [r3, #8]
 c003944:	4b17      	ldr	r3, [pc, #92]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003946:	4a20      	ldr	r2, [pc, #128]	@ (c0039c8 <TZ_SAU_Setup+0xec>)
 c003948:	60da      	str	r2, [r3, #12]
 c00394a:	4b16      	ldr	r3, [pc, #88]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c00394c:	4a1f      	ldr	r2, [pc, #124]	@ (c0039cc <TZ_SAU_Setup+0xf0>)
 c00394e:	611a      	str	r2, [r3, #16]
  /* repeat this for all possible SAU regions */

#endif /* defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U) */

  #if defined (SAU_INIT_CTRL) && (SAU_INIT_CTRL == 1U)
    SAU->CTRL = ((SAU_INIT_CTRL_ENABLE << SAU_CTRL_ENABLE_Pos) & SAU_CTRL_ENABLE_Msk) |
 c003950:	4b14      	ldr	r3, [pc, #80]	@ (c0039a4 <TZ_SAU_Setup+0xc8>)
 c003952:	2201      	movs	r2, #1
 c003954:	601a      	str	r2, [r3, #0]
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c003956:	4b1e      	ldr	r3, [pc, #120]	@ (c0039d0 <TZ_SAU_Setup+0xf4>)
 c003958:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c00395c:	4a1c      	ldr	r2, [pc, #112]	@ (c0039d0 <TZ_SAU_Setup+0xf4>)
 c00395e:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c003962:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c003966:	4b1b      	ldr	r3, [pc, #108]	@ (c0039d4 <TZ_SAU_Setup+0xf8>)
 c003968:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
 c00396a:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c00396e:	4a19      	ldr	r2, [pc, #100]	@ (c0039d4 <TZ_SAU_Setup+0xf8>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
 c003970:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c003974:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
 c003976:	4b18      	ldr	r3, [pc, #96]	@ (c0039d8 <TZ_SAU_Setup+0xfc>)
 c003978:	2200      	movs	r2, #0
 c00397a:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
 c00397e:	4b16      	ldr	r3, [pc, #88]	@ (c0039d8 <TZ_SAU_Setup+0xfc>)
 c003980:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 c003984:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
 c003988:	4b13      	ldr	r3, [pc, #76]	@ (c0039d8 <TZ_SAU_Setup+0xfc>)
 c00398a:	2204      	movs	r2, #4
 c00398c:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
 c003990:	4b11      	ldr	r3, [pc, #68]	@ (c0039d8 <TZ_SAU_Setup+0xfc>)
 c003992:	2200      	movs	r2, #0
 c003994:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

}
 c003998:	bf00      	nop
 c00399a:	46bd      	mov	sp, r7
 c00399c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0039a0:	4770      	bx	lr
 c0039a2:	bf00      	nop
 c0039a4:	e000edd0 	.word	0xe000edd0
 c0039a8:	0c03e000 	.word	0x0c03e000
 c0039ac:	0c03ffe3 	.word	0x0c03ffe3
 c0039b0:	08040000 	.word	0x08040000
 c0039b4:	0807ffe1 	.word	0x0807ffe1
 c0039b8:	20018000 	.word	0x20018000
 c0039bc:	2003ffe1 	.word	0x2003ffe1
 c0039c0:	4fffffe1 	.word	0x4fffffe1
 c0039c4:	9fffffe1 	.word	0x9fffffe1
 c0039c8:	0bf90000 	.word	0x0bf90000
 c0039cc:	0bfa8fe1 	.word	0x0bfa8fe1
 c0039d0:	e000ed00 	.word	0xe000ed00
 c0039d4:	e000ef30 	.word	0xe000ef30
 c0039d8:	e000e100 	.word	0xe000e100

0c0039dc <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
 c0039dc:	b580      	push	{r7, lr}
 c0039de:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
 c0039e0:	f7ff ff7c 	bl	c0038dc <TZ_SAU_Setup>
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0039e4:	4b08      	ldr	r3, [pc, #32]	@ (c003a08 <SystemInit+0x2c>)
 c0039e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 c0039ea:	4a07      	ldr	r2, [pc, #28]	@ (c003a08 <SystemInit+0x2c>)
 c0039ec:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 c0039f0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0039f4:	4b05      	ldr	r3, [pc, #20]	@ (c003a0c <SystemInit+0x30>)
 c0039f6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 c0039fa:	4a04      	ldr	r2, [pc, #16]	@ (c003a0c <SystemInit+0x30>)
 c0039fc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 c003a00:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif
}
 c003a04:	bf00      	nop
 c003a06:	bd80      	pop	{r7, pc}
 c003a08:	e000ed00 	.word	0xe000ed00
 c003a0c:	e002ed00 	.word	0xe002ed00

0c003a10 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 c003a10:	b480      	push	{r7}
 c003a12:	b087      	sub	sp, #28
 c003a14:	af00      	add	r7, sp, #0
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c003a16:	4b4f      	ldr	r3, [pc, #316]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003a18:	681b      	ldr	r3, [r3, #0]
 c003a1a:	f003 0308 	and.w	r3, r3, #8
 c003a1e:	2b00      	cmp	r3, #0
 c003a20:	d107      	bne.n	c003a32 <SystemCoreClockUpdate+0x22>
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c003a22:	4b4c      	ldr	r3, [pc, #304]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003a24:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 c003a28:	0a1b      	lsrs	r3, r3, #8
 c003a2a:	f003 030f 	and.w	r3, r3, #15
 c003a2e:	617b      	str	r3, [r7, #20]
 c003a30:	e005      	b.n	c003a3e <SystemCoreClockUpdate+0x2e>
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c003a32:	4b48      	ldr	r3, [pc, #288]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003a34:	681b      	ldr	r3, [r3, #0]
 c003a36:	091b      	lsrs	r3, r3, #4
 c003a38:	f003 030f 	and.w	r3, r3, #15
 c003a3c:	617b      	str	r3, [r7, #20]
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 c003a3e:	4a46      	ldr	r2, [pc, #280]	@ (c003b58 <SystemCoreClockUpdate+0x148>)
 c003a40:	697b      	ldr	r3, [r7, #20]
 c003a42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c003a46:	617b      	str	r3, [r7, #20]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c003a48:	4b42      	ldr	r3, [pc, #264]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003a4a:	689b      	ldr	r3, [r3, #8]
 c003a4c:	f003 030c 	and.w	r3, r3, #12
 c003a50:	2b0c      	cmp	r3, #12
 c003a52:	d866      	bhi.n	c003b22 <SystemCoreClockUpdate+0x112>
 c003a54:	a201      	add	r2, pc, #4	@ (adr r2, c003a5c <SystemCoreClockUpdate+0x4c>)
 c003a56:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c003a5a:	bf00      	nop
 c003a5c:	0c003a91 	.word	0x0c003a91
 c003a60:	0c003b23 	.word	0x0c003b23
 c003a64:	0c003b23 	.word	0x0c003b23
 c003a68:	0c003b23 	.word	0x0c003b23
 c003a6c:	0c003a99 	.word	0x0c003a99
 c003a70:	0c003b23 	.word	0x0c003b23
 c003a74:	0c003b23 	.word	0x0c003b23
 c003a78:	0c003b23 	.word	0x0c003b23
 c003a7c:	0c003aa1 	.word	0x0c003aa1
 c003a80:	0c003b23 	.word	0x0c003b23
 c003a84:	0c003b23 	.word	0x0c003b23
 c003a88:	0c003b23 	.word	0x0c003b23
 c003a8c:	0c003aa9 	.word	0x0c003aa9
  {
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
 c003a90:	4a32      	ldr	r2, [pc, #200]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003a92:	697b      	ldr	r3, [r7, #20]
 c003a94:	6013      	str	r3, [r2, #0]
      break;
 c003a96:	e048      	b.n	c003b2a <SystemCoreClockUpdate+0x11a>

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 c003a98:	4b30      	ldr	r3, [pc, #192]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003a9a:	4a31      	ldr	r2, [pc, #196]	@ (c003b60 <SystemCoreClockUpdate+0x150>)
 c003a9c:	601a      	str	r2, [r3, #0]
      break;
 c003a9e:	e044      	b.n	c003b2a <SystemCoreClockUpdate+0x11a>

    case 0x08:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 c003aa0:	4b2e      	ldr	r3, [pc, #184]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003aa2:	4a2f      	ldr	r2, [pc, #188]	@ (c003b60 <SystemCoreClockUpdate+0x150>)
 c003aa4:	601a      	str	r2, [r3, #0]
      break;
 c003aa6:	e040      	b.n	c003b2a <SystemCoreClockUpdate+0x11a>

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c003aa8:	4b2a      	ldr	r3, [pc, #168]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003aaa:	68db      	ldr	r3, [r3, #12]
 c003aac:	f003 0303 	and.w	r3, r3, #3
 c003ab0:	60fb      	str	r3, [r7, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c003ab2:	4b28      	ldr	r3, [pc, #160]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003ab4:	68db      	ldr	r3, [r3, #12]
 c003ab6:	091b      	lsrs	r3, r3, #4
 c003ab8:	f003 030f 	and.w	r3, r3, #15
 c003abc:	3301      	adds	r3, #1
 c003abe:	60bb      	str	r3, [r7, #8]

      switch (pllsource)
 c003ac0:	68fb      	ldr	r3, [r7, #12]
 c003ac2:	2b02      	cmp	r3, #2
 c003ac4:	d003      	beq.n	c003ace <SystemCoreClockUpdate+0xbe>
 c003ac6:	68fb      	ldr	r3, [r7, #12]
 c003ac8:	2b03      	cmp	r3, #3
 c003aca:	d006      	beq.n	c003ada <SystemCoreClockUpdate+0xca>
 c003acc:	e00b      	b.n	c003ae6 <SystemCoreClockUpdate+0xd6>
      {
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
 c003ace:	4a24      	ldr	r2, [pc, #144]	@ (c003b60 <SystemCoreClockUpdate+0x150>)
 c003ad0:	68bb      	ldr	r3, [r7, #8]
 c003ad2:	fbb2 f3f3 	udiv	r3, r2, r3
 c003ad6:	613b      	str	r3, [r7, #16]
          break;
 c003ad8:	e00b      	b.n	c003af2 <SystemCoreClockUpdate+0xe2>

        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
 c003ada:	4a21      	ldr	r2, [pc, #132]	@ (c003b60 <SystemCoreClockUpdate+0x150>)
 c003adc:	68bb      	ldr	r3, [r7, #8]
 c003ade:	fbb2 f3f3 	udiv	r3, r2, r3
 c003ae2:	613b      	str	r3, [r7, #16]
          break;
 c003ae4:	e005      	b.n	c003af2 <SystemCoreClockUpdate+0xe2>

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
 c003ae6:	697a      	ldr	r2, [r7, #20]
 c003ae8:	68bb      	ldr	r3, [r7, #8]
 c003aea:	fbb2 f3f3 	udiv	r3, r2, r3
 c003aee:	613b      	str	r3, [r7, #16]
          break;
 c003af0:	bf00      	nop
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c003af2:	4b18      	ldr	r3, [pc, #96]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003af4:	68db      	ldr	r3, [r3, #12]
 c003af6:	0a1b      	lsrs	r3, r3, #8
 c003af8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 c003afc:	693b      	ldr	r3, [r7, #16]
 c003afe:	fb02 f303 	mul.w	r3, r2, r3
 c003b02:	613b      	str	r3, [r7, #16]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c003b04:	4b13      	ldr	r3, [pc, #76]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003b06:	68db      	ldr	r3, [r3, #12]
 c003b08:	0e5b      	lsrs	r3, r3, #25
 c003b0a:	f003 0303 	and.w	r3, r3, #3
 c003b0e:	3301      	adds	r3, #1
 c003b10:	005b      	lsls	r3, r3, #1
 c003b12:	607b      	str	r3, [r7, #4]
      SystemCoreClock = pllvco/pllr;
 c003b14:	693a      	ldr	r2, [r7, #16]
 c003b16:	687b      	ldr	r3, [r7, #4]
 c003b18:	fbb2 f3f3 	udiv	r3, r2, r3
 c003b1c:	4a0f      	ldr	r2, [pc, #60]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003b1e:	6013      	str	r3, [r2, #0]
      break;
 c003b20:	e003      	b.n	c003b2a <SystemCoreClockUpdate+0x11a>

    default:
      SystemCoreClock = msirange;
 c003b22:	4a0e      	ldr	r2, [pc, #56]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003b24:	697b      	ldr	r3, [r7, #20]
 c003b26:	6013      	str	r3, [r2, #0]
      break;
 c003b28:	bf00      	nop
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 c003b2a:	4b0a      	ldr	r3, [pc, #40]	@ (c003b54 <SystemCoreClockUpdate+0x144>)
 c003b2c:	689b      	ldr	r3, [r3, #8]
 c003b2e:	091b      	lsrs	r3, r3, #4
 c003b30:	f003 030f 	and.w	r3, r3, #15
 c003b34:	4a0b      	ldr	r2, [pc, #44]	@ (c003b64 <SystemCoreClockUpdate+0x154>)
 c003b36:	5cd3      	ldrb	r3, [r2, r3]
 c003b38:	603b      	str	r3, [r7, #0]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 c003b3a:	4b08      	ldr	r3, [pc, #32]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003b3c:	681a      	ldr	r2, [r3, #0]
 c003b3e:	683b      	ldr	r3, [r7, #0]
 c003b40:	fa22 f303 	lsr.w	r3, r2, r3
 c003b44:	4a05      	ldr	r2, [pc, #20]	@ (c003b5c <SystemCoreClockUpdate+0x14c>)
 c003b46:	6013      	str	r3, [r2, #0]
}
 c003b48:	bf00      	nop
 c003b4a:	371c      	adds	r7, #28
 c003b4c:	46bd      	mov	sp, r7
 c003b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003b52:	4770      	bx	lr
 c003b54:	50021000 	.word	0x50021000
 c003b58:	0c006c9c 	.word	0x0c006c9c
 c003b5c:	30000018 	.word	0x30000018
 c003b60:	00f42400 	.word	0x00f42400
 c003b64:	0c006c8c 	.word	0x0c006c8c

0c003b68 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value (HCLK)
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
 c003b68:	b580      	push	{r7, lr}
 c003b6a:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
 c003b6c:	f7ff ff50 	bl	c003a10 <SystemCoreClockUpdate>
  
  return SystemCoreClock;
 c003b70:	4b1c      	ldr	r3, [pc, #112]	@ (c003be4 <__acle_se_SECURE_SystemCoreClockUpdate+0x7c>)
 c003b72:	681b      	ldr	r3, [r3, #0]
}
 c003b74:	4618      	mov	r0, r3
 c003b76:	46bd      	mov	sp, r7
 c003b78:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c003b7c:	4671      	mov	r1, lr
 c003b7e:	4672      	mov	r2, lr
 c003b80:	4673      	mov	r3, lr
 c003b82:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c003b86:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c003b8a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003b8e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c003b92:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c003b96:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c003b9a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003b9e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c003ba2:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003ba6:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003baa:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003bae:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c003bb2:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003bb6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003bba:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003bbe:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c003bc2:	f38e 8c00 	msr	CPSR_fs, lr
 c003bc6:	b410      	push	{r4}
 c003bc8:	eef1 ca10 	vmrs	ip, fpscr
 c003bcc:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c003bd0:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c003bd4:	ea0c 0c04 	and.w	ip, ip, r4
 c003bd8:	eee1 ca10 	vmsr	fpscr, ip
 c003bdc:	bc10      	pop	{r4}
 c003bde:	46f4      	mov	ip, lr
 c003be0:	4774      	bxns	lr
 c003be2:	bf00      	nop
 c003be4:	30000018 	.word	0x30000018

0c003be8 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 c003be8:	b580      	push	{r7, lr}
 c003bea:	b082      	sub	sp, #8
 c003bec:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 c003bee:	2300      	movs	r3, #0
 c003bf0:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 c003bf2:	2004      	movs	r0, #4
 c003bf4:	f000 f94e 	bl	c003e94 <HAL_NVIC_SetPriorityGrouping>

  /* Insure time base clock coherency */
  SystemCoreClockUpdate();
 c003bf8:	f7ff ff0a 	bl	c003a10 <SystemCoreClockUpdate>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c003bfc:	2000      	movs	r0, #0
 c003bfe:	f000 f80d 	bl	c003c1c <HAL_InitTick>
 c003c02:	4603      	mov	r3, r0
 c003c04:	2b00      	cmp	r3, #0
 c003c06:	d002      	beq.n	c003c0e <HAL_Init+0x26>
  {
    status = HAL_ERROR;
 c003c08:	2301      	movs	r3, #1
 c003c0a:	71fb      	strb	r3, [r7, #7]
 c003c0c:	e001      	b.n	c003c12 <HAL_Init+0x2a>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 c003c0e:	f7ff fc3d 	bl	c00348c <HAL_MspInit>
  }

  /* Return function status */
  return status;
 c003c12:	79fb      	ldrb	r3, [r7, #7]
}
 c003c14:	4618      	mov	r0, r3
 c003c16:	3708      	adds	r7, #8
 c003c18:	46bd      	mov	sp, r7
 c003c1a:	bd80      	pop	{r7, pc}

0c003c1c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 c003c1c:	b580      	push	{r7, lr}
 c003c1e:	b084      	sub	sp, #16
 c003c20:	af00      	add	r7, sp, #0
 c003c22:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 c003c24:	2300      	movs	r3, #0
 c003c26:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 c003c28:	4b17      	ldr	r3, [pc, #92]	@ (c003c88 <HAL_InitTick+0x6c>)
 c003c2a:	781b      	ldrb	r3, [r3, #0]
 c003c2c:	2b00      	cmp	r3, #0
 c003c2e:	d023      	beq.n	c003c78 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 c003c30:	4b16      	ldr	r3, [pc, #88]	@ (c003c8c <HAL_InitTick+0x70>)
 c003c32:	681a      	ldr	r2, [r3, #0]
 c003c34:	4b14      	ldr	r3, [pc, #80]	@ (c003c88 <HAL_InitTick+0x6c>)
 c003c36:	781b      	ldrb	r3, [r3, #0]
 c003c38:	4619      	mov	r1, r3
 c003c3a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 c003c3e:	fbb3 f3f1 	udiv	r3, r3, r1
 c003c42:	fbb2 f3f3 	udiv	r3, r2, r3
 c003c46:	4618      	mov	r0, r3
 c003c48:	f000 f957 	bl	c003efa <HAL_SYSTICK_Config>
 c003c4c:	4603      	mov	r3, r0
 c003c4e:	2b00      	cmp	r3, #0
 c003c50:	d10f      	bne.n	c003c72 <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 c003c52:	687b      	ldr	r3, [r7, #4]
 c003c54:	2b07      	cmp	r3, #7
 c003c56:	d809      	bhi.n	c003c6c <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 c003c58:	2200      	movs	r2, #0
 c003c5a:	6879      	ldr	r1, [r7, #4]
 c003c5c:	f04f 30ff 	mov.w	r0, #4294967295
 c003c60:	f000 f923 	bl	c003eaa <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 c003c64:	4a0a      	ldr	r2, [pc, #40]	@ (c003c90 <HAL_InitTick+0x74>)
 c003c66:	687b      	ldr	r3, [r7, #4]
 c003c68:	6013      	str	r3, [r2, #0]
 c003c6a:	e007      	b.n	c003c7c <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
 c003c6c:	2301      	movs	r3, #1
 c003c6e:	73fb      	strb	r3, [r7, #15]
 c003c70:	e004      	b.n	c003c7c <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
 c003c72:	2301      	movs	r3, #1
 c003c74:	73fb      	strb	r3, [r7, #15]
 c003c76:	e001      	b.n	c003c7c <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
 c003c78:	2301      	movs	r3, #1
 c003c7a:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 c003c7c:	7bfb      	ldrb	r3, [r7, #15]
}
 c003c7e:	4618      	mov	r0, r3
 c003c80:	3710      	adds	r7, #16
 c003c82:	46bd      	mov	sp, r7
 c003c84:	bd80      	pop	{r7, pc}
 c003c86:	bf00      	nop
 c003c88:	30000020 	.word	0x30000020
 c003c8c:	30000018 	.word	0x30000018
 c003c90:	3000001c 	.word	0x3000001c

0c003c94 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 c003c94:	b480      	push	{r7}
 c003c96:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 c003c98:	4b06      	ldr	r3, [pc, #24]	@ (c003cb4 <HAL_IncTick+0x20>)
 c003c9a:	781b      	ldrb	r3, [r3, #0]
 c003c9c:	461a      	mov	r2, r3
 c003c9e:	4b06      	ldr	r3, [pc, #24]	@ (c003cb8 <HAL_IncTick+0x24>)
 c003ca0:	681b      	ldr	r3, [r3, #0]
 c003ca2:	4413      	add	r3, r2
 c003ca4:	4a04      	ldr	r2, [pc, #16]	@ (c003cb8 <HAL_IncTick+0x24>)
 c003ca6:	6013      	str	r3, [r2, #0]
}
 c003ca8:	bf00      	nop
 c003caa:	46bd      	mov	sp, r7
 c003cac:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003cb0:	4770      	bx	lr
 c003cb2:	bf00      	nop
 c003cb4:	30000020 	.word	0x30000020
 c003cb8:	300004bc 	.word	0x300004bc

0c003cbc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 c003cbc:	b480      	push	{r7}
 c003cbe:	af00      	add	r7, sp, #0
  return uwTick;
 c003cc0:	4b03      	ldr	r3, [pc, #12]	@ (c003cd0 <HAL_GetTick+0x14>)
 c003cc2:	681b      	ldr	r3, [r3, #0]
}
 c003cc4:	4618      	mov	r0, r3
 c003cc6:	46bd      	mov	sp, r7
 c003cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003ccc:	4770      	bx	lr
 c003cce:	bf00      	nop
 c003cd0:	300004bc 	.word	0x300004bc

0c003cd4 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
 c003cd4:	b480      	push	{r7}
 c003cd6:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 c003cd8:	4b05      	ldr	r3, [pc, #20]	@ (c003cf0 <HAL_SuspendTick+0x1c>)
 c003cda:	681b      	ldr	r3, [r3, #0]
 c003cdc:	4a04      	ldr	r2, [pc, #16]	@ (c003cf0 <HAL_SuspendTick+0x1c>)
 c003cde:	f023 0302 	bic.w	r3, r3, #2
 c003ce2:	6013      	str	r3, [r2, #0]
}
 c003ce4:	bf00      	nop
 c003ce6:	46bd      	mov	sp, r7
 c003ce8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003cec:	4770      	bx	lr
 c003cee:	bf00      	nop
 c003cf0:	e000e010 	.word	0xe000e010

0c003cf4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 c003cf4:	b480      	push	{r7}
 c003cf6:	b085      	sub	sp, #20
 c003cf8:	af00      	add	r7, sp, #0
 c003cfa:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 c003cfc:	687b      	ldr	r3, [r7, #4]
 c003cfe:	f003 0307 	and.w	r3, r3, #7
 c003d02:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c003d04:	4b0c      	ldr	r3, [pc, #48]	@ (c003d38 <__NVIC_SetPriorityGrouping+0x44>)
 c003d06:	68db      	ldr	r3, [r3, #12]
 c003d08:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c003d0a:	68ba      	ldr	r2, [r7, #8]
 c003d0c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 c003d10:	4013      	ands	r3, r2
 c003d12:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c003d14:	68fb      	ldr	r3, [r7, #12]
 c003d16:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 c003d18:	68bb      	ldr	r3, [r7, #8]
 c003d1a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 c003d1c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 c003d20:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 c003d24:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 c003d26:	4a04      	ldr	r2, [pc, #16]	@ (c003d38 <__NVIC_SetPriorityGrouping+0x44>)
 c003d28:	68bb      	ldr	r3, [r7, #8]
 c003d2a:	60d3      	str	r3, [r2, #12]
}
 c003d2c:	bf00      	nop
 c003d2e:	3714      	adds	r7, #20
 c003d30:	46bd      	mov	sp, r7
 c003d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d36:	4770      	bx	lr
 c003d38:	e000ed00 	.word	0xe000ed00

0c003d3c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 c003d3c:	b480      	push	{r7}
 c003d3e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c003d40:	4b04      	ldr	r3, [pc, #16]	@ (c003d54 <__NVIC_GetPriorityGrouping+0x18>)
 c003d42:	68db      	ldr	r3, [r3, #12]
 c003d44:	0a1b      	lsrs	r3, r3, #8
 c003d46:	f003 0307 	and.w	r3, r3, #7
}
 c003d4a:	4618      	mov	r0, r3
 c003d4c:	46bd      	mov	sp, r7
 c003d4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d52:	4770      	bx	lr
 c003d54:	e000ed00 	.word	0xe000ed00

0c003d58 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 c003d58:	b480      	push	{r7}
 c003d5a:	b083      	sub	sp, #12
 c003d5c:	af00      	add	r7, sp, #0
 c003d5e:	4603      	mov	r3, r0
 c003d60:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 c003d62:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d66:	2b00      	cmp	r3, #0
 c003d68:	db0b      	blt.n	c003d82 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c003d6a:	79fb      	ldrb	r3, [r7, #7]
 c003d6c:	f003 021f 	and.w	r2, r3, #31
 c003d70:	4907      	ldr	r1, [pc, #28]	@ (c003d90 <__NVIC_EnableIRQ+0x38>)
 c003d72:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d76:	095b      	lsrs	r3, r3, #5
 c003d78:	2001      	movs	r0, #1
 c003d7a:	fa00 f202 	lsl.w	r2, r0, r2
 c003d7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 c003d82:	bf00      	nop
 c003d84:	370c      	adds	r7, #12
 c003d86:	46bd      	mov	sp, r7
 c003d88:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d8c:	4770      	bx	lr
 c003d8e:	bf00      	nop
 c003d90:	e000e100 	.word	0xe000e100

0c003d94 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 c003d94:	b480      	push	{r7}
 c003d96:	b083      	sub	sp, #12
 c003d98:	af00      	add	r7, sp, #0
 c003d9a:	4603      	mov	r3, r0
 c003d9c:	6039      	str	r1, [r7, #0]
 c003d9e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 c003da0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003da4:	2b00      	cmp	r3, #0
 c003da6:	db0a      	blt.n	c003dbe <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c003da8:	683b      	ldr	r3, [r7, #0]
 c003daa:	b2da      	uxtb	r2, r3
 c003dac:	490c      	ldr	r1, [pc, #48]	@ (c003de0 <__NVIC_SetPriority+0x4c>)
 c003dae:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003db2:	0152      	lsls	r2, r2, #5
 c003db4:	b2d2      	uxtb	r2, r2
 c003db6:	440b      	add	r3, r1
 c003db8:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 c003dbc:	e00a      	b.n	c003dd4 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c003dbe:	683b      	ldr	r3, [r7, #0]
 c003dc0:	b2da      	uxtb	r2, r3
 c003dc2:	4908      	ldr	r1, [pc, #32]	@ (c003de4 <__NVIC_SetPriority+0x50>)
 c003dc4:	79fb      	ldrb	r3, [r7, #7]
 c003dc6:	f003 030f 	and.w	r3, r3, #15
 c003dca:	3b04      	subs	r3, #4
 c003dcc:	0152      	lsls	r2, r2, #5
 c003dce:	b2d2      	uxtb	r2, r2
 c003dd0:	440b      	add	r3, r1
 c003dd2:	761a      	strb	r2, [r3, #24]
}
 c003dd4:	bf00      	nop
 c003dd6:	370c      	adds	r7, #12
 c003dd8:	46bd      	mov	sp, r7
 c003dda:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003dde:	4770      	bx	lr
 c003de0:	e000e100 	.word	0xe000e100
 c003de4:	e000ed00 	.word	0xe000ed00

0c003de8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c003de8:	b480      	push	{r7}
 c003dea:	b089      	sub	sp, #36	@ 0x24
 c003dec:	af00      	add	r7, sp, #0
 c003dee:	60f8      	str	r0, [r7, #12]
 c003df0:	60b9      	str	r1, [r7, #8]
 c003df2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 c003df4:	68fb      	ldr	r3, [r7, #12]
 c003df6:	f003 0307 	and.w	r3, r3, #7
 c003dfa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c003dfc:	69fb      	ldr	r3, [r7, #28]
 c003dfe:	f1c3 0307 	rsb	r3, r3, #7
 c003e02:	2b03      	cmp	r3, #3
 c003e04:	bf28      	it	cs
 c003e06:	2303      	movcs	r3, #3
 c003e08:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c003e0a:	69fb      	ldr	r3, [r7, #28]
 c003e0c:	3303      	adds	r3, #3
 c003e0e:	2b06      	cmp	r3, #6
 c003e10:	d902      	bls.n	c003e18 <NVIC_EncodePriority+0x30>
 c003e12:	69fb      	ldr	r3, [r7, #28]
 c003e14:	3b04      	subs	r3, #4
 c003e16:	e000      	b.n	c003e1a <NVIC_EncodePriority+0x32>
 c003e18:	2300      	movs	r3, #0
 c003e1a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c003e1c:	f04f 32ff 	mov.w	r2, #4294967295
 c003e20:	69bb      	ldr	r3, [r7, #24]
 c003e22:	fa02 f303 	lsl.w	r3, r2, r3
 c003e26:	43da      	mvns	r2, r3
 c003e28:	68bb      	ldr	r3, [r7, #8]
 c003e2a:	401a      	ands	r2, r3
 c003e2c:	697b      	ldr	r3, [r7, #20]
 c003e2e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 c003e30:	f04f 31ff 	mov.w	r1, #4294967295
 c003e34:	697b      	ldr	r3, [r7, #20]
 c003e36:	fa01 f303 	lsl.w	r3, r1, r3
 c003e3a:	43d9      	mvns	r1, r3
 c003e3c:	687b      	ldr	r3, [r7, #4]
 c003e3e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c003e40:	4313      	orrs	r3, r2
         );
}
 c003e42:	4618      	mov	r0, r3
 c003e44:	3724      	adds	r7, #36	@ 0x24
 c003e46:	46bd      	mov	sp, r7
 c003e48:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003e4c:	4770      	bx	lr
	...

0c003e50 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 c003e50:	b580      	push	{r7, lr}
 c003e52:	b082      	sub	sp, #8
 c003e54:	af00      	add	r7, sp, #0
 c003e56:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 c003e58:	687b      	ldr	r3, [r7, #4]
 c003e5a:	3b01      	subs	r3, #1
 c003e5c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 c003e60:	d301      	bcc.n	c003e66 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 c003e62:	2301      	movs	r3, #1
 c003e64:	e00f      	b.n	c003e86 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c003e66:	4a0a      	ldr	r2, [pc, #40]	@ (c003e90 <SysTick_Config+0x40>)
 c003e68:	687b      	ldr	r3, [r7, #4]
 c003e6a:	3b01      	subs	r3, #1
 c003e6c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 c003e6e:	2107      	movs	r1, #7
 c003e70:	f04f 30ff 	mov.w	r0, #4294967295
 c003e74:	f7ff ff8e 	bl	c003d94 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c003e78:	4b05      	ldr	r3, [pc, #20]	@ (c003e90 <SysTick_Config+0x40>)
 c003e7a:	2200      	movs	r2, #0
 c003e7c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c003e7e:	4b04      	ldr	r3, [pc, #16]	@ (c003e90 <SysTick_Config+0x40>)
 c003e80:	2207      	movs	r2, #7
 c003e82:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 c003e84:	2300      	movs	r3, #0
}
 c003e86:	4618      	mov	r0, r3
 c003e88:	3708      	adds	r7, #8
 c003e8a:	46bd      	mov	sp, r7
 c003e8c:	bd80      	pop	{r7, pc}
 c003e8e:	bf00      	nop
 c003e90:	e000e010 	.word	0xe000e010

0c003e94 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 c003e94:	b580      	push	{r7, lr}
 c003e96:	b082      	sub	sp, #8
 c003e98:	af00      	add	r7, sp, #0
 c003e9a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 c003e9c:	6878      	ldr	r0, [r7, #4]
 c003e9e:	f7ff ff29 	bl	c003cf4 <__NVIC_SetPriorityGrouping>
}
 c003ea2:	bf00      	nop
 c003ea4:	3708      	adds	r7, #8
 c003ea6:	46bd      	mov	sp, r7
 c003ea8:	bd80      	pop	{r7, pc}

0c003eaa <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c003eaa:	b580      	push	{r7, lr}
 c003eac:	b086      	sub	sp, #24
 c003eae:	af00      	add	r7, sp, #0
 c003eb0:	4603      	mov	r3, r0
 c003eb2:	60b9      	str	r1, [r7, #8]
 c003eb4:	607a      	str	r2, [r7, #4]
 c003eb6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 c003eb8:	f7ff ff40 	bl	c003d3c <__NVIC_GetPriorityGrouping>
 c003ebc:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 c003ebe:	687a      	ldr	r2, [r7, #4]
 c003ec0:	68b9      	ldr	r1, [r7, #8]
 c003ec2:	6978      	ldr	r0, [r7, #20]
 c003ec4:	f7ff ff90 	bl	c003de8 <NVIC_EncodePriority>
 c003ec8:	4602      	mov	r2, r0
 c003eca:	f997 300f 	ldrsb.w	r3, [r7, #15]
 c003ece:	4611      	mov	r1, r2
 c003ed0:	4618      	mov	r0, r3
 c003ed2:	f7ff ff5f 	bl	c003d94 <__NVIC_SetPriority>
}
 c003ed6:	bf00      	nop
 c003ed8:	3718      	adds	r7, #24
 c003eda:	46bd      	mov	sp, r7
 c003edc:	bd80      	pop	{r7, pc}

0c003ede <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 c003ede:	b580      	push	{r7, lr}
 c003ee0:	b082      	sub	sp, #8
 c003ee2:	af00      	add	r7, sp, #0
 c003ee4:	4603      	mov	r3, r0
 c003ee6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 c003ee8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003eec:	4618      	mov	r0, r3
 c003eee:	f7ff ff33 	bl	c003d58 <__NVIC_EnableIRQ>
}
 c003ef2:	bf00      	nop
 c003ef4:	3708      	adds	r7, #8
 c003ef6:	46bd      	mov	sp, r7
 c003ef8:	bd80      	pop	{r7, pc}

0c003efa <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 c003efa:	b580      	push	{r7, lr}
 c003efc:	b082      	sub	sp, #8
 c003efe:	af00      	add	r7, sp, #0
 c003f00:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 c003f02:	6878      	ldr	r0, [r7, #4]
 c003f04:	f7ff ffa4 	bl	c003e50 <SysTick_Config>
 c003f08:	4603      	mov	r3, r0
}
 c003f0a:	4618      	mov	r0, r3
 c003f0c:	3708      	adds	r7, #8
 c003f0e:	46bd      	mov	sp, r7
 c003f10:	bd80      	pop	{r7, pc}
	...

0c003f14 <HAL_FLASH_Program>:
  *                This parameter is the data for the double word program
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 c003f14:	b580      	push	{r7, lr}
 c003f16:	b086      	sub	sp, #24
 c003f18:	af00      	add	r7, sp, #0
 c003f1a:	60f8      	str	r0, [r7, #12]
 c003f1c:	60b9      	str	r1, [r7, #8]
 c003f1e:	e9c7 2300 	strd	r2, r3, [r7]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 c003f22:	4b1e      	ldr	r3, [pc, #120]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f24:	781b      	ldrb	r3, [r3, #0]
 c003f26:	2b01      	cmp	r3, #1
 c003f28:	d101      	bne.n	c003f2e <HAL_FLASH_Program+0x1a>
 c003f2a:	2302      	movs	r3, #2
 c003f2c:	e032      	b.n	c003f94 <HAL_FLASH_Program+0x80>
 c003f2e:	4b1b      	ldr	r3, [pc, #108]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f30:	2201      	movs	r2, #1
 c003f32:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c003f34:	4b19      	ldr	r3, [pc, #100]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f36:	2200      	movs	r2, #0
 c003f38:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c003f3a:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c003f3e:	f000 f89f 	bl	c004080 <FLASH_WaitForLastOperation>
 c003f42:	4603      	mov	r3, r0
 c003f44:	75fb      	strb	r3, [r7, #23]

  if(status == HAL_OK)
 c003f46:	7dfb      	ldrb	r3, [r7, #23]
 c003f48:	2b00      	cmp	r3, #0
 c003f4a:	d11f      	bne.n	c003f8c <HAL_FLASH_Program+0x78>
  {
    pFlash.ProcedureOnGoing = TypeProgram;
 c003f4c:	4a13      	ldr	r2, [pc, #76]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f4e:	68fb      	ldr	r3, [r7, #12]
 c003f50:	6093      	str	r3, [r2, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c003f52:	4b12      	ldr	r3, [pc, #72]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f54:	689b      	ldr	r3, [r3, #8]
 c003f56:	2b00      	cmp	r3, #0
 c003f58:	db01      	blt.n	c003f5e <HAL_FLASH_Program+0x4a>
 c003f5a:	4b11      	ldr	r3, [pc, #68]	@ (c003fa0 <HAL_FLASH_Program+0x8c>)
 c003f5c:	e000      	b.n	c003f60 <HAL_FLASH_Program+0x4c>
 c003f5e:	4b11      	ldr	r3, [pc, #68]	@ (c003fa4 <HAL_FLASH_Program+0x90>)
 c003f60:	613b      	str	r3, [r7, #16]

    /* Program double-word (64-bit) at a specified address */
    FLASH_Program_DoubleWord(Address, Data);
 c003f62:	e9d7 2300 	ldrd	r2, r3, [r7]
 c003f66:	68b8      	ldr	r0, [r7, #8]
 c003f68:	f000 f8e8 	bl	c00413c <FLASH_Program_DoubleWord>

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c003f6c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c003f70:	f000 f886 	bl	c004080 <FLASH_WaitForLastOperation>
 c003f74:	4603      	mov	r3, r0
 c003f76:	75fb      	strb	r3, [r7, #23]

    /* If the program operation is completed, disable the PG Bit */
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c003f78:	693b      	ldr	r3, [r7, #16]
 c003f7a:	681a      	ldr	r2, [r3, #0]
 c003f7c:	4b07      	ldr	r3, [pc, #28]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f7e:	689b      	ldr	r3, [r3, #8]
 c003f80:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c003f84:	43db      	mvns	r3, r3
 c003f86:	401a      	ands	r2, r3
 c003f88:	693b      	ldr	r3, [r7, #16]
 c003f8a:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c003f8c:	4b03      	ldr	r3, [pc, #12]	@ (c003f9c <HAL_FLASH_Program+0x88>)
 c003f8e:	2200      	movs	r2, #0
 c003f90:	701a      	strb	r2, [r3, #0]

  return status;
 c003f92:	7dfb      	ldrb	r3, [r7, #23]
}
 c003f94:	4618      	mov	r0, r3
 c003f96:	3718      	adds	r7, #24
 c003f98:	46bd      	mov	sp, r7
 c003f9a:	bd80      	pop	{r7, pc}
 c003f9c:	30000024 	.word	0x30000024
 c003fa0:	5002202c 	.word	0x5002202c
 c003fa4:	40022028 	.word	0x40022028

0c003fa8 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 c003fa8:	b480      	push	{r7}
 c003faa:	b083      	sub	sp, #12
 c003fac:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c003fae:	2300      	movs	r3, #0
 c003fb0:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003fb2:	4b15      	ldr	r3, [pc, #84]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fb4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003fb6:	2b00      	cmp	r3, #0
 c003fb8:	da0b      	bge.n	c003fd2 <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c003fba:	4b13      	ldr	r3, [pc, #76]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fbc:	4a13      	ldr	r2, [pc, #76]	@ (c00400c <HAL_FLASH_Unlock+0x64>)
 c003fbe:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c003fc0:	4b11      	ldr	r3, [pc, #68]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fc2:	4a13      	ldr	r2, [pc, #76]	@ (c004010 <HAL_FLASH_Unlock+0x68>)
 c003fc4:	609a      	str	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003fc6:	4b10      	ldr	r3, [pc, #64]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fc8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003fca:	2b00      	cmp	r3, #0
 c003fcc:	da01      	bge.n	c003fd2 <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 c003fce:	2301      	movs	r3, #1
 c003fd0:	71fb      	strb	r3, [r7, #7]
    }
  }

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if (status == HAL_OK)
 c003fd2:	79fb      	ldrb	r3, [r7, #7]
 c003fd4:	2b00      	cmp	r3, #0
 c003fd6:	d10f      	bne.n	c003ff8 <HAL_FLASH_Unlock+0x50>
  {
    if(READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c003fd8:	4b0b      	ldr	r3, [pc, #44]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fda:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c003fdc:	2b00      	cmp	r3, #0
 c003fde:	da0b      	bge.n	c003ff8 <HAL_FLASH_Unlock+0x50>
    {
      /* Authorize the FLASH Registers access */
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c003fe0:	4b09      	ldr	r3, [pc, #36]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fe2:	4a0a      	ldr	r2, [pc, #40]	@ (c00400c <HAL_FLASH_Unlock+0x64>)
 c003fe4:	60da      	str	r2, [r3, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c003fe6:	4b08      	ldr	r3, [pc, #32]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fe8:	4a09      	ldr	r2, [pc, #36]	@ (c004010 <HAL_FLASH_Unlock+0x68>)
 c003fea:	60da      	str	r2, [r3, #12]

      /* verify Flash is unlocked */
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c003fec:	4b06      	ldr	r3, [pc, #24]	@ (c004008 <HAL_FLASH_Unlock+0x60>)
 c003fee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c003ff0:	2b00      	cmp	r3, #0
 c003ff2:	da01      	bge.n	c003ff8 <HAL_FLASH_Unlock+0x50>
      {
        status = HAL_ERROR;
 c003ff4:	2301      	movs	r3, #1
 c003ff6:	71fb      	strb	r3, [r7, #7]
      }
    }
  }
#endif

  return status;
 c003ff8:	79fb      	ldrb	r3, [r7, #7]
}
 c003ffa:	4618      	mov	r0, r3
 c003ffc:	370c      	adds	r7, #12
 c003ffe:	46bd      	mov	sp, r7
 c004000:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004004:	4770      	bx	lr
 c004006:	bf00      	nop
 c004008:	50022000 	.word	0x50022000
 c00400c:	45670123 	.word	0x45670123
 c004010:	cdef89ab 	.word	0xcdef89ab

0c004014 <HAL_FLASH_Lock>:
/**
  * @brief  Lock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 c004014:	b480      	push	{r7}
 c004016:	b083      	sub	sp, #12
 c004018:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_ERROR;
 c00401a:	2301      	movs	r3, #1
 c00401c:	71fb      	strb	r3, [r7, #7]

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c00401e:	4b11      	ldr	r3, [pc, #68]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c004020:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c004022:	4a10      	ldr	r2, [pc, #64]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c004024:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c004028:	6293      	str	r3, [r2, #40]	@ 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c00402a:	4b0e      	ldr	r3, [pc, #56]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c00402c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c00402e:	2b00      	cmp	r3, #0
 c004030:	da01      	bge.n	c004036 <HAL_FLASH_Lock+0x22>
  {
    status = HAL_OK;
 c004032:	2300      	movs	r3, #0
 c004034:	71fb      	strb	r3, [r7, #7]
  }

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if (status == HAL_OK)
 c004036:	79fb      	ldrb	r3, [r7, #7]
 c004038:	2b00      	cmp	r3, #0
 c00403a:	d10b      	bne.n	c004054 <HAL_FLASH_Lock+0x40>
  {
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c00403c:	4b09      	ldr	r3, [pc, #36]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c00403e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c004040:	4a08      	ldr	r2, [pc, #32]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c004042:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c004046:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* verify Flash is locked */
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c004048:	4b06      	ldr	r3, [pc, #24]	@ (c004064 <HAL_FLASH_Lock+0x50>)
 c00404a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c00404c:	2b00      	cmp	r3, #0
 c00404e:	da01      	bge.n	c004054 <HAL_FLASH_Lock+0x40>
    {
      status = HAL_OK;
 c004050:	2300      	movs	r3, #0
 c004052:	71fb      	strb	r3, [r7, #7]
    }
  }
#endif

  return status;
 c004054:	79fb      	ldrb	r3, [r7, #7]
}
 c004056:	4618      	mov	r0, r3
 c004058:	370c      	adds	r7, #12
 c00405a:	46bd      	mov	sp, r7
 c00405c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004060:	4770      	bx	lr
 c004062:	bf00      	nop
 c004064:	50022000 	.word	0x50022000

0c004068 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_SIZ: FLASH Size error
  *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming sequence error
  *            @arg HAL_FLASH_ERROR_OPTW: FLASH Option modification error
  */
uint32_t HAL_FLASH_GetError(void)
{
 c004068:	b480      	push	{r7}
 c00406a:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
 c00406c:	4b03      	ldr	r3, [pc, #12]	@ (c00407c <HAL_FLASH_GetError+0x14>)
 c00406e:	685b      	ldr	r3, [r3, #4]
}
 c004070:	4618      	mov	r0, r3
 c004072:	46bd      	mov	sp, r7
 c004074:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004078:	4770      	bx	lr
 c00407a:	bf00      	nop
 c00407c:	30000024 	.word	0x30000024

0c004080 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 c004080:	b580      	push	{r7, lr}
 c004082:	b086      	sub	sp, #24
 c004084:	af00      	add	r7, sp, #0
 c004086:	6078      	str	r0, [r7, #4]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
 c004088:	f7ff fe18 	bl	c003cbc <HAL_GetTick>
 c00408c:	4602      	mov	r2, r0
 c00408e:	687b      	ldr	r3, [r7, #4]
 c004090:	4413      	add	r3, r2
 c004092:	617b      	str	r3, [r7, #20]
  uint32_t error;
  __IO uint32_t *reg_sr;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c004094:	e00b      	b.n	c0040ae <FLASH_WaitForLastOperation+0x2e>
  {
    if(Timeout != HAL_MAX_DELAY)
 c004096:	687b      	ldr	r3, [r7, #4]
 c004098:	f1b3 3fff 	cmp.w	r3, #4294967295
 c00409c:	d007      	beq.n	c0040ae <FLASH_WaitForLastOperation+0x2e>
    {
      if(HAL_GetTick() >= timeout)
 c00409e:	f7ff fe0d 	bl	c003cbc <HAL_GetTick>
 c0040a2:	4602      	mov	r2, r0
 c0040a4:	697b      	ldr	r3, [r7, #20]
 c0040a6:	4293      	cmp	r3, r2
 c0040a8:	d801      	bhi.n	c0040ae <FLASH_WaitForLastOperation+0x2e>
      {
        return HAL_TIMEOUT;
 c0040aa:	2303      	movs	r3, #3
 c0040ac:	e03a      	b.n	c004124 <FLASH_WaitForLastOperation+0xa4>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c0040ae:	4b1f      	ldr	r3, [pc, #124]	@ (c00412c <FLASH_WaitForLastOperation+0xac>)
 c0040b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0040b2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c0040b6:	2b00      	cmp	r3, #0
 c0040b8:	d1ed      	bne.n	c004096 <FLASH_WaitForLastOperation+0x16>
      }
    }
  }
  
  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c0040ba:	4b1d      	ldr	r3, [pc, #116]	@ (c004130 <FLASH_WaitForLastOperation+0xb0>)
 c0040bc:	689b      	ldr	r3, [r3, #8]
 c0040be:	2b00      	cmp	r3, #0
 c0040c0:	db01      	blt.n	c0040c6 <FLASH_WaitForLastOperation+0x46>
 c0040c2:	4b1c      	ldr	r3, [pc, #112]	@ (c004134 <FLASH_WaitForLastOperation+0xb4>)
 c0040c4:	e000      	b.n	c0040c8 <FLASH_WaitForLastOperation+0x48>
 c0040c6:	4b1c      	ldr	r3, [pc, #112]	@ (c004138 <FLASH_WaitForLastOperation+0xb8>)
 c0040c8:	613b      	str	r3, [r7, #16]

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c0040ca:	693b      	ldr	r3, [r7, #16]
 c0040cc:	681b      	ldr	r3, [r3, #0]
 c0040ce:	f003 03fa 	and.w	r3, r3, #250	@ 0xfa
 c0040d2:	60fb      	str	r3, [r7, #12]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c0040d4:	4b15      	ldr	r3, [pc, #84]	@ (c00412c <FLASH_WaitForLastOperation+0xac>)
 c0040d6:	6a1b      	ldr	r3, [r3, #32]
 c0040d8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 c0040dc:	68fa      	ldr	r2, [r7, #12]
 c0040de:	4313      	orrs	r3, r2
 c0040e0:	60fb      	str	r3, [r7, #12]
#endif /* __ARM_FEATURE_CMSE */ 

  if(error != 0u)
 c0040e2:	68fb      	ldr	r3, [r7, #12]
 c0040e4:	2b00      	cmp	r3, #0
 c0040e6:	d013      	beq.n	c004110 <FLASH_WaitForLastOperation+0x90>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 c0040e8:	4b11      	ldr	r3, [pc, #68]	@ (c004130 <FLASH_WaitForLastOperation+0xb0>)
 c0040ea:	685a      	ldr	r2, [r3, #4]
 c0040ec:	68fb      	ldr	r3, [r7, #12]
 c0040ee:	4313      	orrs	r3, r2
 c0040f0:	4a0f      	ldr	r2, [pc, #60]	@ (c004130 <FLASH_WaitForLastOperation+0xb0>)
 c0040f2:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    (*reg_sr) = error;
 c0040f4:	693b      	ldr	r3, [r7, #16]
 c0040f6:	68fa      	ldr	r2, [r7, #12]
 c0040f8:	601a      	str	r2, [r3, #0]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c0040fa:	68fb      	ldr	r3, [r7, #12]
 c0040fc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 c004100:	2b00      	cmp	r3, #0
 c004102:	d003      	beq.n	c00410c <FLASH_WaitForLastOperation+0x8c>
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c004104:	4b09      	ldr	r3, [pc, #36]	@ (c00412c <FLASH_WaitForLastOperation+0xac>)
 c004106:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 c00410a:	621a      	str	r2, [r3, #32]
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
 c00410c:	2301      	movs	r3, #1
 c00410e:	e009      	b.n	c004124 <FLASH_WaitForLastOperation+0xa4>
  }

  /* Check FLASH End of Operation flag  */
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c004110:	693b      	ldr	r3, [r7, #16]
 c004112:	681b      	ldr	r3, [r3, #0]
 c004114:	f003 0301 	and.w	r3, r3, #1
 c004118:	2b00      	cmp	r3, #0
 c00411a:	d002      	beq.n	c004122 <FLASH_WaitForLastOperation+0xa2>
  {
    /* Clear FLASH End of Operation pending bit */
    (*reg_sr) = FLASH_FLAG_EOP;
 c00411c:	693b      	ldr	r3, [r7, #16]
 c00411e:	2201      	movs	r2, #1
 c004120:	601a      	str	r2, [r3, #0]
  }

  /* If there is an error flag set */
  return HAL_OK;
 c004122:	2300      	movs	r3, #0
}
 c004124:	4618      	mov	r0, r3
 c004126:	3718      	adds	r7, #24
 c004128:	46bd      	mov	sp, r7
 c00412a:	bd80      	pop	{r7, pc}
 c00412c:	50022000 	.word	0x50022000
 c004130:	30000024 	.word	0x30000024
 c004134:	50022024 	.word	0x50022024
 c004138:	40022020 	.word	0x40022020

0c00413c <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 c00413c:	b480      	push	{r7}
 c00413e:	b089      	sub	sp, #36	@ 0x24
 c004140:	af00      	add	r7, sp, #0
 c004142:	60f8      	str	r0, [r7, #12]
 c004144:	e9c7 2300 	strd	r2, r3, [r7]
  __IO uint32_t *reg;
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c004148:	4b19      	ldr	r3, [pc, #100]	@ (c0041b0 <FLASH_Program_DoubleWord+0x74>)
 c00414a:	689b      	ldr	r3, [r3, #8]
 c00414c:	2b00      	cmp	r3, #0
 c00414e:	db01      	blt.n	c004154 <FLASH_Program_DoubleWord+0x18>
 c004150:	4b18      	ldr	r3, [pc, #96]	@ (c0041b4 <FLASH_Program_DoubleWord+0x78>)
 c004152:	e000      	b.n	c004156 <FLASH_Program_DoubleWord+0x1a>
 c004154:	4b18      	ldr	r3, [pc, #96]	@ (c0041b8 <FLASH_Program_DoubleWord+0x7c>)
 c004156:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c004158:	f3ef 8310 	mrs	r3, PRIMASK
 c00415c:	613b      	str	r3, [r7, #16]
  return(result);
 c00415e:	693b      	ldr	r3, [r7, #16]

  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
 c004160:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 c004162:	b672      	cpsid	i
}
 c004164:	bf00      	nop
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 c004166:	69fb      	ldr	r3, [r7, #28]
 c004168:	681b      	ldr	r3, [r3, #0]
 c00416a:	f043 0201 	orr.w	r2, r3, #1
 c00416e:	69fb      	ldr	r3, [r7, #28]
 c004170:	601a      	str	r2, [r3, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 c004172:	68fb      	ldr	r3, [r7, #12]
 c004174:	683a      	ldr	r2, [r7, #0]
 c004176:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c004178:	f3bf 8f6f 	isb	sy
}
 c00417c:	bf00      	nop
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 c00417e:	e9d7 0100 	ldrd	r0, r1, [r7]
 c004182:	f04f 0200 	mov.w	r2, #0
 c004186:	f04f 0300 	mov.w	r3, #0
 c00418a:	000a      	movs	r2, r1
 c00418c:	2300      	movs	r3, #0
 c00418e:	68f9      	ldr	r1, [r7, #12]
 c004190:	3104      	adds	r1, #4
 c004192:	4613      	mov	r3, r2
 c004194:	600b      	str	r3, [r1, #0]
 c004196:	69bb      	ldr	r3, [r7, #24]
 c004198:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c00419a:	697b      	ldr	r3, [r7, #20]
 c00419c:	f383 8810 	msr	PRIMASK, r3
}
 c0041a0:	bf00      	nop

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 c0041a2:	bf00      	nop
 c0041a4:	3724      	adds	r7, #36	@ 0x24
 c0041a6:	46bd      	mov	sp, r7
 c0041a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0041ac:	4770      	bx	lr
 c0041ae:	bf00      	nop
 c0041b0:	30000024 	.word	0x30000024
 c0041b4:	5002202c 	.word	0x5002202c
 c0041b8:	40022028 	.word	0x40022028

0c0041bc <HAL_FLASHEx_Erase>:
  *         the pages have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 c0041bc:	b580      	push	{r7, lr}
 c0041be:	b086      	sub	sp, #24
 c0041c0:	af00      	add	r7, sp, #0
 c0041c2:	6078      	str	r0, [r7, #4]
 c0041c4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 c0041c6:	4b36      	ldr	r3, [pc, #216]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c0041c8:	781b      	ldrb	r3, [r3, #0]
 c0041ca:	2b01      	cmp	r3, #1
 c0041cc:	d101      	bne.n	c0041d2 <HAL_FLASHEx_Erase+0x16>
 c0041ce:	2302      	movs	r3, #2
 c0041d0:	e062      	b.n	c004298 <HAL_FLASHEx_Erase+0xdc>
 c0041d2:	4b33      	ldr	r3, [pc, #204]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c0041d4:	2201      	movs	r2, #1
 c0041d6:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0041d8:	4b31      	ldr	r3, [pc, #196]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c0041da:	2200      	movs	r2, #0
 c0041dc:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0041de:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c0041e2:	f7ff ff4d 	bl	c004080 <FLASH_WaitForLastOperation>
 c0041e6:	4603      	mov	r3, r0
 c0041e8:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
 c0041ea:	7dfb      	ldrb	r3, [r7, #23]
 c0041ec:	2b00      	cmp	r3, #0
 c0041ee:	d14f      	bne.n	c004290 <HAL_FLASHEx_Erase+0xd4>
  {
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0041f0:	687b      	ldr	r3, [r7, #4]
 c0041f2:	681b      	ldr	r3, [r3, #0]
 c0041f4:	4a2a      	ldr	r2, [pc, #168]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c0041f6:	6093      	str	r3, [r2, #8]

    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0041f8:	4b29      	ldr	r3, [pc, #164]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c0041fa:	689b      	ldr	r3, [r3, #8]
 c0041fc:	2b00      	cmp	r3, #0
 c0041fe:	db01      	blt.n	c004204 <HAL_FLASHEx_Erase+0x48>
 c004200:	4b28      	ldr	r3, [pc, #160]	@ (c0042a4 <HAL_FLASHEx_Erase+0xe8>)
 c004202:	e000      	b.n	c004206 <HAL_FLASHEx_Erase+0x4a>
 c004204:	4b28      	ldr	r3, [pc, #160]	@ (c0042a8 <HAL_FLASHEx_Erase+0xec>)
 c004206:	60fb      	str	r3, [r7, #12]

    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c004208:	4b25      	ldr	r3, [pc, #148]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c00420a:	689b      	ldr	r3, [r3, #8]
 c00420c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c004210:	f248 0204 	movw	r2, #32772	@ 0x8004
 c004214:	4293      	cmp	r3, r2
 c004216:	d10b      	bne.n	c004230 <HAL_FLASHEx_Erase+0x74>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);
 c004218:	687b      	ldr	r3, [r7, #4]
 c00421a:	685b      	ldr	r3, [r3, #4]
 c00421c:	4618      	mov	r0, r3
 c00421e:	f000 f8bd 	bl	c00439c <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c004222:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c004226:	f7ff ff2b 	bl	c004080 <FLASH_WaitForLastOperation>
 c00422a:	4603      	mov	r3, r0
 c00422c:	75fb      	strb	r3, [r7, #23]
 c00422e:	e025      	b.n	c00427c <HAL_FLASHEx_Erase+0xc0>
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFFU;
 c004230:	683b      	ldr	r3, [r7, #0]
 c004232:	f04f 32ff 	mov.w	r2, #4294967295
 c004236:	601a      	str	r2, [r3, #0]

      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c004238:	687b      	ldr	r3, [r7, #4]
 c00423a:	689b      	ldr	r3, [r3, #8]
 c00423c:	613b      	str	r3, [r7, #16]
 c00423e:	e015      	b.n	c00426c <HAL_FLASHEx_Erase+0xb0>
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c004240:	687b      	ldr	r3, [r7, #4]
 c004242:	685b      	ldr	r3, [r3, #4]
 c004244:	4619      	mov	r1, r3
 c004246:	6938      	ldr	r0, [r7, #16]
 c004248:	f000 f8fa 	bl	c004440 <FLASH_PageErase>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c00424c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c004250:	f7ff ff16 	bl	c004080 <FLASH_WaitForLastOperation>
 c004254:	4603      	mov	r3, r0
 c004256:	75fb      	strb	r3, [r7, #23]

        if (status != HAL_OK)
 c004258:	7dfb      	ldrb	r3, [r7, #23]
 c00425a:	2b00      	cmp	r3, #0
 c00425c:	d003      	beq.n	c004266 <HAL_FLASHEx_Erase+0xaa>
        {
          /* In case of error, stop erase procedure and return the faulty page */
          *PageError = page_index;
 c00425e:	683b      	ldr	r3, [r7, #0]
 c004260:	693a      	ldr	r2, [r7, #16]
 c004262:	601a      	str	r2, [r3, #0]
          break;
 c004264:	e00a      	b.n	c00427c <HAL_FLASHEx_Erase+0xc0>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c004266:	693b      	ldr	r3, [r7, #16]
 c004268:	3301      	adds	r3, #1
 c00426a:	613b      	str	r3, [r7, #16]
 c00426c:	687b      	ldr	r3, [r7, #4]
 c00426e:	689a      	ldr	r2, [r3, #8]
 c004270:	687b      	ldr	r3, [r7, #4]
 c004272:	68db      	ldr	r3, [r3, #12]
 c004274:	4413      	add	r3, r2
 c004276:	693a      	ldr	r2, [r7, #16]
 c004278:	429a      	cmp	r2, r3
 c00427a:	d3e1      	bcc.n	c004240 <HAL_FLASHEx_Erase+0x84>
        }
      }
    }

    /* If the erase operation is completed, disable the associated bits */
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c00427c:	68fb      	ldr	r3, [r7, #12]
 c00427e:	681a      	ldr	r2, [r3, #0]
 c004280:	4b07      	ldr	r3, [pc, #28]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c004282:	689b      	ldr	r3, [r3, #8]
 c004284:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c004288:	43db      	mvns	r3, r3
 c00428a:	401a      	ands	r2, r3
 c00428c:	68fb      	ldr	r3, [r7, #12]
 c00428e:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c004290:	4b03      	ldr	r3, [pc, #12]	@ (c0042a0 <HAL_FLASHEx_Erase+0xe4>)
 c004292:	2200      	movs	r2, #0
 c004294:	701a      	strb	r2, [r3, #0]

  return status;
 c004296:	7dfb      	ldrb	r3, [r7, #23]
}
 c004298:	4618      	mov	r0, r3
 c00429a:	3718      	adds	r7, #24
 c00429c:	46bd      	mov	sp, r7
 c00429e:	bd80      	pop	{r7, pc}
 c0042a0:	30000024 	.word	0x30000024
 c0042a4:	5002202c 	.word	0x5002202c
 c0042a8:	40022028 	.word	0x40022028

0c0042ac <HAL_FLASHEx_ConfigBBAttributes>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_ConfigBBAttributes(FLASH_BBAttributesTypeDef *pBBAttributes)
{
 c0042ac:	b580      	push	{r7, lr}
 c0042ae:	b084      	sub	sp, #16
 c0042b0:	af00      	add	r7, sp, #0
 c0042b2:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pBBAttributes->Bank));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0042b4:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c0042b8:	f7ff fee2 	bl	c004080 <FLASH_WaitForLastOperation>
 c0042bc:	4603      	mov	r3, r0
 c0042be:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
 c0042c0:	7bfb      	ldrb	r3, [r7, #15]
 c0042c2:	2b00      	cmp	r3, #0
 c0042c4:	d12d      	bne.n	c004322 <HAL_FLASHEx_ConfigBBAttributes+0x76>
  {
    if (pBBAttributes->BBAttributesType == FLASH_BB_SEC)
 c0042c6:	687b      	ldr	r3, [r7, #4]
 c0042c8:	685b      	ldr	r3, [r3, #4]
 c0042ca:	2b01      	cmp	r3, #1
 c0042cc:	d126      	bne.n	c00431c <HAL_FLASHEx_ConfigBBAttributes+0x70>
    {
      if (pBBAttributes->Bank == FLASH_BANK_1)
 c0042ce:	687b      	ldr	r3, [r7, #4]
 c0042d0:	681b      	ldr	r3, [r3, #0]
 c0042d2:	2b01      	cmp	r3, #1
 c0042d4:	d102      	bne.n	c0042dc <HAL_FLASHEx_ConfigBBAttributes+0x30>
      {
        reg = &(FLASH->SECBB1R1);
 c0042d6:	4b17      	ldr	r3, [pc, #92]	@ (c004334 <HAL_FLASHEx_ConfigBBAttributes+0x88>)
 c0042d8:	60bb      	str	r3, [r7, #8]
 c0042da:	e001      	b.n	c0042e0 <HAL_FLASHEx_ConfigBBAttributes+0x34>
      }
      else
      {
        reg = &(FLASH->SECBB2R1);
 c0042dc:	4b16      	ldr	r3, [pc, #88]	@ (c004338 <HAL_FLASHEx_ConfigBBAttributes+0x8c>)
 c0042de:	60bb      	str	r3, [r7, #8]
      }

      /* Modify the register values and check that new attributes are taken in account */
      for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c0042e0:	2300      	movs	r3, #0
 c0042e2:	73bb      	strb	r3, [r7, #14]
 c0042e4:	e017      	b.n	c004316 <HAL_FLASHEx_ConfigBBAttributes+0x6a>
      {
        *reg = pBBAttributes->BBAttributes_array[index];
 c0042e6:	7bba      	ldrb	r2, [r7, #14]
 c0042e8:	687b      	ldr	r3, [r7, #4]
 c0042ea:	3202      	adds	r2, #2
 c0042ec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c0042f0:	68bb      	ldr	r3, [r7, #8]
 c0042f2:	601a      	str	r2, [r3, #0]
        if (*reg != pBBAttributes->BBAttributes_array[index])
 c0042f4:	68bb      	ldr	r3, [r7, #8]
 c0042f6:	681a      	ldr	r2, [r3, #0]
 c0042f8:	7bb9      	ldrb	r1, [r7, #14]
 c0042fa:	687b      	ldr	r3, [r7, #4]
 c0042fc:	3102      	adds	r1, #2
 c0042fe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c004302:	429a      	cmp	r2, r3
 c004304:	d001      	beq.n	c00430a <HAL_FLASHEx_ConfigBBAttributes+0x5e>
        {
          status = HAL_ERROR;
 c004306:	2301      	movs	r3, #1
 c004308:	73fb      	strb	r3, [r7, #15]
        }
        reg++;
 c00430a:	68bb      	ldr	r3, [r7, #8]
 c00430c:	3304      	adds	r3, #4
 c00430e:	60bb      	str	r3, [r7, #8]
      for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c004310:	7bbb      	ldrb	r3, [r7, #14]
 c004312:	3301      	adds	r3, #1
 c004314:	73bb      	strb	r3, [r7, #14]
 c004316:	7bbb      	ldrb	r3, [r7, #14]
 c004318:	2b03      	cmp	r3, #3
 c00431a:	d9e4      	bls.n	c0042e6 <HAL_FLASHEx_ConfigBBAttributes+0x3a>
  __ASM volatile ("isb 0xF":::"memory");
 c00431c:	f3bf 8f6f 	isb	sy
}
 c004320:	bf00      	nop
    /* ISB instruction is called to be sure next instructions are performed with correct attributes */
    __ISB();
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c004322:	4b06      	ldr	r3, [pc, #24]	@ (c00433c <HAL_FLASHEx_ConfigBBAttributes+0x90>)
 c004324:	2200      	movs	r2, #0
 c004326:	701a      	strb	r2, [r3, #0]

  return status;
 c004328:	7bfb      	ldrb	r3, [r7, #15]
}
 c00432a:	4618      	mov	r0, r3
 c00432c:	3710      	adds	r7, #16
 c00432e:	46bd      	mov	sp, r7
 c004330:	bd80      	pop	{r7, pc}
 c004332:	bf00      	nop
 c004334:	50022080 	.word	0x50022080
 c004338:	500220a0 	.word	0x500220a0
 c00433c:	30000024 	.word	0x30000024

0c004340 <HAL_FLASHEx_GetConfigBBAttributes>:
  *          for the block-based security, else no information will be returned
  *
  * @retval None
  */
void HAL_FLASHEx_GetConfigBBAttributes(FLASH_BBAttributesTypeDef *pBBAttributes)
{
 c004340:	b480      	push	{r7}
 c004342:	b085      	sub	sp, #20
 c004344:	af00      	add	r7, sp, #0
 c004346:	6078      	str	r0, [r7, #4]
  __IO uint32_t *reg;

  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pBBAttributes->Bank));

  if (pBBAttributes->BBAttributesType == FLASH_BB_SEC)
 c004348:	687b      	ldr	r3, [r7, #4]
 c00434a:	685b      	ldr	r3, [r3, #4]
 c00434c:	2b01      	cmp	r3, #1
 c00434e:	d11b      	bne.n	c004388 <HAL_FLASHEx_GetConfigBBAttributes+0x48>
  {
    if (pBBAttributes->Bank == FLASH_BANK_1)
 c004350:	687b      	ldr	r3, [r7, #4]
 c004352:	681b      	ldr	r3, [r3, #0]
 c004354:	2b01      	cmp	r3, #1
 c004356:	d102      	bne.n	c00435e <HAL_FLASHEx_GetConfigBBAttributes+0x1e>
    {
      reg = &(FLASH->SECBB1R1);
 c004358:	4b0e      	ldr	r3, [pc, #56]	@ (c004394 <HAL_FLASHEx_GetConfigBBAttributes+0x54>)
 c00435a:	60bb      	str	r3, [r7, #8]
 c00435c:	e001      	b.n	c004362 <HAL_FLASHEx_GetConfigBBAttributes+0x22>
    }
    else
    {
      reg = &(FLASH->SECBB2R1);
 c00435e:	4b0e      	ldr	r3, [pc, #56]	@ (c004398 <HAL_FLASHEx_GetConfigBBAttributes+0x58>)
 c004360:	60bb      	str	r3, [r7, #8]
    }

    for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c004362:	2300      	movs	r3, #0
 c004364:	73fb      	strb	r3, [r7, #15]
 c004366:	e00c      	b.n	c004382 <HAL_FLASHEx_GetConfigBBAttributes+0x42>
    {
      pBBAttributes->BBAttributes_array[index] = *reg;
 c004368:	7bfa      	ldrb	r2, [r7, #15]
 c00436a:	68bb      	ldr	r3, [r7, #8]
 c00436c:	6819      	ldr	r1, [r3, #0]
 c00436e:	687b      	ldr	r3, [r7, #4]
 c004370:	3202      	adds	r2, #2
 c004372:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      reg++;
 c004376:	68bb      	ldr	r3, [r7, #8]
 c004378:	3304      	adds	r3, #4
 c00437a:	60bb      	str	r3, [r7, #8]
    for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c00437c:	7bfb      	ldrb	r3, [r7, #15]
 c00437e:	3301      	adds	r3, #1
 c004380:	73fb      	strb	r3, [r7, #15]
 c004382:	7bfb      	ldrb	r3, [r7, #15]
 c004384:	2b03      	cmp	r3, #3
 c004386:	d9ef      	bls.n	c004368 <HAL_FLASHEx_GetConfigBBAttributes+0x28>
    }
  }
}
 c004388:	bf00      	nop
 c00438a:	3714      	adds	r7, #20
 c00438c:	46bd      	mov	sp, r7
 c00438e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004392:	4770      	bx	lr
 c004394:	50022080 	.word	0x50022080
 c004398:	500220a0 	.word	0x500220a0

0c00439c <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 c00439c:	b480      	push	{r7}
 c00439e:	b087      	sub	sp, #28
 c0043a0:	af00      	add	r7, sp, #0
 c0043a2:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c0043a4:	f3ef 8310 	mrs	r3, PRIMASK
 c0043a8:	60fb      	str	r3, [r7, #12]
  return(result);
 c0043aa:	68fb      	ldr	r3, [r7, #12]
  
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  uint32_t primask_bit;

  /* Disable interrupts to avoid any interruption */
  primask_bit = __get_PRIMASK();
 c0043ac:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 c0043ae:	b672      	cpsid	i
}
 c0043b0:	bf00      	nop
  __disable_irq();
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0043b2:	4b1f      	ldr	r3, [pc, #124]	@ (c004430 <FLASH_MassErase+0x94>)
 c0043b4:	689b      	ldr	r3, [r3, #8]
 c0043b6:	2b00      	cmp	r3, #0
 c0043b8:	db01      	blt.n	c0043be <FLASH_MassErase+0x22>
 c0043ba:	4b1e      	ldr	r3, [pc, #120]	@ (c004434 <FLASH_MassErase+0x98>)
 c0043bc:	e000      	b.n	c0043c0 <FLASH_MassErase+0x24>
 c0043be:	4b1e      	ldr	r3, [pc, #120]	@ (c004438 <FLASH_MassErase+0x9c>)
 c0043c0:	613b      	str	r3, [r7, #16]

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 c0043c2:	4b1e      	ldr	r3, [pc, #120]	@ (c00443c <FLASH_MassErase+0xa0>)
 c0043c4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 c0043c6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c0043ca:	2b00      	cmp	r3, #0
 c0043cc:	d016      	beq.n	c0043fc <FLASH_MassErase+0x60>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 c0043ce:	687b      	ldr	r3, [r7, #4]
 c0043d0:	f003 0301 	and.w	r3, r3, #1
 c0043d4:	2b00      	cmp	r3, #0
 c0043d6:	d005      	beq.n	c0043e4 <FLASH_MassErase+0x48>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 c0043d8:	693b      	ldr	r3, [r7, #16]
 c0043da:	681b      	ldr	r3, [r3, #0]
 c0043dc:	f043 0204 	orr.w	r2, r3, #4
 c0043e0:	693b      	ldr	r3, [r7, #16]
 c0043e2:	601a      	str	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 c0043e4:	687b      	ldr	r3, [r7, #4]
 c0043e6:	f003 0302 	and.w	r3, r3, #2
 c0043ea:	2b00      	cmp	r3, #0
 c0043ec:	d00e      	beq.n	c00440c <FLASH_MassErase+0x70>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 c0043ee:	693b      	ldr	r3, [r7, #16]
 c0043f0:	681b      	ldr	r3, [r3, #0]
 c0043f2:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
 c0043f6:	693b      	ldr	r3, [r7, #16]
 c0043f8:	601a      	str	r2, [r3, #0]
 c0043fa:	e007      	b.n	c00440c <FLASH_MassErase+0x70>
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c0043fc:	693b      	ldr	r3, [r7, #16]
 c0043fe:	681b      	ldr	r3, [r3, #0]
 c004400:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 c004404:	f043 0304 	orr.w	r3, r3, #4
 c004408:	693a      	ldr	r2, [r7, #16]
 c00440a:	6013      	str	r3, [r2, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c00440c:	693b      	ldr	r3, [r7, #16]
 c00440e:	681b      	ldr	r3, [r3, #0]
 c004410:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 c004414:	693b      	ldr	r3, [r7, #16]
 c004416:	601a      	str	r2, [r3, #0]
 c004418:	697b      	ldr	r3, [r7, #20]
 c00441a:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c00441c:	68bb      	ldr	r3, [r7, #8]
 c00441e:	f383 8810 	msr	PRIMASK, r3
}
 c004422:	bf00      	nop

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c004424:	bf00      	nop
 c004426:	371c      	adds	r7, #28
 c004428:	46bd      	mov	sp, r7
 c00442a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00442e:	4770      	bx	lr
 c004430:	30000024 	.word	0x30000024
 c004434:	5002202c 	.word	0x5002202c
 c004438:	40022028 	.word	0x40022028
 c00443c:	50022000 	.word	0x50022000

0c004440 <FLASH_PageErase>:
  *            @arg FLASH_BANK_1: Page in bank 1 to be erased
  *            @arg FLASH_BANK_2: Page in bank 2 to be erased
  * @retval None
  */
void FLASH_PageErase(uint32_t Page, uint32_t Banks)
{
 c004440:	b480      	push	{r7}
 c004442:	b087      	sub	sp, #28
 c004444:	af00      	add	r7, sp, #0
 c004446:	6078      	str	r0, [r7, #4]
 c004448:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c00444a:	f3ef 8310 	mrs	r3, PRIMASK
 c00444e:	60fb      	str	r3, [r7, #12]
  return(result);
 c004450:	68fb      	ldr	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Disable interrupts to avoid any interruption */
  primask_bit = __get_PRIMASK();
 c004452:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 c004454:	b672      	cpsid	i
}
 c004456:	bf00      	nop
  __disable_irq();
#endif

  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c004458:	4b22      	ldr	r3, [pc, #136]	@ (c0044e4 <FLASH_PageErase+0xa4>)
 c00445a:	689b      	ldr	r3, [r3, #8]
 c00445c:	2b00      	cmp	r3, #0
 c00445e:	db01      	blt.n	c004464 <FLASH_PageErase+0x24>
 c004460:	4b21      	ldr	r3, [pc, #132]	@ (c0044e8 <FLASH_PageErase+0xa8>)
 c004462:	e000      	b.n	c004466 <FLASH_PageErase+0x26>
 c004464:	4b21      	ldr	r3, [pc, #132]	@ (c0044ec <FLASH_PageErase+0xac>)
 c004466:	613b      	str	r3, [r7, #16]

  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c004468:	4b21      	ldr	r3, [pc, #132]	@ (c0044f0 <FLASH_PageErase+0xb0>)
 c00446a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 c00446c:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c004470:	2b00      	cmp	r3, #0
 c004472:	d106      	bne.n	c004482 <FLASH_PageErase+0x42>
  {
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c004474:	693b      	ldr	r3, [r7, #16]
 c004476:	681b      	ldr	r3, [r3, #0]
 c004478:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 c00447c:	693b      	ldr	r3, [r7, #16]
 c00447e:	601a      	str	r2, [r3, #0]
 c004480:	e011      	b.n	c0044a6 <FLASH_PageErase+0x66>
  }
  else
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
 c004482:	683b      	ldr	r3, [r7, #0]
 c004484:	f003 0301 	and.w	r3, r3, #1
 c004488:	2b00      	cmp	r3, #0
 c00448a:	d006      	beq.n	c00449a <FLASH_PageErase+0x5a>
    {
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c00448c:	693b      	ldr	r3, [r7, #16]
 c00448e:	681b      	ldr	r3, [r3, #0]
 c004490:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 c004494:	693b      	ldr	r3, [r7, #16]
 c004496:	601a      	str	r2, [r3, #0]
 c004498:	e005      	b.n	c0044a6 <FLASH_PageErase+0x66>
    }
    else
    {
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c00449a:	693b      	ldr	r3, [r7, #16]
 c00449c:	681b      	ldr	r3, [r3, #0]
 c00449e:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
 c0044a2:	693b      	ldr	r3, [r7, #16]
 c0044a4:	601a      	str	r2, [r3, #0]
    }
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 c0044a6:	693b      	ldr	r3, [r7, #16]
 c0044a8:	681b      	ldr	r3, [r3, #0]
 c0044aa:	f423 737e 	bic.w	r3, r3, #1016	@ 0x3f8
 c0044ae:	f023 0302 	bic.w	r3, r3, #2
 c0044b2:	687a      	ldr	r2, [r7, #4]
 c0044b4:	00d2      	lsls	r2, r2, #3
 c0044b6:	4313      	orrs	r3, r2
 c0044b8:	f043 0202 	orr.w	r2, r3, #2
 c0044bc:	693b      	ldr	r3, [r7, #16]
 c0044be:	601a      	str	r2, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c0044c0:	693b      	ldr	r3, [r7, #16]
 c0044c2:	681b      	ldr	r3, [r3, #0]
 c0044c4:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 c0044c8:	693b      	ldr	r3, [r7, #16]
 c0044ca:	601a      	str	r2, [r3, #0]
 c0044cc:	697b      	ldr	r3, [r7, #20]
 c0044ce:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c0044d0:	68bb      	ldr	r3, [r7, #8]
 c0044d2:	f383 8810 	msr	PRIMASK, r3
}
 c0044d6:	bf00      	nop

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c0044d8:	bf00      	nop
 c0044da:	371c      	adds	r7, #28
 c0044dc:	46bd      	mov	sp, r7
 c0044de:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0044e2:	4770      	bx	lr
 c0044e4:	30000024 	.word	0x30000024
 c0044e8:	5002202c 	.word	0x5002202c
 c0044ec:	40022028 	.word	0x40022028
 c0044f0:	50022000 	.word	0x50022000

0c0044f4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 c0044f4:	b480      	push	{r7}
 c0044f6:	b087      	sub	sp, #28
 c0044f8:	af00      	add	r7, sp, #0
 c0044fa:	6078      	str	r0, [r7, #4]
 c0044fc:	6039      	str	r1, [r7, #0]
  uint32_t position = 0U;
 c0044fe:	2300      	movs	r3, #0
 c004500:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 c004502:	e158      	b.n	c0047b6 <HAL_GPIO_Init+0x2c2>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 c004504:	683b      	ldr	r3, [r7, #0]
 c004506:	681a      	ldr	r2, [r3, #0]
 c004508:	2101      	movs	r1, #1
 c00450a:	697b      	ldr	r3, [r7, #20]
 c00450c:	fa01 f303 	lsl.w	r3, r1, r3
 c004510:	4013      	ands	r3, r2
 c004512:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0U)
 c004514:	68fb      	ldr	r3, [r7, #12]
 c004516:	2b00      	cmp	r3, #0
 c004518:	f000 814a 	beq.w	c0047b0 <HAL_GPIO_Init+0x2bc>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 c00451c:	683b      	ldr	r3, [r7, #0]
 c00451e:	685b      	ldr	r3, [r3, #4]
 c004520:	f003 0303 	and.w	r3, r3, #3
 c004524:	2b01      	cmp	r3, #1
 c004526:	d005      	beq.n	c004534 <HAL_GPIO_Init+0x40>
 c004528:	683b      	ldr	r3, [r7, #0]
 c00452a:	685b      	ldr	r3, [r3, #4]
 c00452c:	f003 0303 	and.w	r3, r3, #3
 c004530:	2b02      	cmp	r3, #2
 c004532:	d130      	bne.n	c004596 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 c004534:	687b      	ldr	r3, [r7, #4]
 c004536:	689b      	ldr	r3, [r3, #8]
 c004538:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00453a:	697b      	ldr	r3, [r7, #20]
 c00453c:	005b      	lsls	r3, r3, #1
 c00453e:	2203      	movs	r2, #3
 c004540:	fa02 f303 	lsl.w	r3, r2, r3
 c004544:	43db      	mvns	r3, r3
 c004546:	693a      	ldr	r2, [r7, #16]
 c004548:	4013      	ands	r3, r2
 c00454a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 c00454c:	683b      	ldr	r3, [r7, #0]
 c00454e:	68da      	ldr	r2, [r3, #12]
 c004550:	697b      	ldr	r3, [r7, #20]
 c004552:	005b      	lsls	r3, r3, #1
 c004554:	fa02 f303 	lsl.w	r3, r2, r3
 c004558:	693a      	ldr	r2, [r7, #16]
 c00455a:	4313      	orrs	r3, r2
 c00455c:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 c00455e:	687b      	ldr	r3, [r7, #4]
 c004560:	693a      	ldr	r2, [r7, #16]
 c004562:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 c004564:	687b      	ldr	r3, [r7, #4]
 c004566:	685b      	ldr	r3, [r3, #4]
 c004568:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 c00456a:	2201      	movs	r2, #1
 c00456c:	697b      	ldr	r3, [r7, #20]
 c00456e:	fa02 f303 	lsl.w	r3, r2, r3
 c004572:	43db      	mvns	r3, r3
 c004574:	693a      	ldr	r2, [r7, #16]
 c004576:	4013      	ands	r3, r2
 c004578:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 c00457a:	683b      	ldr	r3, [r7, #0]
 c00457c:	685b      	ldr	r3, [r3, #4]
 c00457e:	091b      	lsrs	r3, r3, #4
 c004580:	f003 0201 	and.w	r2, r3, #1
 c004584:	697b      	ldr	r3, [r7, #20]
 c004586:	fa02 f303 	lsl.w	r3, r2, r3
 c00458a:	693a      	ldr	r2, [r7, #16]
 c00458c:	4313      	orrs	r3, r2
 c00458e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 c004590:	687b      	ldr	r3, [r7, #4]
 c004592:	693a      	ldr	r2, [r7, #16]
 c004594:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 c004596:	683b      	ldr	r3, [r7, #0]
 c004598:	685b      	ldr	r3, [r3, #4]
 c00459a:	f003 0303 	and.w	r3, r3, #3
 c00459e:	2b03      	cmp	r3, #3
 c0045a0:	d017      	beq.n	c0045d2 <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        temp = GPIOx->PUPDR;
 c0045a2:	687b      	ldr	r3, [r7, #4]
 c0045a4:	68db      	ldr	r3, [r3, #12]
 c0045a6:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c0045a8:	697b      	ldr	r3, [r7, #20]
 c0045aa:	005b      	lsls	r3, r3, #1
 c0045ac:	2203      	movs	r2, #3
 c0045ae:	fa02 f303 	lsl.w	r3, r2, r3
 c0045b2:	43db      	mvns	r3, r3
 c0045b4:	693a      	ldr	r2, [r7, #16]
 c0045b6:	4013      	ands	r3, r2
 c0045b8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 c0045ba:	683b      	ldr	r3, [r7, #0]
 c0045bc:	689a      	ldr	r2, [r3, #8]
 c0045be:	697b      	ldr	r3, [r7, #20]
 c0045c0:	005b      	lsls	r3, r3, #1
 c0045c2:	fa02 f303 	lsl.w	r3, r2, r3
 c0045c6:	693a      	ldr	r2, [r7, #16]
 c0045c8:	4313      	orrs	r3, r2
 c0045ca:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 c0045cc:	687b      	ldr	r3, [r7, #4]
 c0045ce:	693a      	ldr	r2, [r7, #16]
 c0045d0:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 c0045d2:	683b      	ldr	r3, [r7, #0]
 c0045d4:	685b      	ldr	r3, [r3, #4]
 c0045d6:	f003 0303 	and.w	r3, r3, #3
 c0045da:	2b02      	cmp	r3, #2
 c0045dc:	d123      	bne.n	c004626 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 c0045de:	697b      	ldr	r3, [r7, #20]
 c0045e0:	08da      	lsrs	r2, r3, #3
 c0045e2:	687b      	ldr	r3, [r7, #4]
 c0045e4:	3208      	adds	r2, #8
 c0045e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0045ea:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0045ec:	697b      	ldr	r3, [r7, #20]
 c0045ee:	f003 0307 	and.w	r3, r3, #7
 c0045f2:	009b      	lsls	r3, r3, #2
 c0045f4:	220f      	movs	r2, #15
 c0045f6:	fa02 f303 	lsl.w	r3, r2, r3
 c0045fa:	43db      	mvns	r3, r3
 c0045fc:	693a      	ldr	r2, [r7, #16]
 c0045fe:	4013      	ands	r3, r2
 c004600:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 c004602:	683b      	ldr	r3, [r7, #0]
 c004604:	691a      	ldr	r2, [r3, #16]
 c004606:	697b      	ldr	r3, [r7, #20]
 c004608:	f003 0307 	and.w	r3, r3, #7
 c00460c:	009b      	lsls	r3, r3, #2
 c00460e:	fa02 f303 	lsl.w	r3, r2, r3
 c004612:	693a      	ldr	r2, [r7, #16]
 c004614:	4313      	orrs	r3, r2
 c004616:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 c004618:	697b      	ldr	r3, [r7, #20]
 c00461a:	08da      	lsrs	r2, r3, #3
 c00461c:	687b      	ldr	r3, [r7, #4]
 c00461e:	3208      	adds	r2, #8
 c004620:	6939      	ldr	r1, [r7, #16]
 c004622:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 c004626:	687b      	ldr	r3, [r7, #4]
 c004628:	681b      	ldr	r3, [r3, #0]
 c00462a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 c00462c:	697b      	ldr	r3, [r7, #20]
 c00462e:	005b      	lsls	r3, r3, #1
 c004630:	2203      	movs	r2, #3
 c004632:	fa02 f303 	lsl.w	r3, r2, r3
 c004636:	43db      	mvns	r3, r3
 c004638:	693a      	ldr	r2, [r7, #16]
 c00463a:	4013      	ands	r3, r2
 c00463c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 c00463e:	683b      	ldr	r3, [r7, #0]
 c004640:	685b      	ldr	r3, [r3, #4]
 c004642:	f003 0203 	and.w	r2, r3, #3
 c004646:	697b      	ldr	r3, [r7, #20]
 c004648:	005b      	lsls	r3, r3, #1
 c00464a:	fa02 f303 	lsl.w	r3, r2, r3
 c00464e:	693a      	ldr	r2, [r7, #16]
 c004650:	4313      	orrs	r3, r2
 c004652:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 c004654:	687b      	ldr	r3, [r7, #4]
 c004656:	693a      	ldr	r2, [r7, #16]
 c004658:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 c00465a:	683b      	ldr	r3, [r7, #0]
 c00465c:	685b      	ldr	r3, [r3, #4]
 c00465e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 c004662:	2b00      	cmp	r3, #0
 c004664:	f000 80a4 	beq.w	c0047b0 <HAL_GPIO_Init+0x2bc>
      {
        temp = EXTI->EXTICR[position >> 2U];
 c004668:	4a5a      	ldr	r2, [pc, #360]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c00466a:	697b      	ldr	r3, [r7, #20]
 c00466c:	089b      	lsrs	r3, r3, #2
 c00466e:	3318      	adds	r3, #24
 c004670:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c004674:	613b      	str	r3, [r7, #16]
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c004676:	697b      	ldr	r3, [r7, #20]
 c004678:	f003 0303 	and.w	r3, r3, #3
 c00467c:	00db      	lsls	r3, r3, #3
 c00467e:	220f      	movs	r2, #15
 c004680:	fa02 f303 	lsl.w	r3, r2, r3
 c004684:	43db      	mvns	r3, r3
 c004686:	693a      	ldr	r2, [r7, #16]
 c004688:	4013      	ands	r3, r2
 c00468a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c00468c:	687b      	ldr	r3, [r7, #4]
 c00468e:	4a52      	ldr	r2, [pc, #328]	@ (c0047d8 <HAL_GPIO_Init+0x2e4>)
 c004690:	4293      	cmp	r3, r2
 c004692:	d025      	beq.n	c0046e0 <HAL_GPIO_Init+0x1ec>
 c004694:	687b      	ldr	r3, [r7, #4]
 c004696:	4a51      	ldr	r2, [pc, #324]	@ (c0047dc <HAL_GPIO_Init+0x2e8>)
 c004698:	4293      	cmp	r3, r2
 c00469a:	d01f      	beq.n	c0046dc <HAL_GPIO_Init+0x1e8>
 c00469c:	687b      	ldr	r3, [r7, #4]
 c00469e:	4a50      	ldr	r2, [pc, #320]	@ (c0047e0 <HAL_GPIO_Init+0x2ec>)
 c0046a0:	4293      	cmp	r3, r2
 c0046a2:	d019      	beq.n	c0046d8 <HAL_GPIO_Init+0x1e4>
 c0046a4:	687b      	ldr	r3, [r7, #4]
 c0046a6:	4a4f      	ldr	r2, [pc, #316]	@ (c0047e4 <HAL_GPIO_Init+0x2f0>)
 c0046a8:	4293      	cmp	r3, r2
 c0046aa:	d013      	beq.n	c0046d4 <HAL_GPIO_Init+0x1e0>
 c0046ac:	687b      	ldr	r3, [r7, #4]
 c0046ae:	4a4e      	ldr	r2, [pc, #312]	@ (c0047e8 <HAL_GPIO_Init+0x2f4>)
 c0046b0:	4293      	cmp	r3, r2
 c0046b2:	d00d      	beq.n	c0046d0 <HAL_GPIO_Init+0x1dc>
 c0046b4:	687b      	ldr	r3, [r7, #4]
 c0046b6:	4a4d      	ldr	r2, [pc, #308]	@ (c0047ec <HAL_GPIO_Init+0x2f8>)
 c0046b8:	4293      	cmp	r3, r2
 c0046ba:	d007      	beq.n	c0046cc <HAL_GPIO_Init+0x1d8>
 c0046bc:	687b      	ldr	r3, [r7, #4]
 c0046be:	4a4c      	ldr	r2, [pc, #304]	@ (c0047f0 <HAL_GPIO_Init+0x2fc>)
 c0046c0:	4293      	cmp	r3, r2
 c0046c2:	d101      	bne.n	c0046c8 <HAL_GPIO_Init+0x1d4>
 c0046c4:	2306      	movs	r3, #6
 c0046c6:	e00c      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046c8:	2307      	movs	r3, #7
 c0046ca:	e00a      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046cc:	2305      	movs	r3, #5
 c0046ce:	e008      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046d0:	2304      	movs	r3, #4
 c0046d2:	e006      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046d4:	2303      	movs	r3, #3
 c0046d6:	e004      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046d8:	2302      	movs	r3, #2
 c0046da:	e002      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046dc:	2301      	movs	r3, #1
 c0046de:	e000      	b.n	c0046e2 <HAL_GPIO_Init+0x1ee>
 c0046e0:	2300      	movs	r3, #0
 c0046e2:	697a      	ldr	r2, [r7, #20]
 c0046e4:	f002 0203 	and.w	r2, r2, #3
 c0046e8:	00d2      	lsls	r2, r2, #3
 c0046ea:	4093      	lsls	r3, r2
 c0046ec:	693a      	ldr	r2, [r7, #16]
 c0046ee:	4313      	orrs	r3, r2
 c0046f0:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2U] = temp;
 c0046f2:	4938      	ldr	r1, [pc, #224]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c0046f4:	697b      	ldr	r3, [r7, #20]
 c0046f6:	089b      	lsrs	r3, r3, #2
 c0046f8:	3318      	adds	r3, #24
 c0046fa:	693a      	ldr	r2, [r7, #16]
 c0046fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 c004700:	4b34      	ldr	r3, [pc, #208]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c004702:	681b      	ldr	r3, [r3, #0]
 c004704:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c004706:	68fb      	ldr	r3, [r7, #12]
 c004708:	43db      	mvns	r3, r3
 c00470a:	693a      	ldr	r2, [r7, #16]
 c00470c:	4013      	ands	r3, r2
 c00470e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 c004710:	683b      	ldr	r3, [r7, #0]
 c004712:	685b      	ldr	r3, [r3, #4]
 c004714:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 c004718:	2b00      	cmp	r3, #0
 c00471a:	d003      	beq.n	c004724 <HAL_GPIO_Init+0x230>
        {
          temp |= iocurrent;
 c00471c:	693a      	ldr	r2, [r7, #16]
 c00471e:	68fb      	ldr	r3, [r7, #12]
 c004720:	4313      	orrs	r3, r2
 c004722:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 c004724:	4a2b      	ldr	r2, [pc, #172]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c004726:	693b      	ldr	r3, [r7, #16]
 c004728:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 c00472a:	4b2a      	ldr	r3, [pc, #168]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c00472c:	685b      	ldr	r3, [r3, #4]
 c00472e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c004730:	68fb      	ldr	r3, [r7, #12]
 c004732:	43db      	mvns	r3, r3
 c004734:	693a      	ldr	r2, [r7, #16]
 c004736:	4013      	ands	r3, r2
 c004738:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 c00473a:	683b      	ldr	r3, [r7, #0]
 c00473c:	685b      	ldr	r3, [r3, #4]
 c00473e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 c004742:	2b00      	cmp	r3, #0
 c004744:	d003      	beq.n	c00474e <HAL_GPIO_Init+0x25a>
        {
          temp |= iocurrent;
 c004746:	693a      	ldr	r2, [r7, #16]
 c004748:	68fb      	ldr	r3, [r7, #12]
 c00474a:	4313      	orrs	r3, r2
 c00474c:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 c00474e:	4a21      	ldr	r2, [pc, #132]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c004750:	693b      	ldr	r3, [r7, #16]
 c004752:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->EMR1;
 c004754:	4b1f      	ldr	r3, [pc, #124]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c004756:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 c00475a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c00475c:	68fb      	ldr	r3, [r7, #12]
 c00475e:	43db      	mvns	r3, r3
 c004760:	693a      	ldr	r2, [r7, #16]
 c004762:	4013      	ands	r3, r2
 c004764:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 c004766:	683b      	ldr	r3, [r7, #0]
 c004768:	685b      	ldr	r3, [r3, #4]
 c00476a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 c00476e:	2b00      	cmp	r3, #0
 c004770:	d003      	beq.n	c00477a <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 c004772:	693a      	ldr	r2, [r7, #16]
 c004774:	68fb      	ldr	r3, [r7, #12]
 c004776:	4313      	orrs	r3, r2
 c004778:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 c00477a:	4a16      	ldr	r2, [pc, #88]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c00477c:	693b      	ldr	r3, [r7, #16]
 c00477e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        temp = EXTI->IMR1;
 c004782:	4b14      	ldr	r3, [pc, #80]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c004784:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 c004788:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c00478a:	68fb      	ldr	r3, [r7, #12]
 c00478c:	43db      	mvns	r3, r3
 c00478e:	693a      	ldr	r2, [r7, #16]
 c004790:	4013      	ands	r3, r2
 c004792:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 c004794:	683b      	ldr	r3, [r7, #0]
 c004796:	685b      	ldr	r3, [r3, #4]
 c004798:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c00479c:	2b00      	cmp	r3, #0
 c00479e:	d003      	beq.n	c0047a8 <HAL_GPIO_Init+0x2b4>
        {
          temp |= iocurrent;
 c0047a0:	693a      	ldr	r2, [r7, #16]
 c0047a2:	68fb      	ldr	r3, [r7, #12]
 c0047a4:	4313      	orrs	r3, r2
 c0047a6:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 c0047a8:	4a0a      	ldr	r2, [pc, #40]	@ (c0047d4 <HAL_GPIO_Init+0x2e0>)
 c0047aa:	693b      	ldr	r3, [r7, #16]
 c0047ac:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
 c0047b0:	697b      	ldr	r3, [r7, #20]
 c0047b2:	3301      	adds	r3, #1
 c0047b4:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0U)
 c0047b6:	683b      	ldr	r3, [r7, #0]
 c0047b8:	681a      	ldr	r2, [r3, #0]
 c0047ba:	697b      	ldr	r3, [r7, #20]
 c0047bc:	fa22 f303 	lsr.w	r3, r2, r3
 c0047c0:	2b00      	cmp	r3, #0
 c0047c2:	f47f ae9f 	bne.w	c004504 <HAL_GPIO_Init+0x10>
  }
}
 c0047c6:	bf00      	nop
 c0047c8:	bf00      	nop
 c0047ca:	371c      	adds	r7, #28
 c0047cc:	46bd      	mov	sp, r7
 c0047ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0047d2:	4770      	bx	lr
 c0047d4:	5002f400 	.word	0x5002f400
 c0047d8:	52020000 	.word	0x52020000
 c0047dc:	52020400 	.word	0x52020400
 c0047e0:	52020800 	.word	0x52020800
 c0047e4:	52020c00 	.word	0x52020c00
 c0047e8:	52021000 	.word	0x52021000
 c0047ec:	52021400 	.word	0x52021400
 c0047f0:	52021800 	.word	0x52021800

0c0047f4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 c0047f4:	b480      	push	{r7}
 c0047f6:	b083      	sub	sp, #12
 c0047f8:	af00      	add	r7, sp, #0
 c0047fa:	6078      	str	r0, [r7, #4]
 c0047fc:	460b      	mov	r3, r1
 c0047fe:	807b      	strh	r3, [r7, #2]
 c004800:	4613      	mov	r3, r2
 c004802:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 c004804:	787b      	ldrb	r3, [r7, #1]
 c004806:	2b00      	cmp	r3, #0
 c004808:	d003      	beq.n	c004812 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 c00480a:	887a      	ldrh	r2, [r7, #2]
 c00480c:	687b      	ldr	r3, [r7, #4]
 c00480e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 c004810:	e002      	b.n	c004818 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 c004812:	887a      	ldrh	r2, [r7, #2]
 c004814:	687b      	ldr	r3, [r7, #4]
 c004816:	629a      	str	r2, [r3, #40]	@ 0x28
}
 c004818:	bf00      	nop
 c00481a:	370c      	adds	r7, #12
 c00481c:	46bd      	mov	sp, r7
 c00481e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004822:	4770      	bx	lr

0c004824 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 c004824:	b480      	push	{r7}
 c004826:	b085      	sub	sp, #20
 c004828:	af00      	add	r7, sp, #0
 c00482a:	6078      	str	r0, [r7, #4]
 c00482c:	460b      	mov	r3, r1
 c00482e:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 c004830:	687b      	ldr	r3, [r7, #4]
 c004832:	695b      	ldr	r3, [r3, #20]
 c004834:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 c004836:	887a      	ldrh	r2, [r7, #2]
 c004838:	68fb      	ldr	r3, [r7, #12]
 c00483a:	4013      	ands	r3, r2
 c00483c:	041a      	lsls	r2, r3, #16
 c00483e:	68fb      	ldr	r3, [r7, #12]
 c004840:	43d9      	mvns	r1, r3
 c004842:	887b      	ldrh	r3, [r7, #2]
 c004844:	400b      	ands	r3, r1
 c004846:	431a      	orrs	r2, r3
 c004848:	687b      	ldr	r3, [r7, #4]
 c00484a:	619a      	str	r2, [r3, #24]
}
 c00484c:	bf00      	nop
 c00484e:	3714      	adds	r7, #20
 c004850:	46bd      	mov	sp, r7
 c004852:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004856:	4770      	bx	lr

0c004858 <HAL_GPIO_ConfigPinAttributes>:
  * @param  GPIO_Pin specifies the pin(s) to configure the secure attribute
  * @param  PinAttributes specifies the pin(s) to be set in secure mode, other being set non secured.
  * @retval None
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
 c004858:	b480      	push	{r7}
 c00485a:	b087      	sub	sp, #28
 c00485c:	af00      	add	r7, sp, #0
 c00485e:	60f8      	str	r0, [r7, #12]
 c004860:	460b      	mov	r3, r1
 c004862:	607a      	str	r2, [r7, #4]
 c004864:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

  /* Configure the port pins */
  temp = GPIOx->SECCFGR;
 c004866:	68fb      	ldr	r3, [r7, #12]
 c004868:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c00486a:	617b      	str	r3, [r7, #20]
  if (PinAttributes != GPIO_PIN_NSEC)
 c00486c:	687b      	ldr	r3, [r7, #4]
 c00486e:	2b00      	cmp	r3, #0
 c004870:	d004      	beq.n	c00487c <HAL_GPIO_ConfigPinAttributes+0x24>
  {
    temp |= (uint32_t)GPIO_Pin;
 c004872:	897b      	ldrh	r3, [r7, #10]
 c004874:	697a      	ldr	r2, [r7, #20]
 c004876:	4313      	orrs	r3, r2
 c004878:	617b      	str	r3, [r7, #20]
 c00487a:	e004      	b.n	c004886 <HAL_GPIO_ConfigPinAttributes+0x2e>
  }
  else
  {
    temp &= ~((uint32_t)GPIO_Pin);
 c00487c:	897b      	ldrh	r3, [r7, #10]
 c00487e:	43db      	mvns	r3, r3
 c004880:	697a      	ldr	r2, [r7, #20]
 c004882:	4013      	ands	r3, r2
 c004884:	617b      	str	r3, [r7, #20]
  }

  /* Set secure attributes */
  GPIOx->SECCFGR = temp;
 c004886:	68fb      	ldr	r3, [r7, #12]
 c004888:	697a      	ldr	r2, [r7, #20]
 c00488a:	631a      	str	r2, [r3, #48]	@ 0x30
}
 c00488c:	bf00      	nop
 c00488e:	371c      	adds	r7, #28
 c004890:	46bd      	mov	sp, r7
 c004892:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004896:	4770      	bx	lr

0c004898 <HAL_GTZC_MPCBB_ConfigMem>:
  *         The structure description is available in @ref GTZC_Exported_Types.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_GTZC_MPCBB_ConfigMem(uint32_t MemBaseAddress,
                                           const MPCBB_ConfigTypeDef *pMPCBB_desc)
{
 c004898:	b480      	push	{r7}
 c00489a:	b089      	sub	sp, #36	@ 0x24
 c00489c:	af00      	add	r7, sp, #0
 c00489e:	6078      	str	r0, [r7, #4]
 c0048a0:	6039      	str	r1, [r7, #0]
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c0048a2:	687b      	ldr	r3, [r7, #4]
 c0048a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 c0048a8:	d00b      	beq.n	c0048c2 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
 c0048aa:	687b      	ldr	r3, [r7, #4]
 c0048ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 c0048b0:	d007      	beq.n	c0048c2 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c0048b2:	687b      	ldr	r3, [r7, #4]
 c0048b4:	4a36      	ldr	r2, [pc, #216]	@ (c004990 <HAL_GTZC_MPCBB_ConfigMem+0xf8>)
 c0048b6:	4293      	cmp	r3, r2
 c0048b8:	d003      	beq.n	c0048c2 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
 c0048ba:	687b      	ldr	r3, [r7, #4]
 c0048bc:	4a35      	ldr	r2, [pc, #212]	@ (c004994 <HAL_GTZC_MPCBB_ConfigMem+0xfc>)
 c0048be:	4293      	cmp	r3, r2
 c0048c0:	d111      	bne.n	c0048e6 <HAL_GTZC_MPCBB_ConfigMem+0x4e>
      || ((pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_ENABLE)
 c0048c2:	683b      	ldr	r3, [r7, #0]
 c0048c4:	681b      	ldr	r3, [r3, #0]
 c0048c6:	2b00      	cmp	r3, #0
 c0048c8:	d004      	beq.n	c0048d4 <HAL_GTZC_MPCBB_ConfigMem+0x3c>
          && (pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_DISABLE))
 c0048ca:	683b      	ldr	r3, [r7, #0]
 c0048cc:	681b      	ldr	r3, [r3, #0]
 c0048ce:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 c0048d2:	d108      	bne.n	c0048e6 <HAL_GTZC_MPCBB_ConfigMem+0x4e>
      || ((pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_NOT_INVERTED)
 c0048d4:	683b      	ldr	r3, [r7, #0]
 c0048d6:	685b      	ldr	r3, [r3, #4]
 c0048d8:	2b00      	cmp	r3, #0
 c0048da:	d006      	beq.n	c0048ea <HAL_GTZC_MPCBB_ConfigMem+0x52>
          && (pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_INVERTED)))
 c0048dc:	683b      	ldr	r3, [r7, #0]
 c0048de:	685b      	ldr	r3, [r3, #4]
 c0048e0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 c0048e4:	d001      	beq.n	c0048ea <HAL_GTZC_MPCBB_ConfigMem+0x52>
  {
    return HAL_ERROR;
 c0048e6:	2301      	movs	r3, #1
 c0048e8:	e04b      	b.n	c004982 <HAL_GTZC_MPCBB_ConfigMem+0xea>
  }

  /* write InvertSecureState and SecureRWIllegalMode properties */
  /* assume their Position/Mask is identical for all sub-blocks */
  reg_value = pMPCBB_desc->InvertSecureState;
 c0048ea:	683b      	ldr	r3, [r7, #0]
 c0048ec:	685b      	ldr	r3, [r3, #4]
 c0048ee:	613b      	str	r3, [r7, #16]
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
 c0048f0:	683b      	ldr	r3, [r7, #0]
 c0048f2:	681b      	ldr	r3, [r3, #0]
 c0048f4:	693a      	ldr	r2, [r7, #16]
 c0048f6:	4313      	orrs	r3, r2
 c0048f8:	613b      	str	r3, [r7, #16]
  if (IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c0048fa:	687b      	ldr	r3, [r7, #4]
 c0048fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 c004900:	d003      	beq.n	c00490a <HAL_GTZC_MPCBB_ConfigMem+0x72>
 c004902:	687b      	ldr	r3, [r7, #4]
 c004904:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 c004908:	d105      	bne.n	c004916 <HAL_GTZC_MPCBB_ConfigMem+0x7e>
  {
    mpcbb_ptr = GTZC_MPCBB1_S;
 c00490a:	4b23      	ldr	r3, [pc, #140]	@ (c004998 <HAL_GTZC_MPCBB_ConfigMem+0x100>)
 c00490c:	61fb      	str	r3, [r7, #28]
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c00490e:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
 c004912:	61bb      	str	r3, [r7, #24]
 c004914:	e004      	b.n	c004920 <HAL_GTZC_MPCBB_ConfigMem+0x88>
  }
  else
  {
    /* Here MemBaseAddress is inside SRAM2 (already tested) */
    mpcbb_ptr = GTZC_MPCBB2_S;
 c004916:	4b21      	ldr	r3, [pc, #132]	@ (c00499c <HAL_GTZC_MPCBB_ConfigMem+0x104>)
 c004918:	61fb      	str	r3, [r7, #28]
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c00491a:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 c00491e:	61bb      	str	r3, [r7, #24]
  }

  /* write vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
 c004920:	69bb      	ldr	r3, [r7, #24]
 c004922:	0b5b      	lsrs	r3, r3, #13
 c004924:	60fb      	str	r3, [r7, #12]
  for (i = 0U; i < size_in_superblocks; i++)
 c004926:	2300      	movs	r3, #0
 c004928:	617b      	str	r3, [r7, #20]
 c00492a:	e00c      	b.n	c004946 <HAL_GTZC_MPCBB_ConfigMem+0xae>
  {
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c00492c:	683b      	ldr	r3, [r7, #0]
 c00492e:	697a      	ldr	r2, [r7, #20]
 c004930:	3202      	adds	r2, #2
 c004932:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c004936:	69fb      	ldr	r3, [r7, #28]
 c004938:	697a      	ldr	r2, [r7, #20]
 c00493a:	3240      	adds	r2, #64	@ 0x40
 c00493c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c004940:	697b      	ldr	r3, [r7, #20]
 c004942:	3301      	adds	r3, #1
 c004944:	617b      	str	r3, [r7, #20]
 c004946:	697a      	ldr	r2, [r7, #20]
 c004948:	68fb      	ldr	r3, [r7, #12]
 c00494a:	429a      	cmp	r2, r3
 c00494c:	d3ee      	bcc.n	c00492c <HAL_GTZC_MPCBB_ConfigMem+0x94>
              pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i]);
  }

  /* write configuration and lock register information */
  MODIFY_REG(mpcbb_ptr->CR,
 c00494e:	69fb      	ldr	r3, [r7, #28]
 c004950:	681b      	ldr	r3, [r3, #0]
 c004952:	f023 4240 	bic.w	r2, r3, #3221225472	@ 0xc0000000
 c004956:	693b      	ldr	r3, [r7, #16]
 c004958:	431a      	orrs	r2, r3
 c00495a:	69fb      	ldr	r3, [r7, #28]
 c00495c:	601a      	str	r2, [r3, #0]
             GTZC_MPCBB_CR_INVSECSTATE_Msk | GTZC_MPCBB_CR_SRWILADIS_Msk, reg_value);

  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c00495e:	69bb      	ldr	r3, [r7, #24]
 c004960:	0b5b      	lsrs	r3, r3, #13
 c004962:	2201      	movs	r2, #1
 c004964:	fa02 f303 	lsl.w	r3, r2, r3
 c004968:	3b01      	subs	r3, #1
 c00496a:	60bb      	str	r3, [r7, #8]
  /* limitation: code not portable with memory > 256K */
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c00496c:	69fb      	ldr	r3, [r7, #28]
 c00496e:	691a      	ldr	r2, [r3, #16]
 c004970:	68bb      	ldr	r3, [r7, #8]
 c004972:	43db      	mvns	r3, r3
 c004974:	401a      	ands	r2, r3
 c004976:	683b      	ldr	r3, [r7, #0]
 c004978:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 c00497a:	431a      	orrs	r2, r3
 c00497c:	69fb      	ldr	r3, [r7, #28]
 c00497e:	611a      	str	r2, [r3, #16]

  return HAL_OK;
 c004980:	2300      	movs	r3, #0
}
 c004982:	4618      	mov	r0, r3
 c004984:	3724      	adds	r7, #36	@ 0x24
 c004986:	46bd      	mov	sp, r7
 c004988:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00498c:	4770      	bx	lr
 c00498e:	bf00      	nop
 c004990:	20030000 	.word	0x20030000
 c004994:	30030000 	.word	0x30030000
 c004998:	50032c00 	.word	0x50032c00
 c00499c:	50033000 	.word	0x50033000

0c0049a0 <HAL_GTZC_IRQHandler>:
/**
  * @brief  This function handles GTZC interrupt request.
  * @retval None.
  */
void HAL_GTZC_IRQHandler(void)
{
 c0049a0:	b580      	push	{r7, lr}
 c0049a2:	b084      	sub	sp, #16
 c0049a4:	af00      	add	r7, sp, #0
  uint32_t flag;
  uint32_t ier_itsources;
  uint32_t sr_flags;

  /* Get current IT Flags and IT sources value on 1st register */
  ier_itsources = READ_REG(GTZC_TZIC->IER1);
 c0049a6:	4b3f      	ldr	r3, [pc, #252]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c0049a8:	681b      	ldr	r3, [r3, #0]
 c0049aa:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR1);
 c0049ac:	4b3d      	ldr	r3, [pc, #244]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c0049ae:	691b      	ldr	r3, [r3, #16]
 c0049b0:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c0049b2:	68ba      	ldr	r2, [r7, #8]
 c0049b4:	687b      	ldr	r3, [r7, #4]
 c0049b6:	4013      	ands	r3, r2
 c0049b8:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c0049ba:	683b      	ldr	r3, [r7, #0]
 c0049bc:	2b00      	cmp	r3, #0
 c0049be:	d019      	beq.n	c0049f4 <HAL_GTZC_IRQHandler+0x54>
  {
    WRITE_REG(GTZC_TZIC->FCR1, flag);
 c0049c0:	4a38      	ldr	r2, [pc, #224]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c0049c2:	683b      	ldr	r3, [r7, #0]
 c0049c4:	6213      	str	r3, [r2, #32]

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c0049c6:	2300      	movs	r3, #0
 c0049c8:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c0049ca:	e00d      	b.n	c0049e8 <HAL_GTZC_IRQHandler+0x48>
    {
      if ((flag & (1UL << position)) != 0U)
 c0049cc:	683a      	ldr	r2, [r7, #0]
 c0049ce:	68fb      	ldr	r3, [r7, #12]
 c0049d0:	fa22 f303 	lsr.w	r3, r2, r3
 c0049d4:	f003 0301 	and.w	r3, r3, #1
 c0049d8:	2b00      	cmp	r3, #0
 c0049da:	d002      	beq.n	c0049e2 <HAL_GTZC_IRQHandler+0x42>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG1 | position);
 c0049dc:	68f8      	ldr	r0, [r7, #12]
 c0049de:	f000 f863 	bl	c004aa8 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c0049e2:	68fb      	ldr	r3, [r7, #12]
 c0049e4:	3301      	adds	r3, #1
 c0049e6:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c0049e8:	683a      	ldr	r2, [r7, #0]
 c0049ea:	68fb      	ldr	r3, [r7, #12]
 c0049ec:	fa22 f303 	lsr.w	r3, r2, r3
 c0049f0:	2b00      	cmp	r3, #0
 c0049f2:	d1eb      	bne.n	c0049cc <HAL_GTZC_IRQHandler+0x2c>
    }
  }

  /* Get current IT Flags and IT sources value on 2nd register */
  ier_itsources = READ_REG(GTZC_TZIC->IER2);
 c0049f4:	4b2b      	ldr	r3, [pc, #172]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c0049f6:	685b      	ldr	r3, [r3, #4]
 c0049f8:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR2);
 c0049fa:	4b2a      	ldr	r3, [pc, #168]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c0049fc:	695b      	ldr	r3, [r3, #20]
 c0049fe:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c004a00:	68ba      	ldr	r2, [r7, #8]
 c004a02:	687b      	ldr	r3, [r7, #4]
 c004a04:	4013      	ands	r3, r2
 c004a06:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c004a08:	683b      	ldr	r3, [r7, #0]
 c004a0a:	2b00      	cmp	r3, #0
 c004a0c:	d01c      	beq.n	c004a48 <HAL_GTZC_IRQHandler+0xa8>
  {
    WRITE_REG(GTZC_TZIC->FCR2, flag);
 c004a0e:	4a25      	ldr	r2, [pc, #148]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c004a10:	683b      	ldr	r3, [r7, #0]
 c004a12:	6253      	str	r3, [r2, #36]	@ 0x24

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c004a14:	2300      	movs	r3, #0
 c004a16:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a18:	e010      	b.n	c004a3c <HAL_GTZC_IRQHandler+0x9c>
    {
      if ((flag & (1UL << position)) != 0U)
 c004a1a:	683a      	ldr	r2, [r7, #0]
 c004a1c:	68fb      	ldr	r3, [r7, #12]
 c004a1e:	fa22 f303 	lsr.w	r3, r2, r3
 c004a22:	f003 0301 	and.w	r3, r3, #1
 c004a26:	2b00      	cmp	r3, #0
 c004a28:	d005      	beq.n	c004a36 <HAL_GTZC_IRQHandler+0x96>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG2 | position);
 c004a2a:	68fb      	ldr	r3, [r7, #12]
 c004a2c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 c004a30:	4618      	mov	r0, r3
 c004a32:	f000 f839 	bl	c004aa8 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c004a36:	68fb      	ldr	r3, [r7, #12]
 c004a38:	3301      	adds	r3, #1
 c004a3a:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a3c:	683a      	ldr	r2, [r7, #0]
 c004a3e:	68fb      	ldr	r3, [r7, #12]
 c004a40:	fa22 f303 	lsr.w	r3, r2, r3
 c004a44:	2b00      	cmp	r3, #0
 c004a46:	d1e8      	bne.n	c004a1a <HAL_GTZC_IRQHandler+0x7a>
    }
  }

  /* Get current IT Flags and IT sources value on 3rd register */
  ier_itsources = READ_REG(GTZC_TZIC->IER3);
 c004a48:	4b16      	ldr	r3, [pc, #88]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c004a4a:	689b      	ldr	r3, [r3, #8]
 c004a4c:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR3);
 c004a4e:	4b15      	ldr	r3, [pc, #84]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c004a50:	699b      	ldr	r3, [r3, #24]
 c004a52:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c004a54:	68ba      	ldr	r2, [r7, #8]
 c004a56:	687b      	ldr	r3, [r7, #4]
 c004a58:	4013      	ands	r3, r2
 c004a5a:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c004a5c:	683b      	ldr	r3, [r7, #0]
 c004a5e:	2b00      	cmp	r3, #0
 c004a60:	d01c      	beq.n	c004a9c <HAL_GTZC_IRQHandler+0xfc>
  {
    WRITE_REG(GTZC_TZIC->FCR3, flag);
 c004a62:	4a10      	ldr	r2, [pc, #64]	@ (c004aa4 <HAL_GTZC_IRQHandler+0x104>)
 c004a64:	683b      	ldr	r3, [r7, #0]
 c004a66:	6293      	str	r3, [r2, #40]	@ 0x28

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c004a68:	2300      	movs	r3, #0
 c004a6a:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a6c:	e010      	b.n	c004a90 <HAL_GTZC_IRQHandler+0xf0>
    {
      if ((flag & (1UL << position)) != 0U)
 c004a6e:	683a      	ldr	r2, [r7, #0]
 c004a70:	68fb      	ldr	r3, [r7, #12]
 c004a72:	fa22 f303 	lsr.w	r3, r2, r3
 c004a76:	f003 0301 	and.w	r3, r3, #1
 c004a7a:	2b00      	cmp	r3, #0
 c004a7c:	d005      	beq.n	c004a8a <HAL_GTZC_IRQHandler+0xea>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG3 | position);
 c004a7e:	68fb      	ldr	r3, [r7, #12]
 c004a80:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 c004a84:	4618      	mov	r0, r3
 c004a86:	f000 f80f 	bl	c004aa8 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c004a8a:	68fb      	ldr	r3, [r7, #12]
 c004a8c:	3301      	adds	r3, #1
 c004a8e:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a90:	683a      	ldr	r2, [r7, #0]
 c004a92:	68fb      	ldr	r3, [r7, #12]
 c004a94:	fa22 f303 	lsr.w	r3, r2, r3
 c004a98:	2b00      	cmp	r3, #0
 c004a9a:	d1e8      	bne.n	c004a6e <HAL_GTZC_IRQHandler+0xce>
    }
  }
}
 c004a9c:	bf00      	nop
 c004a9e:	3710      	adds	r7, #16
 c004aa0:	46bd      	mov	sp, r7
 c004aa2:	bd80      	pop	{r7, pc}
 c004aa4:	50032800 	.word	0x50032800

0c004aa8 <HAL_GTZC_TZIC_Callback>:
  * @param  PeriphId Peripheral identifier triggering the illegal access.
  *         This parameter can be a value of @ref GTZC_TZSC_TZIC_PeriphId
  * @retval None.
  */
__weak void HAL_GTZC_TZIC_Callback(uint32_t PeriphId)
{
 c004aa8:	b480      	push	{r7}
 c004aaa:	b083      	sub	sp, #12
 c004aac:	af00      	add	r7, sp, #0
 c004aae:	6078      	str	r0, [r7, #4]
  UNUSED(PeriphId);

  /* NOTE: This function should not be modified. When the callback is needed,
   * the HAL_GTZC_TZIC_Callback is to be implemented in the user file
   */
}
 c004ab0:	bf00      	nop
 c004ab2:	370c      	adds	r7, #12
 c004ab4:	46bd      	mov	sp, r7
 c004ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004aba:	4770      	bx	lr

0c004abc <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 c004abc:	b480      	push	{r7}
 c004abe:	b085      	sub	sp, #20
 c004ac0:	af00      	add	r7, sp, #0
 c004ac2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 c004ac4:	2300      	movs	r3, #0
 c004ac6:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004ac8:	4b0b      	ldr	r3, [pc, #44]	@ (c004af8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004aca:	681b      	ldr	r3, [r3, #0]
 c004acc:	f003 0301 	and.w	r3, r3, #1
 c004ad0:	2b00      	cmp	r3, #0
 c004ad2:	d002      	beq.n	c004ada <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 c004ad4:	2301      	movs	r3, #1
 c004ad6:	73fb      	strb	r3, [r7, #15]
 c004ad8:	e007      	b.n	c004aea <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 c004ada:	4b07      	ldr	r3, [pc, #28]	@ (c004af8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004adc:	681b      	ldr	r3, [r3, #0]
 c004ade:	f023 0204 	bic.w	r2, r3, #4
 c004ae2:	4905      	ldr	r1, [pc, #20]	@ (c004af8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004ae4:	687b      	ldr	r3, [r7, #4]
 c004ae6:	4313      	orrs	r3, r2
 c004ae8:	600b      	str	r3, [r1, #0]
  }

  return status;
 c004aea:	7bfb      	ldrb	r3, [r7, #15]
}
 c004aec:	4618      	mov	r0, r3
 c004aee:	3714      	adds	r7, #20
 c004af0:	46bd      	mov	sp, r7
 c004af2:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004af6:	4770      	bx	lr
 c004af8:	50030400 	.word	0x50030400

0c004afc <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 c004afc:	b480      	push	{r7}
 c004afe:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c004b00:	4b05      	ldr	r3, [pc, #20]	@ (c004b18 <HAL_ICACHE_Enable+0x1c>)
 c004b02:	681b      	ldr	r3, [r3, #0]
 c004b04:	4a04      	ldr	r2, [pc, #16]	@ (c004b18 <HAL_ICACHE_Enable+0x1c>)
 c004b06:	f043 0301 	orr.w	r3, r3, #1
 c004b0a:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 c004b0c:	2300      	movs	r3, #0
}
 c004b0e:	4618      	mov	r0, r3
 c004b10:	46bd      	mov	sp, r7
 c004b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004b16:	4770      	bx	lr
 c004b18:	50030400 	.word	0x50030400

0c004b1c <HAL_ICACHE_Disable>:
  * @note   This function waits for the cache being disabled but
  *         not for the end of the automatic cache invalidation procedure.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_Disable(void)
{
 c004b1c:	b580      	push	{r7, lr}
 c004b1e:	b082      	sub	sp, #8
 c004b20:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c004b22:	2300      	movs	r3, #0
 c004b24:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart;

  /* Make sure BSYENDF is reset before to disable the instruction cache */
  /* as it automatically starts a cache invalidation procedure */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c004b26:	4b14      	ldr	r3, [pc, #80]	@ (c004b78 <HAL_ICACHE_Disable+0x5c>)
 c004b28:	2202      	movs	r2, #2
 c004b2a:	60da      	str	r2, [r3, #12]

  CLEAR_BIT(ICACHE->CR, ICACHE_CR_EN);
 c004b2c:	4b12      	ldr	r3, [pc, #72]	@ (c004b78 <HAL_ICACHE_Disable+0x5c>)
 c004b2e:	681b      	ldr	r3, [r3, #0]
 c004b30:	4a11      	ldr	r2, [pc, #68]	@ (c004b78 <HAL_ICACHE_Disable+0x5c>)
 c004b32:	f023 0301 	bic.w	r3, r3, #1
 c004b36:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 c004b38:	f7ff f8c0 	bl	c003cbc <HAL_GetTick>
 c004b3c:	6038      	str	r0, [r7, #0]

  /* Wait for instruction cache being disabled */
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b3e:	e00f      	b.n	c004b60 <HAL_ICACHE_Disable+0x44>
  {
    if ((HAL_GetTick() - tickstart) > ICACHE_DISABLE_TIMEOUT_VALUE)
 c004b40:	f7ff f8bc 	bl	c003cbc <HAL_GetTick>
 c004b44:	4602      	mov	r2, r0
 c004b46:	683b      	ldr	r3, [r7, #0]
 c004b48:	1ad3      	subs	r3, r2, r3
 c004b4a:	2b01      	cmp	r3, #1
 c004b4c:	d908      	bls.n	c004b60 <HAL_ICACHE_Disable+0x44>
    {
      /* New check to avoid false timeout detection in case of preemption */
      if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b4e:	4b0a      	ldr	r3, [pc, #40]	@ (c004b78 <HAL_ICACHE_Disable+0x5c>)
 c004b50:	681b      	ldr	r3, [r3, #0]
 c004b52:	f003 0301 	and.w	r3, r3, #1
 c004b56:	2b00      	cmp	r3, #0
 c004b58:	d002      	beq.n	c004b60 <HAL_ICACHE_Disable+0x44>
      {
        status = HAL_TIMEOUT;
 c004b5a:	2303      	movs	r3, #3
 c004b5c:	71fb      	strb	r3, [r7, #7]
        break;
 c004b5e:	e005      	b.n	c004b6c <HAL_ICACHE_Disable+0x50>
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b60:	4b05      	ldr	r3, [pc, #20]	@ (c004b78 <HAL_ICACHE_Disable+0x5c>)
 c004b62:	681b      	ldr	r3, [r3, #0]
 c004b64:	f003 0301 	and.w	r3, r3, #1
 c004b68:	2b00      	cmp	r3, #0
 c004b6a:	d1e9      	bne.n	c004b40 <HAL_ICACHE_Disable+0x24>
      }
    }
  }

  return status;
 c004b6c:	79fb      	ldrb	r3, [r7, #7]
}
 c004b6e:	4618      	mov	r0, r3
 c004b70:	3708      	adds	r7, #8
 c004b72:	46bd      	mov	sp, r7
 c004b74:	bd80      	pop	{r7, pc}
 c004b76:	bf00      	nop
 c004b78:	50030400 	.word	0x50030400

0c004b7c <HAL_ICACHE_Invalidate>:
  * @note   This function waits for the end of cache invalidation procedure
  *         and clears the associated BSYENDF flag.
  * @retval HAL status (HAL_OK/HAL_ERROR/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_Invalidate(void)
{
 c004b7c:	b580      	push	{r7, lr}
 c004b7e:	b082      	sub	sp, #8
 c004b80:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Check if no ongoing operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) == 0U)
 c004b82:	4b0a      	ldr	r3, [pc, #40]	@ (c004bac <HAL_ICACHE_Invalidate+0x30>)
 c004b84:	685b      	ldr	r3, [r3, #4]
 c004b86:	f003 0301 	and.w	r3, r3, #1
 c004b8a:	2b00      	cmp	r3, #0
 c004b8c:	d105      	bne.n	c004b9a <HAL_ICACHE_Invalidate+0x1e>
  {
    /* Launch cache invalidation */
    SET_BIT(ICACHE->CR, ICACHE_CR_CACHEINV);
 c004b8e:	4b07      	ldr	r3, [pc, #28]	@ (c004bac <HAL_ICACHE_Invalidate+0x30>)
 c004b90:	681b      	ldr	r3, [r3, #0]
 c004b92:	4a06      	ldr	r2, [pc, #24]	@ (c004bac <HAL_ICACHE_Invalidate+0x30>)
 c004b94:	f043 0302 	orr.w	r3, r3, #2
 c004b98:	6013      	str	r3, [r2, #0]
  }

  status = HAL_ICACHE_WaitForInvalidateComplete();
 c004b9a:	f000 f809 	bl	c004bb0 <HAL_ICACHE_WaitForInvalidateComplete>
 c004b9e:	4603      	mov	r3, r0
 c004ba0:	71fb      	strb	r3, [r7, #7]

  return status;
 c004ba2:	79fb      	ldrb	r3, [r7, #7]
}
 c004ba4:	4618      	mov	r0, r3
 c004ba6:	3708      	adds	r7, #8
 c004ba8:	46bd      	mov	sp, r7
 c004baa:	bd80      	pop	{r7, pc}
 c004bac:	50030400 	.word	0x50030400

0c004bb0 <HAL_ICACHE_WaitForInvalidateComplete>:
  * @brief Wait for the end of the Instruction Cache invalidate procedure.
  * @note This function checks and clears the BSYENDF flag when set.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_WaitForInvalidateComplete(void)
{
 c004bb0:	b580      	push	{r7, lr}
 c004bb2:	b082      	sub	sp, #8
 c004bb4:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c004bb6:	2300      	movs	r3, #0
 c004bb8:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart;

  /* Check if ongoing invalidation operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c004bba:	4b14      	ldr	r3, [pc, #80]	@ (c004c0c <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bbc:	685b      	ldr	r3, [r3, #4]
 c004bbe:	f003 0301 	and.w	r3, r3, #1
 c004bc2:	2b00      	cmp	r3, #0
 c004bc4:	d019      	beq.n	c004bfa <HAL_ICACHE_WaitForInvalidateComplete+0x4a>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
 c004bc6:	f7ff f879 	bl	c003cbc <HAL_GetTick>
 c004bca:	6038      	str	r0, [r7, #0]

    /* Wait for end of cache invalidation */
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004bcc:	e00f      	b.n	c004bee <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
    {
      if ((HAL_GetTick() - tickstart) > ICACHE_INVALIDATE_TIMEOUT_VALUE)
 c004bce:	f7ff f875 	bl	c003cbc <HAL_GetTick>
 c004bd2:	4602      	mov	r2, r0
 c004bd4:	683b      	ldr	r3, [r7, #0]
 c004bd6:	1ad3      	subs	r3, r2, r3
 c004bd8:	2b01      	cmp	r3, #1
 c004bda:	d908      	bls.n	c004bee <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004bdc:	4b0b      	ldr	r3, [pc, #44]	@ (c004c0c <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bde:	685b      	ldr	r3, [r3, #4]
 c004be0:	f003 0302 	and.w	r3, r3, #2
 c004be4:	2b00      	cmp	r3, #0
 c004be6:	d102      	bne.n	c004bee <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
        {
          status = HAL_TIMEOUT;
 c004be8:	2303      	movs	r3, #3
 c004bea:	71fb      	strb	r3, [r7, #7]
          break;
 c004bec:	e005      	b.n	c004bfa <HAL_ICACHE_WaitForInvalidateComplete+0x4a>
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004bee:	4b07      	ldr	r3, [pc, #28]	@ (c004c0c <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bf0:	685b      	ldr	r3, [r3, #4]
 c004bf2:	f003 0302 	and.w	r3, r3, #2
 c004bf6:	2b00      	cmp	r3, #0
 c004bf8:	d0e9      	beq.n	c004bce <HAL_ICACHE_WaitForInvalidateComplete+0x1e>
      }
    }
  }

  /* Clear BSYENDF */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c004bfa:	4b04      	ldr	r3, [pc, #16]	@ (c004c0c <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bfc:	2202      	movs	r2, #2
 c004bfe:	60da      	str	r2, [r3, #12]

  return status;
 c004c00:	79fb      	ldrb	r3, [r7, #7]
}
 c004c02:	4618      	mov	r0, r3
 c004c04:	3708      	adds	r7, #8
 c004c06:	46bd      	mov	sp, r7
 c004c08:	bd80      	pop	{r7, pc}
 c004c0a:	bf00      	nop
 c004c0c:	50030400 	.word	0x50030400

0c004c10 <HAL_PWREx_EnableVddIO2>:
  * @brief Enable VDDIO2 supply.
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
 c004c10:	b480      	push	{r7}
 c004c12:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 c004c14:	4b05      	ldr	r3, [pc, #20]	@ (c004c2c <HAL_PWREx_EnableVddIO2+0x1c>)
 c004c16:	685b      	ldr	r3, [r3, #4]
 c004c18:	4a04      	ldr	r2, [pc, #16]	@ (c004c2c <HAL_PWREx_EnableVddIO2+0x1c>)
 c004c1a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 c004c1e:	6053      	str	r3, [r2, #4]
}
 c004c20:	bf00      	nop
 c004c22:	46bd      	mov	sp, r7
 c004c24:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004c28:	4770      	bx	lr
 c004c2a:	bf00      	nop
 c004c2c:	50007000 	.word	0x50007000

0c004c30 <HAL_PWREx_DisableUCPDDeadBattery>:
  *       or to hand over control to the UCPD (which should therefore be
  *       initialized before doing the disable).
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
 c004c30:	b480      	push	{r7}
 c004c32:	af00      	add	r7, sp, #0
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 c004c34:	4b05      	ldr	r3, [pc, #20]	@ (c004c4c <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 c004c36:	689b      	ldr	r3, [r3, #8]
 c004c38:	4a04      	ldr	r2, [pc, #16]	@ (c004c4c <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 c004c3a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 c004c3e:	6093      	str	r3, [r2, #8]
}
 c004c40:	bf00      	nop
 c004c42:	46bd      	mov	sp, r7
 c004c44:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004c48:	4770      	bx	lr
 c004c4a:	bf00      	nop
 c004c4c:	50007000 	.word	0x50007000

0c004c50 <__acle_se_SecureContext_Init>:
	uint8_t *pucStackStart;				/**< First location of the stack memory. */
} SecureContext_t;
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
{
 c004c50:	b480      	push	{r7}
 c004c52:	b083      	sub	sp, #12
 c004c54:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004c56:	f3ef 8305 	mrs	r3, IPSR
 c004c5a:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004c5c:	687b      	ldr	r3, [r7, #4]
 c004c5e:	2b00      	cmp	r3, #0
 c004c60:	d008      	beq.n	c004c74 <__acle_se_SecureContext_Init+0x24>
	{
		/* No stack for thread mode until a task's context is loaded. */
		secureportSET_PSPLIM( securecontextNO_STACK );
 c004c62:	2300      	movs	r3, #0
 c004c64:	f383 880b 	msr	PSPLIM, r3
		secureportSET_PSP( securecontextNO_STACK );
 c004c68:	2300      	movs	r3, #0
 c004c6a:	f383 8809 	msr	PSP, r3
			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
		}
		#else /* configENABLE_MPU */
		{
			/* Configure thread mode to use PSP and to be privileged.. */
			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
 c004c6e:	2302      	movs	r3, #2
 c004c70:	f383 8814 	msr	CONTROL, r3
		}
		#endif /* configENABLE_MPU */
	}
}
 c004c74:	bf00      	nop
 c004c76:	370c      	adds	r7, #12
 c004c78:	46bd      	mov	sp, r7
 c004c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004c7e:	4670      	mov	r0, lr
 c004c80:	4671      	mov	r1, lr
 c004c82:	4672      	mov	r2, lr
 c004c84:	4673      	mov	r3, lr
 c004c86:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004c8a:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004c8e:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004c92:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004c96:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004c9a:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004c9e:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004ca2:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004ca6:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004caa:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004cae:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004cb2:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004cb6:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004cba:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004cbe:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004cc2:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004cc6:	f38e 8c00 	msr	CPSR_fs, lr
 c004cca:	b410      	push	{r4}
 c004ccc:	eef1 ca10 	vmrs	ip, fpscr
 c004cd0:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004cd4:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004cd8:	ea0c 0c04 	and.w	ip, ip, r4
 c004cdc:	eee1 ca10 	vmsr	fpscr, ip
 c004ce0:	bc10      	pop	{r4}
 c004ce2:	46f4      	mov	ip, lr
 c004ce4:	4774      	bxns	lr

0c004ce6 <__acle_se_SecureContext_AllocateContext>:
#if( configENABLE_MPU == 1 )
	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
#else /* configENABLE_MPU */
	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
#endif /* configENABLE_MPU */
{
 c004ce6:	b580      	push	{r7, lr}
 c004ce8:	b086      	sub	sp, #24
 c004cea:	af00      	add	r7, sp, #0
 c004cec:	6078      	str	r0, [r7, #4]
	uint8_t *pucStackMemory = NULL;
 c004cee:	2300      	movs	r3, #0
 c004cf0:	613b      	str	r3, [r7, #16]
	uint32_t ulIPSR;
	SecureContextHandle_t xSecureContextHandle = NULL;
 c004cf2:	2300      	movs	r3, #0
 c004cf4:	617b      	str	r3, [r7, #20]
	#if( configENABLE_MPU == 1 )
		uint32_t *pulCurrentStackPointer = NULL;
	#endif /* configENABLE_MPU */

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004cf6:	f3ef 8305 	mrs	r3, IPSR
 c004cfa:	60fb      	str	r3, [r7, #12]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004cfc:	68fb      	ldr	r3, [r7, #12]
 c004cfe:	2b00      	cmp	r3, #0
 c004d00:	d01f      	beq.n	c004d42 <__acle_se_SecureContext_AllocateContext+0x5c>
	{
		/* Allocate the context structure. */
		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
 c004d02:	200c      	movs	r0, #12
 c004d04:	f000 f9f8 	bl	c0050f8 <pvPortMalloc>
 c004d08:	6178      	str	r0, [r7, #20]

		if( xSecureContextHandle != NULL )
 c004d0a:	697b      	ldr	r3, [r7, #20]
 c004d0c:	2b00      	cmp	r3, #0
 c004d0e:	d018      	beq.n	c004d42 <__acle_se_SecureContext_AllocateContext+0x5c>
		{
			/* Allocate the stack space. */
			pucStackMemory = pvPortMalloc( ulSecureStackSize );
 c004d10:	6878      	ldr	r0, [r7, #4]
 c004d12:	f000 f9f1 	bl	c0050f8 <pvPortMalloc>
 c004d16:	6138      	str	r0, [r7, #16]

			if( pucStackMemory != NULL )
 c004d18:	693b      	ldr	r3, [r7, #16]
 c004d1a:	2b00      	cmp	r3, #0
 c004d1c:	d00c      	beq.n	c004d38 <__acle_se_SecureContext_AllocateContext+0x52>
				 * location. Note that this location is next to the last
				 * allocated byte because the hardware decrements the stack
				 * pointer before writing i.e. if stack pointer is 0x2, a push
				 * operation will decrement the stack pointer to 0x1 and then
				 * write at 0x1. */
				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
 c004d1e:	693a      	ldr	r2, [r7, #16]
 c004d20:	687b      	ldr	r3, [r7, #4]
 c004d22:	441a      	add	r2, r3
 c004d24:	697b      	ldr	r3, [r7, #20]
 c004d26:	609a      	str	r2, [r3, #8]

				/* The stack cannot go beyond this location. This value is
				 * programmed in the PSPLIM register on context switch.*/
				xSecureContextHandle->pucStackLimit = pucStackMemory;
 c004d28:	697b      	ldr	r3, [r7, #20]
 c004d2a:	693a      	ldr	r2, [r7, #16]
 c004d2c:	605a      	str	r2, [r3, #4]
				}
				#else /* configENABLE_MPU */
				{
					/* Current SP is set to the starting of the stack. This
					 * value programmed in the PSP register on context switch. */
					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
 c004d2e:	697b      	ldr	r3, [r7, #20]
 c004d30:	689a      	ldr	r2, [r3, #8]
 c004d32:	697b      	ldr	r3, [r7, #20]
 c004d34:	601a      	str	r2, [r3, #0]
 c004d36:	e004      	b.n	c004d42 <__acle_se_SecureContext_AllocateContext+0x5c>
			}
			else
			{
				/* Free the context to avoid memory leak and make sure to return
				 * NULL to indicate failure. */
				vPortFree( xSecureContextHandle );
 c004d38:	6978      	ldr	r0, [r7, #20]
 c004d3a:	f000 fa95 	bl	c005268 <vPortFree>
				xSecureContextHandle = NULL;
 c004d3e:	2300      	movs	r3, #0
 c004d40:	617b      	str	r3, [r7, #20]
			}
		}
	}

	return xSecureContextHandle;
 c004d42:	697b      	ldr	r3, [r7, #20]
}
 c004d44:	4618      	mov	r0, r3
 c004d46:	3718      	adds	r7, #24
 c004d48:	46bd      	mov	sp, r7
 c004d4a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c004d4e:	4671      	mov	r1, lr
 c004d50:	4672      	mov	r2, lr
 c004d52:	4673      	mov	r3, lr
 c004d54:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004d58:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004d5c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004d60:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004d64:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004d68:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004d6c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004d70:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004d74:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004d78:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004d7c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004d80:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004d84:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004d88:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004d8c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004d90:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004d94:	f38e 8c00 	msr	CPSR_fs, lr
 c004d98:	b410      	push	{r4}
 c004d9a:	eef1 ca10 	vmrs	ip, fpscr
 c004d9e:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004da2:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004da6:	ea0c 0c04 	and.w	ip, ip, r4
 c004daa:	eee1 ca10 	vmsr	fpscr, ip
 c004dae:	bc10      	pop	{r4}
 c004db0:	46f4      	mov	ip, lr
 c004db2:	4774      	bxns	lr

0c004db4 <__acle_se_SecureContext_FreeContext>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
{
 c004db4:	b580      	push	{r7, lr}
 c004db6:	b084      	sub	sp, #16
 c004db8:	af00      	add	r7, sp, #0
 c004dba:	6078      	str	r0, [r7, #4]
	uint32_t ulIPSR;

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004dbc:	f3ef 8305 	mrs	r3, IPSR
 c004dc0:	60fb      	str	r3, [r7, #12]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004dc2:	68fb      	ldr	r3, [r7, #12]
 c004dc4:	2b00      	cmp	r3, #0
 c004dc6:	d012      	beq.n	c004dee <__acle_se_SecureContext_FreeContext+0x3a>
	{
		/* Ensure that valid parameters are passed. */
		secureportASSERT( xSecureContextHandle != NULL );
 c004dc8:	687b      	ldr	r3, [r7, #4]
 c004dca:	2b00      	cmp	r3, #0
 c004dcc:	d107      	bne.n	c004dde <__acle_se_SecureContext_FreeContext+0x2a>
 c004dce:	2301      	movs	r3, #1
 c004dd0:	f383 8810 	msr	PRIMASK, r3
 c004dd4:	2301      	movs	r3, #1
 c004dd6:	f383 8890 	msr	PRIMASK_NS, r3
 c004dda:	bf00      	nop
 c004ddc:	e7fd      	b.n	c004dda <__acle_se_SecureContext_FreeContext+0x26>

		/* Free the stack space. */
		vPortFree( xSecureContextHandle->pucStackLimit );
 c004dde:	687b      	ldr	r3, [r7, #4]
 c004de0:	685b      	ldr	r3, [r3, #4]
 c004de2:	4618      	mov	r0, r3
 c004de4:	f000 fa40 	bl	c005268 <vPortFree>

		/* Free the context itself. */
		vPortFree( xSecureContextHandle );
 c004de8:	6878      	ldr	r0, [r7, #4]
 c004dea:	f000 fa3d 	bl	c005268 <vPortFree>
	}
}
 c004dee:	bf00      	nop
 c004df0:	3710      	adds	r7, #16
 c004df2:	46bd      	mov	sp, r7
 c004df4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c004df8:	4670      	mov	r0, lr
 c004dfa:	4671      	mov	r1, lr
 c004dfc:	4672      	mov	r2, lr
 c004dfe:	4673      	mov	r3, lr
 c004e00:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004e04:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004e08:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004e0c:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004e10:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004e14:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004e18:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004e1c:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004e20:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004e24:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004e28:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004e2c:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004e30:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004e34:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004e38:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004e3c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004e40:	f38e 8c00 	msr	CPSR_fs, lr
 c004e44:	b410      	push	{r4}
 c004e46:	eef1 ca10 	vmrs	ip, fpscr
 c004e4a:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004e4e:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004e52:	ea0c 0c04 	and.w	ip, ip, r4
 c004e56:	eee1 ca10 	vmsr	fpscr, ip
 c004e5a:	bc10      	pop	{r4}
 c004e5c:	46f4      	mov	ip, lr
 c004e5e:	4774      	bxns	lr

0c004e60 <__acle_se_SecureContext_LoadContext>:

/* Secure port macros. */
#include "secure_port_macros.h"

secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
{
 c004e60:	b480      	push	{r7}
 c004e62:	b083      	sub	sp, #12
 c004e64:	af00      	add	r7, sp, #0
 c004e66:	6078      	str	r0, [r7, #4]
	/* xSecureContextHandle value is in r0. */
	__asm volatile
 c004e68:	f3ef 8105 	mrs	r1, IPSR
 c004e6c:	b121      	cbz	r1, c004e78 <load_ctx_therad_mode>
 c004e6e:	c806      	ldmia	r0!, {r1, r2}
 c004e70:	f382 880b 	msr	PSPLIM, r2
 c004e74:	f381 8809 	msr	PSP, r1

0c004e78 <load_ctx_therad_mode>:
 c004e78:	bf00      	nop
	" load_ctx_therad_mode:						\n"
	"	nop										\n"
	"											\n"
	:::"r0", "r1", "r2"
	);
}
 c004e7a:	bf00      	nop
 c004e7c:	370c      	adds	r7, #12
 c004e7e:	46bd      	mov	sp, r7
 c004e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004e84:	4670      	mov	r0, lr
 c004e86:	4671      	mov	r1, lr
 c004e88:	4672      	mov	r2, lr
 c004e8a:	4673      	mov	r3, lr
 c004e8c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004e90:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004e94:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004e98:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004e9c:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004ea0:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004ea4:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004ea8:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004eac:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004eb0:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004eb4:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004eb8:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004ebc:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004ec0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004ec4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004ec8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004ecc:	f38e 8c00 	msr	CPSR_fs, lr
 c004ed0:	b410      	push	{r4}
 c004ed2:	eef1 ca10 	vmrs	ip, fpscr
 c004ed6:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004eda:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004ede:	ea0c 0c04 	and.w	ip, ip, r4
 c004ee2:	eee1 ca10 	vmsr	fpscr, ip
 c004ee6:	bc10      	pop	{r4}
 c004ee8:	46f4      	mov	ip, lr
 c004eea:	4774      	bxns	lr

0c004eec <__acle_se_SecureContext_SaveContext>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
{
 c004eec:	b480      	push	{r7}
 c004eee:	b083      	sub	sp, #12
 c004ef0:	af00      	add	r7, sp, #0
 c004ef2:	6078      	str	r0, [r7, #4]
	/* xSecureContextHandle value is in r0. */
	__asm volatile
 c004ef4:	f3ef 8105 	mrs	r1, IPSR
 c004ef8:	b139      	cbz	r1, c004f0a <save_ctx_therad_mode>
 c004efa:	f3ef 8109 	mrs	r1, PSP
 c004efe:	6001      	str	r1, [r0, #0]
 c004f00:	2100      	movs	r1, #0
 c004f02:	f381 880b 	msr	PSPLIM, r1
 c004f06:	f381 8809 	msr	PSP, r1

0c004f0a <save_ctx_therad_mode>:
 c004f0a:	bf00      	nop
	" save_ctx_therad_mode:						\n"
	"	nop										\n"
	"											\n"
	:: "i" ( securecontextNO_STACK ) : "r1", "memory"
	);
}
 c004f0c:	bf00      	nop
 c004f0e:	370c      	adds	r7, #12
 c004f10:	46bd      	mov	sp, r7
 c004f12:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004f16:	4670      	mov	r0, lr
 c004f18:	4671      	mov	r1, lr
 c004f1a:	4672      	mov	r2, lr
 c004f1c:	4673      	mov	r3, lr
 c004f1e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004f22:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004f26:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004f2a:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004f2e:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004f32:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004f36:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004f3a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004f3e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004f42:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004f46:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004f4a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004f4e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004f52:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004f56:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004f5a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004f5e:	f38e 8c00 	msr	CPSR_fs, lr
 c004f62:	b410      	push	{r4}
 c004f64:	eef1 ca10 	vmrs	ip, fpscr
 c004f68:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004f6c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004f70:	ea0c 0c04 	and.w	ip, ip, r4
 c004f74:	eee1 ca10 	vmsr	fpscr, ip
 c004f78:	bc10      	pop	{r4}
 c004f7a:	46f4      	mov	ip, lr
 c004f7c:	4774      	bxns	lr
	...

0c004f80 <prvHeapInit>:
 */
static size_t xBlockAllocatedBit = 0;
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 c004f80:	b480      	push	{r7}
 c004f82:	b085      	sub	sp, #20
 c004f84:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
 c004f86:	f44f 5320 	mov.w	r3, #10240	@ 0x2800
 c004f8a:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 c004f8c:	4b27      	ldr	r3, [pc, #156]	@ (c00502c <prvHeapInit+0xac>)
 c004f8e:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
 c004f90:	68fb      	ldr	r3, [r7, #12]
 c004f92:	f003 0307 	and.w	r3, r3, #7
 c004f96:	2b00      	cmp	r3, #0
 c004f98:	d00c      	beq.n	c004fb4 <prvHeapInit+0x34>
	{
		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
 c004f9a:	68fb      	ldr	r3, [r7, #12]
 c004f9c:	3307      	adds	r3, #7
 c004f9e:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
 c004fa0:	68fb      	ldr	r3, [r7, #12]
 c004fa2:	f023 0307 	bic.w	r3, r3, #7
 c004fa6:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 c004fa8:	68ba      	ldr	r2, [r7, #8]
 c004faa:	68fb      	ldr	r3, [r7, #12]
 c004fac:	1ad3      	subs	r3, r2, r3
 c004fae:	4a1f      	ldr	r2, [pc, #124]	@ (c00502c <prvHeapInit+0xac>)
 c004fb0:	4413      	add	r3, r2
 c004fb2:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 c004fb4:	68fb      	ldr	r3, [r7, #12]
 c004fb6:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	 * blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 c004fb8:	4a1d      	ldr	r2, [pc, #116]	@ (c005030 <prvHeapInit+0xb0>)
 c004fba:	687b      	ldr	r3, [r7, #4]
 c004fbc:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 c004fbe:	4b1c      	ldr	r3, [pc, #112]	@ (c005030 <prvHeapInit+0xb0>)
 c004fc0:	2200      	movs	r2, #0
 c004fc2:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	 * at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 c004fc4:	687b      	ldr	r3, [r7, #4]
 c004fc6:	68ba      	ldr	r2, [r7, #8]
 c004fc8:	4413      	add	r3, r2
 c004fca:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 c004fcc:	2208      	movs	r2, #8
 c004fce:	68fb      	ldr	r3, [r7, #12]
 c004fd0:	1a9b      	subs	r3, r3, r2
 c004fd2:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
 c004fd4:	68fb      	ldr	r3, [r7, #12]
 c004fd6:	f023 0307 	bic.w	r3, r3, #7
 c004fda:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 c004fdc:	68fb      	ldr	r3, [r7, #12]
 c004fde:	4a15      	ldr	r2, [pc, #84]	@ (c005034 <prvHeapInit+0xb4>)
 c004fe0:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 c004fe2:	4b14      	ldr	r3, [pc, #80]	@ (c005034 <prvHeapInit+0xb4>)
 c004fe4:	681b      	ldr	r3, [r3, #0]
 c004fe6:	2200      	movs	r2, #0
 c004fe8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 c004fea:	4b12      	ldr	r3, [pc, #72]	@ (c005034 <prvHeapInit+0xb4>)
 c004fec:	681b      	ldr	r3, [r3, #0]
 c004fee:	2200      	movs	r2, #0
 c004ff0:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	 * entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 c004ff2:	687b      	ldr	r3, [r7, #4]
 c004ff4:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 c004ff6:	683b      	ldr	r3, [r7, #0]
 c004ff8:	68fa      	ldr	r2, [r7, #12]
 c004ffa:	1ad2      	subs	r2, r2, r3
 c004ffc:	683b      	ldr	r3, [r7, #0]
 c004ffe:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 c005000:	4b0c      	ldr	r3, [pc, #48]	@ (c005034 <prvHeapInit+0xb4>)
 c005002:	681a      	ldr	r2, [r3, #0]
 c005004:	683b      	ldr	r3, [r7, #0]
 c005006:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 c005008:	683b      	ldr	r3, [r7, #0]
 c00500a:	685b      	ldr	r3, [r3, #4]
 c00500c:	4a0a      	ldr	r2, [pc, #40]	@ (c005038 <prvHeapInit+0xb8>)
 c00500e:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 c005010:	683b      	ldr	r3, [r7, #0]
 c005012:	685b      	ldr	r3, [r3, #4]
 c005014:	4a09      	ldr	r2, [pc, #36]	@ (c00503c <prvHeapInit+0xbc>)
 c005016:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
 c005018:	4b09      	ldr	r3, [pc, #36]	@ (c005040 <prvHeapInit+0xc0>)
 c00501a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 c00501e:	601a      	str	r2, [r3, #0]
}
 c005020:	bf00      	nop
 c005022:	3714      	adds	r7, #20
 c005024:	46bd      	mov	sp, r7
 c005026:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00502a:	4770      	bx	lr
 c00502c:	300004c0 	.word	0x300004c0
 c005030:	30002cc0 	.word	0x30002cc0
 c005034:	30002cc8 	.word	0x30002cc8
 c005038:	30002cd0 	.word	0x30002cd0
 c00503c:	30002ccc 	.word	0x30002ccc
 c005040:	30002cd4 	.word	0x30002cd4

0c005044 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 c005044:	b480      	push	{r7}
 c005046:	b085      	sub	sp, #20
 c005048:	af00      	add	r7, sp, #0
 c00504a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	 * than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 c00504c:	4b28      	ldr	r3, [pc, #160]	@ (c0050f0 <prvInsertBlockIntoFreeList+0xac>)
 c00504e:	60fb      	str	r3, [r7, #12]
 c005050:	e002      	b.n	c005058 <prvInsertBlockIntoFreeList+0x14>
 c005052:	68fb      	ldr	r3, [r7, #12]
 c005054:	681b      	ldr	r3, [r3, #0]
 c005056:	60fb      	str	r3, [r7, #12]
 c005058:	68fb      	ldr	r3, [r7, #12]
 c00505a:	681b      	ldr	r3, [r3, #0]
 c00505c:	687a      	ldr	r2, [r7, #4]
 c00505e:	429a      	cmp	r2, r3
 c005060:	d8f7      	bhi.n	c005052 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	 * make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 c005062:	68fb      	ldr	r3, [r7, #12]
 c005064:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 c005066:	68fb      	ldr	r3, [r7, #12]
 c005068:	685b      	ldr	r3, [r3, #4]
 c00506a:	68ba      	ldr	r2, [r7, #8]
 c00506c:	4413      	add	r3, r2
 c00506e:	687a      	ldr	r2, [r7, #4]
 c005070:	429a      	cmp	r2, r3
 c005072:	d108      	bne.n	c005086 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 c005074:	68fb      	ldr	r3, [r7, #12]
 c005076:	685a      	ldr	r2, [r3, #4]
 c005078:	687b      	ldr	r3, [r7, #4]
 c00507a:	685b      	ldr	r3, [r3, #4]
 c00507c:	441a      	add	r2, r3
 c00507e:	68fb      	ldr	r3, [r7, #12]
 c005080:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 c005082:	68fb      	ldr	r3, [r7, #12]
 c005084:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	 * make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 c005086:	687b      	ldr	r3, [r7, #4]
 c005088:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 c00508a:	687b      	ldr	r3, [r7, #4]
 c00508c:	685b      	ldr	r3, [r3, #4]
 c00508e:	68ba      	ldr	r2, [r7, #8]
 c005090:	441a      	add	r2, r3
 c005092:	68fb      	ldr	r3, [r7, #12]
 c005094:	681b      	ldr	r3, [r3, #0]
 c005096:	429a      	cmp	r2, r3
 c005098:	d118      	bne.n	c0050cc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 c00509a:	68fb      	ldr	r3, [r7, #12]
 c00509c:	681a      	ldr	r2, [r3, #0]
 c00509e:	4b15      	ldr	r3, [pc, #84]	@ (c0050f4 <prvInsertBlockIntoFreeList+0xb0>)
 c0050a0:	681b      	ldr	r3, [r3, #0]
 c0050a2:	429a      	cmp	r2, r3
 c0050a4:	d00d      	beq.n	c0050c2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 c0050a6:	687b      	ldr	r3, [r7, #4]
 c0050a8:	685a      	ldr	r2, [r3, #4]
 c0050aa:	68fb      	ldr	r3, [r7, #12]
 c0050ac:	681b      	ldr	r3, [r3, #0]
 c0050ae:	685b      	ldr	r3, [r3, #4]
 c0050b0:	441a      	add	r2, r3
 c0050b2:	687b      	ldr	r3, [r7, #4]
 c0050b4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 c0050b6:	68fb      	ldr	r3, [r7, #12]
 c0050b8:	681b      	ldr	r3, [r3, #0]
 c0050ba:	681a      	ldr	r2, [r3, #0]
 c0050bc:	687b      	ldr	r3, [r7, #4]
 c0050be:	601a      	str	r2, [r3, #0]
 c0050c0:	e008      	b.n	c0050d4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 c0050c2:	4b0c      	ldr	r3, [pc, #48]	@ (c0050f4 <prvInsertBlockIntoFreeList+0xb0>)
 c0050c4:	681a      	ldr	r2, [r3, #0]
 c0050c6:	687b      	ldr	r3, [r7, #4]
 c0050c8:	601a      	str	r2, [r3, #0]
 c0050ca:	e003      	b.n	c0050d4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 c0050cc:	68fb      	ldr	r3, [r7, #12]
 c0050ce:	681a      	ldr	r2, [r3, #0]
 c0050d0:	687b      	ldr	r3, [r7, #4]
 c0050d2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	 * before and the block after, then it's pxNextFreeBlock pointer will have
	 * already been set, and should not be set here as that would make it point
	 * to itself. */
	if( pxIterator != pxBlockToInsert )
 c0050d4:	68fa      	ldr	r2, [r7, #12]
 c0050d6:	687b      	ldr	r3, [r7, #4]
 c0050d8:	429a      	cmp	r2, r3
 c0050da:	d002      	beq.n	c0050e2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 c0050dc:	68fb      	ldr	r3, [r7, #12]
 c0050de:	687a      	ldr	r2, [r7, #4]
 c0050e0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 c0050e2:	bf00      	nop
 c0050e4:	3714      	adds	r7, #20
 c0050e6:	46bd      	mov	sp, r7
 c0050e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0050ec:	4770      	bx	lr
 c0050ee:	bf00      	nop
 c0050f0:	30002cc0 	.word	0x30002cc0
 c0050f4:	30002cc8 	.word	0x30002cc8

0c0050f8 <pvPortMalloc>:
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 c0050f8:	b580      	push	{r7, lr}
 c0050fa:	b086      	sub	sp, #24
 c0050fc:	af00      	add	r7, sp, #0
 c0050fe:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 c005100:	2300      	movs	r3, #0
 c005102:	60fb      	str	r3, [r7, #12]

	/* If this is the first call to malloc then the heap will require
	 * initialisation to setup the list of free blocks. */
	if( pxEnd == NULL )
 c005104:	4b53      	ldr	r3, [pc, #332]	@ (c005254 <pvPortMalloc+0x15c>)
 c005106:	681b      	ldr	r3, [r3, #0]
 c005108:	2b00      	cmp	r3, #0
 c00510a:	d101      	bne.n	c005110 <pvPortMalloc+0x18>
	{
		prvHeapInit();
 c00510c:	f7ff ff38 	bl	c004f80 <prvHeapInit>

	/* Check the requested block size is not so large that the top bit is set.
	 * The top bit of the block size member of the BlockLink_t structure is used
	 * to determine who owns the block - the application or the kernel, so it
	 * must be free. */
	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 c005110:	4b51      	ldr	r3, [pc, #324]	@ (c005258 <pvPortMalloc+0x160>)
 c005112:	681a      	ldr	r2, [r3, #0]
 c005114:	687b      	ldr	r3, [r7, #4]
 c005116:	4013      	ands	r3, r2
 c005118:	2b00      	cmp	r3, #0
 c00511a:	f040 8088 	bne.w	c00522e <pvPortMalloc+0x136>
	{
		/* The wanted size is increased so it can contain a BlockLink_t
		 * structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 c00511e:	687b      	ldr	r3, [r7, #4]
 c005120:	2b00      	cmp	r3, #0
 c005122:	d01a      	beq.n	c00515a <pvPortMalloc+0x62>
		{
			xWantedSize += xHeapStructSize;
 c005124:	2208      	movs	r2, #8
 c005126:	687b      	ldr	r3, [r7, #4]
 c005128:	4413      	add	r3, r2
 c00512a:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of
			 * bytes. */
			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
 c00512c:	687b      	ldr	r3, [r7, #4]
 c00512e:	f003 0307 	and.w	r3, r3, #7
 c005132:	2b00      	cmp	r3, #0
 c005134:	d011      	beq.n	c00515a <pvPortMalloc+0x62>
			{
				/* Byte alignment required. */
				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
 c005136:	687b      	ldr	r3, [r7, #4]
 c005138:	f023 0307 	bic.w	r3, r3, #7
 c00513c:	3308      	adds	r3, #8
 c00513e:	607b      	str	r3, [r7, #4]
				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c005140:	687b      	ldr	r3, [r7, #4]
 c005142:	f003 0307 	and.w	r3, r3, #7
 c005146:	2b00      	cmp	r3, #0
 c005148:	d007      	beq.n	c00515a <pvPortMalloc+0x62>
 c00514a:	2301      	movs	r3, #1
 c00514c:	f383 8810 	msr	PRIMASK, r3
 c005150:	2301      	movs	r3, #1
 c005152:	f383 8890 	msr	PRIMASK_NS, r3
 c005156:	bf00      	nop
 c005158:	e7fd      	b.n	c005156 <pvPortMalloc+0x5e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 c00515a:	687b      	ldr	r3, [r7, #4]
 c00515c:	2b00      	cmp	r3, #0
 c00515e:	d066      	beq.n	c00522e <pvPortMalloc+0x136>
 c005160:	4b3e      	ldr	r3, [pc, #248]	@ (c00525c <pvPortMalloc+0x164>)
 c005162:	681b      	ldr	r3, [r3, #0]
 c005164:	687a      	ldr	r2, [r7, #4]
 c005166:	429a      	cmp	r2, r3
 c005168:	d861      	bhi.n	c00522e <pvPortMalloc+0x136>
		{
			/* Traverse the list from the start (lowest address) block until
			 * one of adequate size is found. */
			pxPreviousBlock = &xStart;
 c00516a:	4b3d      	ldr	r3, [pc, #244]	@ (c005260 <pvPortMalloc+0x168>)
 c00516c:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
 c00516e:	4b3c      	ldr	r3, [pc, #240]	@ (c005260 <pvPortMalloc+0x168>)
 c005170:	681b      	ldr	r3, [r3, #0]
 c005172:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 c005174:	e004      	b.n	c005180 <pvPortMalloc+0x88>
			{
				pxPreviousBlock = pxBlock;
 c005176:	697b      	ldr	r3, [r7, #20]
 c005178:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
 c00517a:	697b      	ldr	r3, [r7, #20]
 c00517c:	681b      	ldr	r3, [r3, #0]
 c00517e:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 c005180:	697b      	ldr	r3, [r7, #20]
 c005182:	685b      	ldr	r3, [r3, #4]
 c005184:	687a      	ldr	r2, [r7, #4]
 c005186:	429a      	cmp	r2, r3
 c005188:	d903      	bls.n	c005192 <pvPortMalloc+0x9a>
 c00518a:	697b      	ldr	r3, [r7, #20]
 c00518c:	681b      	ldr	r3, [r3, #0]
 c00518e:	2b00      	cmp	r3, #0
 c005190:	d1f1      	bne.n	c005176 <pvPortMalloc+0x7e>
			}

			/* If the end marker was reached then a block of adequate size was
			 * not found. */
			if( pxBlock != pxEnd )
 c005192:	4b30      	ldr	r3, [pc, #192]	@ (c005254 <pvPortMalloc+0x15c>)
 c005194:	681b      	ldr	r3, [r3, #0]
 c005196:	697a      	ldr	r2, [r7, #20]
 c005198:	429a      	cmp	r2, r3
 c00519a:	d048      	beq.n	c00522e <pvPortMalloc+0x136>
			{
				/* Return the memory space pointed to - jumping over the
				 * BlockLink_t structure at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 c00519c:	693b      	ldr	r3, [r7, #16]
 c00519e:	681b      	ldr	r3, [r3, #0]
 c0051a0:	2208      	movs	r2, #8
 c0051a2:	4413      	add	r3, r2
 c0051a4:	60fb      	str	r3, [r7, #12]

				/* This block is being returned for use so must be taken out
				 * of the list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 c0051a6:	697b      	ldr	r3, [r7, #20]
 c0051a8:	681a      	ldr	r2, [r3, #0]
 c0051aa:	693b      	ldr	r3, [r7, #16]
 c0051ac:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into
				 * two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
 c0051ae:	697b      	ldr	r3, [r7, #20]
 c0051b0:	685a      	ldr	r2, [r3, #4]
 c0051b2:	687b      	ldr	r3, [r7, #4]
 c0051b4:	1ad2      	subs	r2, r2, r3
 c0051b6:	2308      	movs	r3, #8
 c0051b8:	005b      	lsls	r3, r3, #1
 c0051ba:	429a      	cmp	r2, r3
 c0051bc:	d91c      	bls.n	c0051f8 <pvPortMalloc+0x100>
				{
					/* This block is to be split into two.  Create a new
					 * block following the number of bytes requested. The void
					 * cast is used to prevent byte alignment warnings from the
					 * compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 c0051be:	697a      	ldr	r2, [r7, #20]
 c0051c0:	687b      	ldr	r3, [r7, #4]
 c0051c2:	4413      	add	r3, r2
 c0051c4:	60bb      	str	r3, [r7, #8]
					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c0051c6:	68bb      	ldr	r3, [r7, #8]
 c0051c8:	f003 0307 	and.w	r3, r3, #7
 c0051cc:	2b00      	cmp	r3, #0
 c0051ce:	d007      	beq.n	c0051e0 <pvPortMalloc+0xe8>
 c0051d0:	2301      	movs	r3, #1
 c0051d2:	f383 8810 	msr	PRIMASK, r3
 c0051d6:	2301      	movs	r3, #1
 c0051d8:	f383 8890 	msr	PRIMASK_NS, r3
 c0051dc:	bf00      	nop
 c0051de:	e7fd      	b.n	c0051dc <pvPortMalloc+0xe4>

					/* Calculate the sizes of two blocks split from the single
					 * block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 c0051e0:	697b      	ldr	r3, [r7, #20]
 c0051e2:	685a      	ldr	r2, [r3, #4]
 c0051e4:	687b      	ldr	r3, [r7, #4]
 c0051e6:	1ad2      	subs	r2, r2, r3
 c0051e8:	68bb      	ldr	r3, [r7, #8]
 c0051ea:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 c0051ec:	697b      	ldr	r3, [r7, #20]
 c0051ee:	687a      	ldr	r2, [r7, #4]
 c0051f0:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( pxNewBlockLink );
 c0051f2:	68b8      	ldr	r0, [r7, #8]
 c0051f4:	f7ff ff26 	bl	c005044 <prvInsertBlockIntoFreeList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 c0051f8:	4b18      	ldr	r3, [pc, #96]	@ (c00525c <pvPortMalloc+0x164>)
 c0051fa:	681a      	ldr	r2, [r3, #0]
 c0051fc:	697b      	ldr	r3, [r7, #20]
 c0051fe:	685b      	ldr	r3, [r3, #4]
 c005200:	1ad3      	subs	r3, r2, r3
 c005202:	4a16      	ldr	r2, [pc, #88]	@ (c00525c <pvPortMalloc+0x164>)
 c005204:	6013      	str	r3, [r2, #0]

				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 c005206:	4b15      	ldr	r3, [pc, #84]	@ (c00525c <pvPortMalloc+0x164>)
 c005208:	681a      	ldr	r2, [r3, #0]
 c00520a:	4b16      	ldr	r3, [pc, #88]	@ (c005264 <pvPortMalloc+0x16c>)
 c00520c:	681b      	ldr	r3, [r3, #0]
 c00520e:	429a      	cmp	r2, r3
 c005210:	d203      	bcs.n	c00521a <pvPortMalloc+0x122>
				{
					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 c005212:	4b12      	ldr	r3, [pc, #72]	@ (c00525c <pvPortMalloc+0x164>)
 c005214:	681b      	ldr	r3, [r3, #0]
 c005216:	4a13      	ldr	r2, [pc, #76]	@ (c005264 <pvPortMalloc+0x16c>)
 c005218:	6013      	str	r3, [r2, #0]
					mtCOVERAGE_TEST_MARKER();
				}

				/* The block is being returned - it is allocated and owned by
				 * the application and has no "next" block. */
				pxBlock->xBlockSize |= xBlockAllocatedBit;
 c00521a:	697b      	ldr	r3, [r7, #20]
 c00521c:	685a      	ldr	r2, [r3, #4]
 c00521e:	4b0e      	ldr	r3, [pc, #56]	@ (c005258 <pvPortMalloc+0x160>)
 c005220:	681b      	ldr	r3, [r3, #0]
 c005222:	431a      	orrs	r2, r3
 c005224:	697b      	ldr	r3, [r7, #20]
 c005226:	605a      	str	r2, [r3, #4]
				pxBlock->pxNextFreeBlock = NULL;
 c005228:	697b      	ldr	r3, [r7, #20]
 c00522a:	2200      	movs	r2, #0
 c00522c:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c00522e:	68fb      	ldr	r3, [r7, #12]
 c005230:	f003 0307 	and.w	r3, r3, #7
 c005234:	2b00      	cmp	r3, #0
 c005236:	d007      	beq.n	c005248 <pvPortMalloc+0x150>
 c005238:	2301      	movs	r3, #1
 c00523a:	f383 8810 	msr	PRIMASK, r3
 c00523e:	2301      	movs	r3, #1
 c005240:	f383 8890 	msr	PRIMASK_NS, r3
 c005244:	bf00      	nop
 c005246:	e7fd      	b.n	c005244 <pvPortMalloc+0x14c>
	return pvReturn;
 c005248:	68fb      	ldr	r3, [r7, #12]
}
 c00524a:	4618      	mov	r0, r3
 c00524c:	3718      	adds	r7, #24
 c00524e:	46bd      	mov	sp, r7
 c005250:	bd80      	pop	{r7, pc}
 c005252:	bf00      	nop
 c005254:	30002cc8 	.word	0x30002cc8
 c005258:	30002cd4 	.word	0x30002cd4
 c00525c:	30002ccc 	.word	0x30002ccc
 c005260:	30002cc0 	.word	0x30002cc0
 c005264:	30002cd0 	.word	0x30002cd0

0c005268 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 c005268:	b580      	push	{r7, lr}
 c00526a:	b084      	sub	sp, #16
 c00526c:	af00      	add	r7, sp, #0
 c00526e:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 c005270:	687b      	ldr	r3, [r7, #4]
 c005272:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
 c005274:	687b      	ldr	r3, [r7, #4]
 c005276:	2b00      	cmp	r3, #0
 c005278:	d044      	beq.n	c005304 <vPortFree+0x9c>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		 * before it. */
		puc -= xHeapStructSize;
 c00527a:	2308      	movs	r3, #8
 c00527c:	425b      	negs	r3, r3
 c00527e:	68fa      	ldr	r2, [r7, #12]
 c005280:	4413      	add	r3, r2
 c005282:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 c005284:	68fb      	ldr	r3, [r7, #12]
 c005286:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 c005288:	68bb      	ldr	r3, [r7, #8]
 c00528a:	685a      	ldr	r2, [r3, #4]
 c00528c:	4b1f      	ldr	r3, [pc, #124]	@ (c00530c <vPortFree+0xa4>)
 c00528e:	681b      	ldr	r3, [r3, #0]
 c005290:	4013      	ands	r3, r2
 c005292:	2b00      	cmp	r3, #0
 c005294:	d107      	bne.n	c0052a6 <vPortFree+0x3e>
 c005296:	2301      	movs	r3, #1
 c005298:	f383 8810 	msr	PRIMASK, r3
 c00529c:	2301      	movs	r3, #1
 c00529e:	f383 8890 	msr	PRIMASK_NS, r3
 c0052a2:	bf00      	nop
 c0052a4:	e7fd      	b.n	c0052a2 <vPortFree+0x3a>
		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
 c0052a6:	68bb      	ldr	r3, [r7, #8]
 c0052a8:	681b      	ldr	r3, [r3, #0]
 c0052aa:	2b00      	cmp	r3, #0
 c0052ac:	d007      	beq.n	c0052be <vPortFree+0x56>
 c0052ae:	2301      	movs	r3, #1
 c0052b0:	f383 8810 	msr	PRIMASK, r3
 c0052b4:	2301      	movs	r3, #1
 c0052b6:	f383 8890 	msr	PRIMASK_NS, r3
 c0052ba:	bf00      	nop
 c0052bc:	e7fd      	b.n	c0052ba <vPortFree+0x52>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 c0052be:	68bb      	ldr	r3, [r7, #8]
 c0052c0:	685a      	ldr	r2, [r3, #4]
 c0052c2:	4b12      	ldr	r3, [pc, #72]	@ (c00530c <vPortFree+0xa4>)
 c0052c4:	681b      	ldr	r3, [r3, #0]
 c0052c6:	4013      	ands	r3, r2
 c0052c8:	2b00      	cmp	r3, #0
 c0052ca:	d01b      	beq.n	c005304 <vPortFree+0x9c>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 c0052cc:	68bb      	ldr	r3, [r7, #8]
 c0052ce:	681b      	ldr	r3, [r3, #0]
 c0052d0:	2b00      	cmp	r3, #0
 c0052d2:	d117      	bne.n	c005304 <vPortFree+0x9c>
			{
				/* The block is being returned to the heap - it is no longer
				 * allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 c0052d4:	68bb      	ldr	r3, [r7, #8]
 c0052d6:	685a      	ldr	r2, [r3, #4]
 c0052d8:	4b0c      	ldr	r3, [pc, #48]	@ (c00530c <vPortFree+0xa4>)
 c0052da:	681b      	ldr	r3, [r3, #0]
 c0052dc:	43db      	mvns	r3, r3
 c0052de:	401a      	ands	r2, r3
 c0052e0:	68bb      	ldr	r3, [r7, #8]
 c0052e2:	605a      	str	r2, [r3, #4]

				secureportDISABLE_NON_SECURE_INTERRUPTS();
 c0052e4:	2301      	movs	r3, #1
 c0052e6:	f383 8890 	msr	PRIMASK_NS, r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 c0052ea:	68bb      	ldr	r3, [r7, #8]
 c0052ec:	685a      	ldr	r2, [r3, #4]
 c0052ee:	4b08      	ldr	r3, [pc, #32]	@ (c005310 <vPortFree+0xa8>)
 c0052f0:	681b      	ldr	r3, [r3, #0]
 c0052f2:	4413      	add	r3, r2
 c0052f4:	4a06      	ldr	r2, [pc, #24]	@ (c005310 <vPortFree+0xa8>)
 c0052f6:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 c0052f8:	68b8      	ldr	r0, [r7, #8]
 c0052fa:	f7ff fea3 	bl	c005044 <prvInsertBlockIntoFreeList>
				}
				secureportENABLE_NON_SECURE_INTERRUPTS();
 c0052fe:	2300      	movs	r3, #0
 c005300:	f383 8890 	msr	PRIMASK_NS, r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 c005304:	bf00      	nop
 c005306:	3710      	adds	r7, #16
 c005308:	46bd      	mov	sp, r7
 c00530a:	bd80      	pop	{r7, pc}
 c00530c:	30002cd4 	.word	0x30002cd4
 c005310:	30002ccc 	.word	0x30002ccc

0c005314 <__acle_se_SecureInit_DePrioritizeNSExceptions>:
#define secureinitNSACR_CP11_POS			( 11UL )
#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
{
 c005314:	b480      	push	{r7}
 c005316:	b083      	sub	sp, #12
 c005318:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	 /* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c00531a:	f3ef 8305 	mrs	r3, IPSR
 c00531e:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c005320:	687b      	ldr	r3, [r7, #4]
 c005322:	2b00      	cmp	r3, #0
 c005324:	d008      	beq.n	c005338 <__acle_se_SecureInit_DePrioritizeNSExceptions+0x24>
	{
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c005326:	4b21      	ldr	r3, [pc, #132]	@ (c0053ac <__acle_se_SecureInit_DePrioritizeNSExceptions+0x98>)
 c005328:	681b      	ldr	r3, [r3, #0]
									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
 c00532a:	b29b      	uxth	r3, r3
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c00532c:	4a1f      	ldr	r2, [pc, #124]	@ (c0053ac <__acle_se_SecureInit_DePrioritizeNSExceptions+0x98>)
									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
 c00532e:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 c005332:	f443 3310 	orr.w	r3, r3, #147456	@ 0x24000
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c005336:	6013      	str	r3, [r2, #0]
									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
	}
}
 c005338:	bf00      	nop
 c00533a:	370c      	adds	r7, #12
 c00533c:	46bd      	mov	sp, r7
 c00533e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c005342:	4670      	mov	r0, lr
 c005344:	4671      	mov	r1, lr
 c005346:	4672      	mov	r2, lr
 c005348:	4673      	mov	r3, lr
 c00534a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c00534e:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c005352:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c005356:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00535a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00535e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c005362:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c005366:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00536a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00536e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c005372:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c005376:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00537a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00537e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c005382:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c005386:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00538a:	f38e 8c00 	msr	CPSR_fs, lr
 c00538e:	b410      	push	{r4}
 c005390:	eef1 ca10 	vmrs	ip, fpscr
 c005394:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c005398:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00539c:	ea0c 0c04 	and.w	ip, ip, r4
 c0053a0:	eee1 ca10 	vmsr	fpscr, ip
 c0053a4:	bc10      	pop	{r4}
 c0053a6:	46f4      	mov	ip, lr
 c0053a8:	4774      	bxns	lr
 c0053aa:	bf00      	nop
 c0053ac:	e000ed0c 	.word	0xe000ed0c

0c0053b0 <__acle_se_SecureInit_EnableNSFPUAccess>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
{
 c0053b0:	b480      	push	{r7}
 c0053b2:	b083      	sub	sp, #12
 c0053b4:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	 /* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c0053b6:	f3ef 8305 	mrs	r3, IPSR
 c0053ba:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c0053bc:	687b      	ldr	r3, [r7, #4]
 c0053be:	2b00      	cmp	r3, #0
 c0053c0:	d011      	beq.n	c0053e6 <__acle_se_SecureInit_EnableNSFPUAccess+0x36>
	{
		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
		 * permitted. CP11 should be programmed to the same value as CP10. */
		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
 c0053c2:	4b25      	ldr	r3, [pc, #148]	@ (c005458 <__acle_se_SecureInit_EnableNSFPUAccess+0xa8>)
 c0053c4:	681b      	ldr	r3, [r3, #0]
 c0053c6:	4a24      	ldr	r2, [pc, #144]	@ (c005458 <__acle_se_SecureInit_EnableNSFPUAccess+0xa8>)
 c0053c8:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c0053cc:	6013      	str	r3, [r2, #0]

		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
		 * that we can enable/disable lazy stacking in port.c file. */
		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
 c0053ce:	4b23      	ldr	r3, [pc, #140]	@ (c00545c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053d0:	681b      	ldr	r3, [r3, #0]
 c0053d2:	4a22      	ldr	r2, [pc, #136]	@ (c00545c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053d4:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 c0053d8:	6013      	str	r3, [r2, #0]

		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
		 * registers (S16-S31) are also pushed to stack on exception entry and
		 * restored on exception return. */
		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
 c0053da:	4b20      	ldr	r3, [pc, #128]	@ (c00545c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053dc:	681b      	ldr	r3, [r3, #0]
 c0053de:	4a1f      	ldr	r2, [pc, #124]	@ (c00545c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053e0:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 c0053e4:	6013      	str	r3, [r2, #0]
	}
}
 c0053e6:	bf00      	nop
 c0053e8:	370c      	adds	r7, #12
 c0053ea:	46bd      	mov	sp, r7
 c0053ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0053f0:	4670      	mov	r0, lr
 c0053f2:	4671      	mov	r1, lr
 c0053f4:	4672      	mov	r2, lr
 c0053f6:	4673      	mov	r3, lr
 c0053f8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0053fc:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c005400:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c005404:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c005408:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00540c:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c005410:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c005414:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c005418:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00541c:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c005420:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c005424:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c005428:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00542c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c005430:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c005434:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c005438:	f38e 8c00 	msr	CPSR_fs, lr
 c00543c:	b410      	push	{r4}
 c00543e:	eef1 ca10 	vmrs	ip, fpscr
 c005442:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c005446:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00544a:	ea0c 0c04 	and.w	ip, ip, r4
 c00544e:	eee1 ca10 	vmsr	fpscr, ip
 c005452:	bc10      	pop	{r4}
 c005454:	46f4      	mov	ip, lr
 c005456:	4774      	bxns	lr
 c005458:	e000ed8c 	.word	0xe000ed8c
 c00545c:	e000ef34 	.word	0xe000ef34

0c005460 <malloc>:
 c005460:	4b02      	ldr	r3, [pc, #8]	@ (c00546c <malloc+0xc>)
 c005462:	4601      	mov	r1, r0
 c005464:	6818      	ldr	r0, [r3, #0]
 c005466:	f000 b825 	b.w	c0054b4 <_malloc_r>
 c00546a:	bf00      	nop
 c00546c:	3000004c 	.word	0x3000004c

0c005470 <sbrk_aligned>:
 c005470:	b570      	push	{r4, r5, r6, lr}
 c005472:	4e0f      	ldr	r6, [pc, #60]	@ (c0054b0 <sbrk_aligned+0x40>)
 c005474:	460c      	mov	r4, r1
 c005476:	4605      	mov	r5, r0
 c005478:	6831      	ldr	r1, [r6, #0]
 c00547a:	b911      	cbnz	r1, c005482 <sbrk_aligned+0x12>
 c00547c:	f000 fb6c 	bl	c005b58 <_sbrk_r>
 c005480:	6030      	str	r0, [r6, #0]
 c005482:	4621      	mov	r1, r4
 c005484:	4628      	mov	r0, r5
 c005486:	f000 fb67 	bl	c005b58 <_sbrk_r>
 c00548a:	1c43      	adds	r3, r0, #1
 c00548c:	d103      	bne.n	c005496 <sbrk_aligned+0x26>
 c00548e:	f04f 34ff 	mov.w	r4, #4294967295
 c005492:	4620      	mov	r0, r4
 c005494:	bd70      	pop	{r4, r5, r6, pc}
 c005496:	1cc4      	adds	r4, r0, #3
 c005498:	f024 0403 	bic.w	r4, r4, #3
 c00549c:	42a0      	cmp	r0, r4
 c00549e:	d0f8      	beq.n	c005492 <sbrk_aligned+0x22>
 c0054a0:	1a21      	subs	r1, r4, r0
 c0054a2:	4628      	mov	r0, r5
 c0054a4:	f000 fb58 	bl	c005b58 <_sbrk_r>
 c0054a8:	3001      	adds	r0, #1
 c0054aa:	d1f2      	bne.n	c005492 <sbrk_aligned+0x22>
 c0054ac:	e7ef      	b.n	c00548e <sbrk_aligned+0x1e>
 c0054ae:	bf00      	nop
 c0054b0:	30002cd8 	.word	0x30002cd8

0c0054b4 <_malloc_r>:
 c0054b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0054b8:	1ccd      	adds	r5, r1, #3
 c0054ba:	4606      	mov	r6, r0
 c0054bc:	f025 0503 	bic.w	r5, r5, #3
 c0054c0:	3508      	adds	r5, #8
 c0054c2:	2d0c      	cmp	r5, #12
 c0054c4:	bf38      	it	cc
 c0054c6:	250c      	movcc	r5, #12
 c0054c8:	2d00      	cmp	r5, #0
 c0054ca:	db01      	blt.n	c0054d0 <_malloc_r+0x1c>
 c0054cc:	42a9      	cmp	r1, r5
 c0054ce:	d904      	bls.n	c0054da <_malloc_r+0x26>
 c0054d0:	230c      	movs	r3, #12
 c0054d2:	6033      	str	r3, [r6, #0]
 c0054d4:	2000      	movs	r0, #0
 c0054d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c0054da:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ c0055b0 <_malloc_r+0xfc>
 c0054de:	f000 f869 	bl	c0055b4 <__malloc_lock>
 c0054e2:	f8d8 3000 	ldr.w	r3, [r8]
 c0054e6:	461c      	mov	r4, r3
 c0054e8:	bb44      	cbnz	r4, c00553c <_malloc_r+0x88>
 c0054ea:	4629      	mov	r1, r5
 c0054ec:	4630      	mov	r0, r6
 c0054ee:	f7ff ffbf 	bl	c005470 <sbrk_aligned>
 c0054f2:	1c43      	adds	r3, r0, #1
 c0054f4:	4604      	mov	r4, r0
 c0054f6:	d158      	bne.n	c0055aa <_malloc_r+0xf6>
 c0054f8:	f8d8 4000 	ldr.w	r4, [r8]
 c0054fc:	4627      	mov	r7, r4
 c0054fe:	2f00      	cmp	r7, #0
 c005500:	d143      	bne.n	c00558a <_malloc_r+0xd6>
 c005502:	2c00      	cmp	r4, #0
 c005504:	d04b      	beq.n	c00559e <_malloc_r+0xea>
 c005506:	6823      	ldr	r3, [r4, #0]
 c005508:	4639      	mov	r1, r7
 c00550a:	4630      	mov	r0, r6
 c00550c:	eb04 0903 	add.w	r9, r4, r3
 c005510:	f000 fb22 	bl	c005b58 <_sbrk_r>
 c005514:	4581      	cmp	r9, r0
 c005516:	d142      	bne.n	c00559e <_malloc_r+0xea>
 c005518:	6821      	ldr	r1, [r4, #0]
 c00551a:	4630      	mov	r0, r6
 c00551c:	1a6d      	subs	r5, r5, r1
 c00551e:	4629      	mov	r1, r5
 c005520:	f7ff ffa6 	bl	c005470 <sbrk_aligned>
 c005524:	3001      	adds	r0, #1
 c005526:	d03a      	beq.n	c00559e <_malloc_r+0xea>
 c005528:	6823      	ldr	r3, [r4, #0]
 c00552a:	442b      	add	r3, r5
 c00552c:	6023      	str	r3, [r4, #0]
 c00552e:	f8d8 3000 	ldr.w	r3, [r8]
 c005532:	685a      	ldr	r2, [r3, #4]
 c005534:	bb62      	cbnz	r2, c005590 <_malloc_r+0xdc>
 c005536:	f8c8 7000 	str.w	r7, [r8]
 c00553a:	e00f      	b.n	c00555c <_malloc_r+0xa8>
 c00553c:	6822      	ldr	r2, [r4, #0]
 c00553e:	1b52      	subs	r2, r2, r5
 c005540:	d420      	bmi.n	c005584 <_malloc_r+0xd0>
 c005542:	2a0b      	cmp	r2, #11
 c005544:	d917      	bls.n	c005576 <_malloc_r+0xc2>
 c005546:	1961      	adds	r1, r4, r5
 c005548:	42a3      	cmp	r3, r4
 c00554a:	6025      	str	r5, [r4, #0]
 c00554c:	bf18      	it	ne
 c00554e:	6059      	strne	r1, [r3, #4]
 c005550:	6863      	ldr	r3, [r4, #4]
 c005552:	bf08      	it	eq
 c005554:	f8c8 1000 	streq.w	r1, [r8]
 c005558:	5162      	str	r2, [r4, r5]
 c00555a:	604b      	str	r3, [r1, #4]
 c00555c:	4630      	mov	r0, r6
 c00555e:	f000 f82f 	bl	c0055c0 <__malloc_unlock>
 c005562:	f104 000b 	add.w	r0, r4, #11
 c005566:	1d23      	adds	r3, r4, #4
 c005568:	f020 0007 	bic.w	r0, r0, #7
 c00556c:	1ac2      	subs	r2, r0, r3
 c00556e:	bf1c      	itt	ne
 c005570:	1a1b      	subne	r3, r3, r0
 c005572:	50a3      	strne	r3, [r4, r2]
 c005574:	e7af      	b.n	c0054d6 <_malloc_r+0x22>
 c005576:	6862      	ldr	r2, [r4, #4]
 c005578:	42a3      	cmp	r3, r4
 c00557a:	bf0c      	ite	eq
 c00557c:	f8c8 2000 	streq.w	r2, [r8]
 c005580:	605a      	strne	r2, [r3, #4]
 c005582:	e7eb      	b.n	c00555c <_malloc_r+0xa8>
 c005584:	4623      	mov	r3, r4
 c005586:	6864      	ldr	r4, [r4, #4]
 c005588:	e7ae      	b.n	c0054e8 <_malloc_r+0x34>
 c00558a:	463c      	mov	r4, r7
 c00558c:	687f      	ldr	r7, [r7, #4]
 c00558e:	e7b6      	b.n	c0054fe <_malloc_r+0x4a>
 c005590:	461a      	mov	r2, r3
 c005592:	685b      	ldr	r3, [r3, #4]
 c005594:	42a3      	cmp	r3, r4
 c005596:	d1fb      	bne.n	c005590 <_malloc_r+0xdc>
 c005598:	2300      	movs	r3, #0
 c00559a:	6053      	str	r3, [r2, #4]
 c00559c:	e7de      	b.n	c00555c <_malloc_r+0xa8>
 c00559e:	230c      	movs	r3, #12
 c0055a0:	4630      	mov	r0, r6
 c0055a2:	6033      	str	r3, [r6, #0]
 c0055a4:	f000 f80c 	bl	c0055c0 <__malloc_unlock>
 c0055a8:	e794      	b.n	c0054d4 <_malloc_r+0x20>
 c0055aa:	6005      	str	r5, [r0, #0]
 c0055ac:	e7d6      	b.n	c00555c <_malloc_r+0xa8>
 c0055ae:	bf00      	nop
 c0055b0:	30002cdc 	.word	0x30002cdc

0c0055b4 <__malloc_lock>:
 c0055b4:	4801      	ldr	r0, [pc, #4]	@ (c0055bc <__malloc_lock+0x8>)
 c0055b6:	f000 bb1c 	b.w	c005bf2 <__retarget_lock_acquire_recursive>
 c0055ba:	bf00      	nop
 c0055bc:	30002e20 	.word	0x30002e20

0c0055c0 <__malloc_unlock>:
 c0055c0:	4801      	ldr	r0, [pc, #4]	@ (c0055c8 <__malloc_unlock+0x8>)
 c0055c2:	f000 bb17 	b.w	c005bf4 <__retarget_lock_release_recursive>
 c0055c6:	bf00      	nop
 c0055c8:	30002e20 	.word	0x30002e20

0c0055cc <srand>:
 c0055cc:	b538      	push	{r3, r4, r5, lr}
 c0055ce:	4b10      	ldr	r3, [pc, #64]	@ (c005610 <srand+0x44>)
 c0055d0:	4604      	mov	r4, r0
 c0055d2:	681d      	ldr	r5, [r3, #0]
 c0055d4:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 c0055d6:	b9b3      	cbnz	r3, c005606 <srand+0x3a>
 c0055d8:	2018      	movs	r0, #24
 c0055da:	f7ff ff41 	bl	c005460 <malloc>
 c0055de:	4602      	mov	r2, r0
 c0055e0:	6328      	str	r0, [r5, #48]	@ 0x30
 c0055e2:	b920      	cbnz	r0, c0055ee <srand+0x22>
 c0055e4:	4b0b      	ldr	r3, [pc, #44]	@ (c005614 <srand+0x48>)
 c0055e6:	2146      	movs	r1, #70	@ 0x46
 c0055e8:	480b      	ldr	r0, [pc, #44]	@ (c005618 <srand+0x4c>)
 c0055ea:	f000 fb11 	bl	c005c10 <__assert_func>
 c0055ee:	490b      	ldr	r1, [pc, #44]	@ (c00561c <srand+0x50>)
 c0055f0:	4b0b      	ldr	r3, [pc, #44]	@ (c005620 <srand+0x54>)
 c0055f2:	e9c0 1300 	strd	r1, r3, [r0]
 c0055f6:	4b0b      	ldr	r3, [pc, #44]	@ (c005624 <srand+0x58>)
 c0055f8:	2100      	movs	r1, #0
 c0055fa:	6083      	str	r3, [r0, #8]
 c0055fc:	230b      	movs	r3, #11
 c0055fe:	8183      	strh	r3, [r0, #12]
 c005600:	2001      	movs	r0, #1
 c005602:	e9c2 0104 	strd	r0, r1, [r2, #16]
 c005606:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 c005608:	2200      	movs	r2, #0
 c00560a:	611c      	str	r4, [r3, #16]
 c00560c:	615a      	str	r2, [r3, #20]
 c00560e:	bd38      	pop	{r3, r4, r5, pc}
 c005610:	3000004c 	.word	0x3000004c
 c005614:	0c006cdc 	.word	0x0c006cdc
 c005618:	0c006cf3 	.word	0x0c006cf3
 c00561c:	abcd330e 	.word	0xabcd330e
 c005620:	e66d1234 	.word	0xe66d1234
 c005624:	0005deec 	.word	0x0005deec

0c005628 <rand>:
 c005628:	4b16      	ldr	r3, [pc, #88]	@ (c005684 <rand+0x5c>)
 c00562a:	b510      	push	{r4, lr}
 c00562c:	681c      	ldr	r4, [r3, #0]
 c00562e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c005630:	b9b3      	cbnz	r3, c005660 <rand+0x38>
 c005632:	2018      	movs	r0, #24
 c005634:	f7ff ff14 	bl	c005460 <malloc>
 c005638:	4602      	mov	r2, r0
 c00563a:	6320      	str	r0, [r4, #48]	@ 0x30
 c00563c:	b920      	cbnz	r0, c005648 <rand+0x20>
 c00563e:	4b12      	ldr	r3, [pc, #72]	@ (c005688 <rand+0x60>)
 c005640:	2152      	movs	r1, #82	@ 0x52
 c005642:	4812      	ldr	r0, [pc, #72]	@ (c00568c <rand+0x64>)
 c005644:	f000 fae4 	bl	c005c10 <__assert_func>
 c005648:	4911      	ldr	r1, [pc, #68]	@ (c005690 <rand+0x68>)
 c00564a:	4b12      	ldr	r3, [pc, #72]	@ (c005694 <rand+0x6c>)
 c00564c:	e9c0 1300 	strd	r1, r3, [r0]
 c005650:	4b11      	ldr	r3, [pc, #68]	@ (c005698 <rand+0x70>)
 c005652:	2100      	movs	r1, #0
 c005654:	6083      	str	r3, [r0, #8]
 c005656:	230b      	movs	r3, #11
 c005658:	8183      	strh	r3, [r0, #12]
 c00565a:	2001      	movs	r0, #1
 c00565c:	e9c2 0104 	strd	r0, r1, [r2, #16]
 c005660:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 c005662:	480e      	ldr	r0, [pc, #56]	@ (c00569c <rand+0x74>)
 c005664:	690b      	ldr	r3, [r1, #16]
 c005666:	694c      	ldr	r4, [r1, #20]
 c005668:	4a0d      	ldr	r2, [pc, #52]	@ (c0056a0 <rand+0x78>)
 c00566a:	4358      	muls	r0, r3
 c00566c:	fb02 0004 	mla	r0, r2, r4, r0
 c005670:	fba3 3202 	umull	r3, r2, r3, r2
 c005674:	3301      	adds	r3, #1
 c005676:	eb40 0002 	adc.w	r0, r0, r2
 c00567a:	e9c1 3004 	strd	r3, r0, [r1, #16]
 c00567e:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 c005682:	bd10      	pop	{r4, pc}
 c005684:	3000004c 	.word	0x3000004c
 c005688:	0c006cdc 	.word	0x0c006cdc
 c00568c:	0c006cf3 	.word	0x0c006cf3
 c005690:	abcd330e 	.word	0xabcd330e
 c005694:	e66d1234 	.word	0xe66d1234
 c005698:	0005deec 	.word	0x0005deec
 c00569c:	5851f42d 	.word	0x5851f42d
 c0056a0:	4c957f2d 	.word	0x4c957f2d

0c0056a4 <std>:
 c0056a4:	2300      	movs	r3, #0
 c0056a6:	b510      	push	{r4, lr}
 c0056a8:	4604      	mov	r4, r0
 c0056aa:	6083      	str	r3, [r0, #8]
 c0056ac:	8181      	strh	r1, [r0, #12]
 c0056ae:	4619      	mov	r1, r3
 c0056b0:	6643      	str	r3, [r0, #100]	@ 0x64
 c0056b2:	81c2      	strh	r2, [r0, #14]
 c0056b4:	2208      	movs	r2, #8
 c0056b6:	6183      	str	r3, [r0, #24]
 c0056b8:	e9c0 3300 	strd	r3, r3, [r0]
 c0056bc:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c0056c0:	305c      	adds	r0, #92	@ 0x5c
 c0056c2:	f000 f9f9 	bl	c005ab8 <memset>
 c0056c6:	4b0d      	ldr	r3, [pc, #52]	@ (c0056fc <std+0x58>)
 c0056c8:	6224      	str	r4, [r4, #32]
 c0056ca:	6263      	str	r3, [r4, #36]	@ 0x24
 c0056cc:	4b0c      	ldr	r3, [pc, #48]	@ (c005700 <std+0x5c>)
 c0056ce:	62a3      	str	r3, [r4, #40]	@ 0x28
 c0056d0:	4b0c      	ldr	r3, [pc, #48]	@ (c005704 <std+0x60>)
 c0056d2:	62e3      	str	r3, [r4, #44]	@ 0x2c
 c0056d4:	4b0c      	ldr	r3, [pc, #48]	@ (c005708 <std+0x64>)
 c0056d6:	6323      	str	r3, [r4, #48]	@ 0x30
 c0056d8:	4b0c      	ldr	r3, [pc, #48]	@ (c00570c <std+0x68>)
 c0056da:	429c      	cmp	r4, r3
 c0056dc:	d006      	beq.n	c0056ec <std+0x48>
 c0056de:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 c0056e2:	4294      	cmp	r4, r2
 c0056e4:	d002      	beq.n	c0056ec <std+0x48>
 c0056e6:	33d0      	adds	r3, #208	@ 0xd0
 c0056e8:	429c      	cmp	r4, r3
 c0056ea:	d105      	bne.n	c0056f8 <std+0x54>
 c0056ec:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 c0056f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0056f4:	f000 ba7c 	b.w	c005bf0 <__retarget_lock_init_recursive>
 c0056f8:	bd10      	pop	{r4, pc}
 c0056fa:	bf00      	nop
 c0056fc:	0c005909 	.word	0x0c005909
 c005700:	0c00592b 	.word	0x0c00592b
 c005704:	0c005963 	.word	0x0c005963
 c005708:	0c005987 	.word	0x0c005987
 c00570c:	30002ce0 	.word	0x30002ce0

0c005710 <stdio_exit_handler>:
 c005710:	4a02      	ldr	r2, [pc, #8]	@ (c00571c <stdio_exit_handler+0xc>)
 c005712:	4903      	ldr	r1, [pc, #12]	@ (c005720 <stdio_exit_handler+0x10>)
 c005714:	4803      	ldr	r0, [pc, #12]	@ (c005724 <stdio_exit_handler+0x14>)
 c005716:	f000 b869 	b.w	c0057ec <_fwalk_sglue>
 c00571a:	bf00      	nop
 c00571c:	30000040 	.word	0x30000040
 c005720:	0c00638d 	.word	0x0c00638d
 c005724:	30000050 	.word	0x30000050

0c005728 <cleanup_stdio>:
 c005728:	6841      	ldr	r1, [r0, #4]
 c00572a:	4b0c      	ldr	r3, [pc, #48]	@ (c00575c <cleanup_stdio+0x34>)
 c00572c:	4299      	cmp	r1, r3
 c00572e:	b510      	push	{r4, lr}
 c005730:	4604      	mov	r4, r0
 c005732:	d001      	beq.n	c005738 <cleanup_stdio+0x10>
 c005734:	f000 fe2a 	bl	c00638c <_fflush_r>
 c005738:	68a1      	ldr	r1, [r4, #8]
 c00573a:	4b09      	ldr	r3, [pc, #36]	@ (c005760 <cleanup_stdio+0x38>)
 c00573c:	4299      	cmp	r1, r3
 c00573e:	d002      	beq.n	c005746 <cleanup_stdio+0x1e>
 c005740:	4620      	mov	r0, r4
 c005742:	f000 fe23 	bl	c00638c <_fflush_r>
 c005746:	68e1      	ldr	r1, [r4, #12]
 c005748:	4b06      	ldr	r3, [pc, #24]	@ (c005764 <cleanup_stdio+0x3c>)
 c00574a:	4299      	cmp	r1, r3
 c00574c:	d004      	beq.n	c005758 <cleanup_stdio+0x30>
 c00574e:	4620      	mov	r0, r4
 c005750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c005754:	f000 be1a 	b.w	c00638c <_fflush_r>
 c005758:	bd10      	pop	{r4, pc}
 c00575a:	bf00      	nop
 c00575c:	30002ce0 	.word	0x30002ce0
 c005760:	30002d48 	.word	0x30002d48
 c005764:	30002db0 	.word	0x30002db0

0c005768 <global_stdio_init.part.0>:
 c005768:	b510      	push	{r4, lr}
 c00576a:	4b0b      	ldr	r3, [pc, #44]	@ (c005798 <global_stdio_init.part.0+0x30>)
 c00576c:	2104      	movs	r1, #4
 c00576e:	4c0b      	ldr	r4, [pc, #44]	@ (c00579c <global_stdio_init.part.0+0x34>)
 c005770:	4a0b      	ldr	r2, [pc, #44]	@ (c0057a0 <global_stdio_init.part.0+0x38>)
 c005772:	4620      	mov	r0, r4
 c005774:	601a      	str	r2, [r3, #0]
 c005776:	2200      	movs	r2, #0
 c005778:	f7ff ff94 	bl	c0056a4 <std>
 c00577c:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 c005780:	2201      	movs	r2, #1
 c005782:	2109      	movs	r1, #9
 c005784:	f7ff ff8e 	bl	c0056a4 <std>
 c005788:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 c00578c:	2202      	movs	r2, #2
 c00578e:	2112      	movs	r1, #18
 c005790:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c005794:	f7ff bf86 	b.w	c0056a4 <std>
 c005798:	30002e18 	.word	0x30002e18
 c00579c:	30002ce0 	.word	0x30002ce0
 c0057a0:	0c005711 	.word	0x0c005711

0c0057a4 <__sfp_lock_acquire>:
 c0057a4:	4801      	ldr	r0, [pc, #4]	@ (c0057ac <__sfp_lock_acquire+0x8>)
 c0057a6:	f000 ba24 	b.w	c005bf2 <__retarget_lock_acquire_recursive>
 c0057aa:	bf00      	nop
 c0057ac:	30002e21 	.word	0x30002e21

0c0057b0 <__sfp_lock_release>:
 c0057b0:	4801      	ldr	r0, [pc, #4]	@ (c0057b8 <__sfp_lock_release+0x8>)
 c0057b2:	f000 ba1f 	b.w	c005bf4 <__retarget_lock_release_recursive>
 c0057b6:	bf00      	nop
 c0057b8:	30002e21 	.word	0x30002e21

0c0057bc <__sinit>:
 c0057bc:	b510      	push	{r4, lr}
 c0057be:	4604      	mov	r4, r0
 c0057c0:	f7ff fff0 	bl	c0057a4 <__sfp_lock_acquire>
 c0057c4:	6a23      	ldr	r3, [r4, #32]
 c0057c6:	b11b      	cbz	r3, c0057d0 <__sinit+0x14>
 c0057c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0057cc:	f7ff bff0 	b.w	c0057b0 <__sfp_lock_release>
 c0057d0:	4b04      	ldr	r3, [pc, #16]	@ (c0057e4 <__sinit+0x28>)
 c0057d2:	6223      	str	r3, [r4, #32]
 c0057d4:	4b04      	ldr	r3, [pc, #16]	@ (c0057e8 <__sinit+0x2c>)
 c0057d6:	681b      	ldr	r3, [r3, #0]
 c0057d8:	2b00      	cmp	r3, #0
 c0057da:	d1f5      	bne.n	c0057c8 <__sinit+0xc>
 c0057dc:	f7ff ffc4 	bl	c005768 <global_stdio_init.part.0>
 c0057e0:	e7f2      	b.n	c0057c8 <__sinit+0xc>
 c0057e2:	bf00      	nop
 c0057e4:	0c005729 	.word	0x0c005729
 c0057e8:	30002e18 	.word	0x30002e18

0c0057ec <_fwalk_sglue>:
 c0057ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0057f0:	4607      	mov	r7, r0
 c0057f2:	4688      	mov	r8, r1
 c0057f4:	4614      	mov	r4, r2
 c0057f6:	2600      	movs	r6, #0
 c0057f8:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 c0057fc:	f1b9 0901 	subs.w	r9, r9, #1
 c005800:	d505      	bpl.n	c00580e <_fwalk_sglue+0x22>
 c005802:	6824      	ldr	r4, [r4, #0]
 c005804:	2c00      	cmp	r4, #0
 c005806:	d1f7      	bne.n	c0057f8 <_fwalk_sglue+0xc>
 c005808:	4630      	mov	r0, r6
 c00580a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c00580e:	89ab      	ldrh	r3, [r5, #12]
 c005810:	2b01      	cmp	r3, #1
 c005812:	d907      	bls.n	c005824 <_fwalk_sglue+0x38>
 c005814:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c005818:	3301      	adds	r3, #1
 c00581a:	d003      	beq.n	c005824 <_fwalk_sglue+0x38>
 c00581c:	4629      	mov	r1, r5
 c00581e:	4638      	mov	r0, r7
 c005820:	47c0      	blx	r8
 c005822:	4306      	orrs	r6, r0
 c005824:	3568      	adds	r5, #104	@ 0x68
 c005826:	e7e9      	b.n	c0057fc <_fwalk_sglue+0x10>

0c005828 <iprintf>:
 c005828:	b40f      	push	{r0, r1, r2, r3}
 c00582a:	b507      	push	{r0, r1, r2, lr}
 c00582c:	4906      	ldr	r1, [pc, #24]	@ (c005848 <iprintf+0x20>)
 c00582e:	ab04      	add	r3, sp, #16
 c005830:	6808      	ldr	r0, [r1, #0]
 c005832:	f853 2b04 	ldr.w	r2, [r3], #4
 c005836:	6881      	ldr	r1, [r0, #8]
 c005838:	9301      	str	r3, [sp, #4]
 c00583a:	f000 fa7b 	bl	c005d34 <_vfiprintf_r>
 c00583e:	b003      	add	sp, #12
 c005840:	f85d eb04 	ldr.w	lr, [sp], #4
 c005844:	b004      	add	sp, #16
 c005846:	4770      	bx	lr
 c005848:	3000004c 	.word	0x3000004c

0c00584c <_puts_r>:
 c00584c:	6a03      	ldr	r3, [r0, #32]
 c00584e:	b570      	push	{r4, r5, r6, lr}
 c005850:	4605      	mov	r5, r0
 c005852:	460e      	mov	r6, r1
 c005854:	6884      	ldr	r4, [r0, #8]
 c005856:	b90b      	cbnz	r3, c00585c <_puts_r+0x10>
 c005858:	f7ff ffb0 	bl	c0057bc <__sinit>
 c00585c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c00585e:	07db      	lsls	r3, r3, #31
 c005860:	d405      	bmi.n	c00586e <_puts_r+0x22>
 c005862:	89a3      	ldrh	r3, [r4, #12]
 c005864:	0598      	lsls	r0, r3, #22
 c005866:	d402      	bmi.n	c00586e <_puts_r+0x22>
 c005868:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c00586a:	f000 f9c2 	bl	c005bf2 <__retarget_lock_acquire_recursive>
 c00586e:	89a3      	ldrh	r3, [r4, #12]
 c005870:	0719      	lsls	r1, r3, #28
 c005872:	d502      	bpl.n	c00587a <_puts_r+0x2e>
 c005874:	6923      	ldr	r3, [r4, #16]
 c005876:	2b00      	cmp	r3, #0
 c005878:	d135      	bne.n	c0058e6 <_puts_r+0x9a>
 c00587a:	4621      	mov	r1, r4
 c00587c:	4628      	mov	r0, r5
 c00587e:	f000 f8c5 	bl	c005a0c <__swsetup_r>
 c005882:	b380      	cbz	r0, c0058e6 <_puts_r+0x9a>
 c005884:	f04f 35ff 	mov.w	r5, #4294967295
 c005888:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c00588a:	07da      	lsls	r2, r3, #31
 c00588c:	d405      	bmi.n	c00589a <_puts_r+0x4e>
 c00588e:	89a3      	ldrh	r3, [r4, #12]
 c005890:	059b      	lsls	r3, r3, #22
 c005892:	d402      	bmi.n	c00589a <_puts_r+0x4e>
 c005894:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c005896:	f000 f9ad 	bl	c005bf4 <__retarget_lock_release_recursive>
 c00589a:	4628      	mov	r0, r5
 c00589c:	bd70      	pop	{r4, r5, r6, pc}
 c00589e:	2b00      	cmp	r3, #0
 c0058a0:	da04      	bge.n	c0058ac <_puts_r+0x60>
 c0058a2:	69a2      	ldr	r2, [r4, #24]
 c0058a4:	429a      	cmp	r2, r3
 c0058a6:	dc17      	bgt.n	c0058d8 <_puts_r+0x8c>
 c0058a8:	290a      	cmp	r1, #10
 c0058aa:	d015      	beq.n	c0058d8 <_puts_r+0x8c>
 c0058ac:	6823      	ldr	r3, [r4, #0]
 c0058ae:	1c5a      	adds	r2, r3, #1
 c0058b0:	6022      	str	r2, [r4, #0]
 c0058b2:	7019      	strb	r1, [r3, #0]
 c0058b4:	68a3      	ldr	r3, [r4, #8]
 c0058b6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c0058ba:	3b01      	subs	r3, #1
 c0058bc:	60a3      	str	r3, [r4, #8]
 c0058be:	2900      	cmp	r1, #0
 c0058c0:	d1ed      	bne.n	c00589e <_puts_r+0x52>
 c0058c2:	2b00      	cmp	r3, #0
 c0058c4:	da11      	bge.n	c0058ea <_puts_r+0x9e>
 c0058c6:	4622      	mov	r2, r4
 c0058c8:	210a      	movs	r1, #10
 c0058ca:	4628      	mov	r0, r5
 c0058cc:	f000 f85f 	bl	c00598e <__swbuf_r>
 c0058d0:	3001      	adds	r0, #1
 c0058d2:	d0d7      	beq.n	c005884 <_puts_r+0x38>
 c0058d4:	250a      	movs	r5, #10
 c0058d6:	e7d7      	b.n	c005888 <_puts_r+0x3c>
 c0058d8:	4622      	mov	r2, r4
 c0058da:	4628      	mov	r0, r5
 c0058dc:	f000 f857 	bl	c00598e <__swbuf_r>
 c0058e0:	3001      	adds	r0, #1
 c0058e2:	d1e7      	bne.n	c0058b4 <_puts_r+0x68>
 c0058e4:	e7ce      	b.n	c005884 <_puts_r+0x38>
 c0058e6:	3e01      	subs	r6, #1
 c0058e8:	e7e4      	b.n	c0058b4 <_puts_r+0x68>
 c0058ea:	6823      	ldr	r3, [r4, #0]
 c0058ec:	1c5a      	adds	r2, r3, #1
 c0058ee:	6022      	str	r2, [r4, #0]
 c0058f0:	220a      	movs	r2, #10
 c0058f2:	701a      	strb	r2, [r3, #0]
 c0058f4:	e7ee      	b.n	c0058d4 <_puts_r+0x88>
	...

0c0058f8 <puts>:
 c0058f8:	4b02      	ldr	r3, [pc, #8]	@ (c005904 <puts+0xc>)
 c0058fa:	4601      	mov	r1, r0
 c0058fc:	6818      	ldr	r0, [r3, #0]
 c0058fe:	f7ff bfa5 	b.w	c00584c <_puts_r>
 c005902:	bf00      	nop
 c005904:	3000004c 	.word	0x3000004c

0c005908 <__sread>:
 c005908:	b510      	push	{r4, lr}
 c00590a:	460c      	mov	r4, r1
 c00590c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c005910:	f000 f910 	bl	c005b34 <_read_r>
 c005914:	2800      	cmp	r0, #0
 c005916:	bfab      	itete	ge
 c005918:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 c00591a:	89a3      	ldrhlt	r3, [r4, #12]
 c00591c:	181b      	addge	r3, r3, r0
 c00591e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 c005922:	bfac      	ite	ge
 c005924:	6563      	strge	r3, [r4, #84]	@ 0x54
 c005926:	81a3      	strhlt	r3, [r4, #12]
 c005928:	bd10      	pop	{r4, pc}

0c00592a <__swrite>:
 c00592a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00592e:	461f      	mov	r7, r3
 c005930:	898b      	ldrh	r3, [r1, #12]
 c005932:	4605      	mov	r5, r0
 c005934:	460c      	mov	r4, r1
 c005936:	05db      	lsls	r3, r3, #23
 c005938:	4616      	mov	r6, r2
 c00593a:	d505      	bpl.n	c005948 <__swrite+0x1e>
 c00593c:	2302      	movs	r3, #2
 c00593e:	2200      	movs	r2, #0
 c005940:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c005944:	f000 f8e4 	bl	c005b10 <_lseek_r>
 c005948:	89a3      	ldrh	r3, [r4, #12]
 c00594a:	4632      	mov	r2, r6
 c00594c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c005950:	4628      	mov	r0, r5
 c005952:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 c005956:	81a3      	strh	r3, [r4, #12]
 c005958:	463b      	mov	r3, r7
 c00595a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c00595e:	f000 b90b 	b.w	c005b78 <_write_r>

0c005962 <__sseek>:
 c005962:	b510      	push	{r4, lr}
 c005964:	460c      	mov	r4, r1
 c005966:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00596a:	f000 f8d1 	bl	c005b10 <_lseek_r>
 c00596e:	1c43      	adds	r3, r0, #1
 c005970:	89a3      	ldrh	r3, [r4, #12]
 c005972:	bf15      	itete	ne
 c005974:	6560      	strne	r0, [r4, #84]	@ 0x54
 c005976:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 c00597a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 c00597e:	81a3      	strheq	r3, [r4, #12]
 c005980:	bf18      	it	ne
 c005982:	81a3      	strhne	r3, [r4, #12]
 c005984:	bd10      	pop	{r4, pc}

0c005986 <__sclose>:
 c005986:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00598a:	f000 b8b1 	b.w	c005af0 <_close_r>

0c00598e <__swbuf_r>:
 c00598e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005990:	460e      	mov	r6, r1
 c005992:	4614      	mov	r4, r2
 c005994:	4605      	mov	r5, r0
 c005996:	b118      	cbz	r0, c0059a0 <__swbuf_r+0x12>
 c005998:	6a03      	ldr	r3, [r0, #32]
 c00599a:	b90b      	cbnz	r3, c0059a0 <__swbuf_r+0x12>
 c00599c:	f7ff ff0e 	bl	c0057bc <__sinit>
 c0059a0:	69a3      	ldr	r3, [r4, #24]
 c0059a2:	60a3      	str	r3, [r4, #8]
 c0059a4:	89a3      	ldrh	r3, [r4, #12]
 c0059a6:	071a      	lsls	r2, r3, #28
 c0059a8:	d501      	bpl.n	c0059ae <__swbuf_r+0x20>
 c0059aa:	6923      	ldr	r3, [r4, #16]
 c0059ac:	b943      	cbnz	r3, c0059c0 <__swbuf_r+0x32>
 c0059ae:	4621      	mov	r1, r4
 c0059b0:	4628      	mov	r0, r5
 c0059b2:	f000 f82b 	bl	c005a0c <__swsetup_r>
 c0059b6:	b118      	cbz	r0, c0059c0 <__swbuf_r+0x32>
 c0059b8:	f04f 37ff 	mov.w	r7, #4294967295
 c0059bc:	4638      	mov	r0, r7
 c0059be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0059c0:	6823      	ldr	r3, [r4, #0]
 c0059c2:	b2f6      	uxtb	r6, r6
 c0059c4:	6922      	ldr	r2, [r4, #16]
 c0059c6:	4637      	mov	r7, r6
 c0059c8:	1a98      	subs	r0, r3, r2
 c0059ca:	6963      	ldr	r3, [r4, #20]
 c0059cc:	4283      	cmp	r3, r0
 c0059ce:	dc05      	bgt.n	c0059dc <__swbuf_r+0x4e>
 c0059d0:	4621      	mov	r1, r4
 c0059d2:	4628      	mov	r0, r5
 c0059d4:	f000 fcda 	bl	c00638c <_fflush_r>
 c0059d8:	2800      	cmp	r0, #0
 c0059da:	d1ed      	bne.n	c0059b8 <__swbuf_r+0x2a>
 c0059dc:	68a3      	ldr	r3, [r4, #8]
 c0059de:	3b01      	subs	r3, #1
 c0059e0:	60a3      	str	r3, [r4, #8]
 c0059e2:	6823      	ldr	r3, [r4, #0]
 c0059e4:	1c5a      	adds	r2, r3, #1
 c0059e6:	6022      	str	r2, [r4, #0]
 c0059e8:	701e      	strb	r6, [r3, #0]
 c0059ea:	1c43      	adds	r3, r0, #1
 c0059ec:	6962      	ldr	r2, [r4, #20]
 c0059ee:	429a      	cmp	r2, r3
 c0059f0:	d004      	beq.n	c0059fc <__swbuf_r+0x6e>
 c0059f2:	89a3      	ldrh	r3, [r4, #12]
 c0059f4:	07db      	lsls	r3, r3, #31
 c0059f6:	d5e1      	bpl.n	c0059bc <__swbuf_r+0x2e>
 c0059f8:	2e0a      	cmp	r6, #10
 c0059fa:	d1df      	bne.n	c0059bc <__swbuf_r+0x2e>
 c0059fc:	4621      	mov	r1, r4
 c0059fe:	4628      	mov	r0, r5
 c005a00:	f000 fcc4 	bl	c00638c <_fflush_r>
 c005a04:	2800      	cmp	r0, #0
 c005a06:	d0d9      	beq.n	c0059bc <__swbuf_r+0x2e>
 c005a08:	e7d6      	b.n	c0059b8 <__swbuf_r+0x2a>
	...

0c005a0c <__swsetup_r>:
 c005a0c:	b538      	push	{r3, r4, r5, lr}
 c005a0e:	4b29      	ldr	r3, [pc, #164]	@ (c005ab4 <__swsetup_r+0xa8>)
 c005a10:	4605      	mov	r5, r0
 c005a12:	460c      	mov	r4, r1
 c005a14:	6818      	ldr	r0, [r3, #0]
 c005a16:	b118      	cbz	r0, c005a20 <__swsetup_r+0x14>
 c005a18:	6a03      	ldr	r3, [r0, #32]
 c005a1a:	b90b      	cbnz	r3, c005a20 <__swsetup_r+0x14>
 c005a1c:	f7ff fece 	bl	c0057bc <__sinit>
 c005a20:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c005a24:	0719      	lsls	r1, r3, #28
 c005a26:	d422      	bmi.n	c005a6e <__swsetup_r+0x62>
 c005a28:	06da      	lsls	r2, r3, #27
 c005a2a:	d407      	bmi.n	c005a3c <__swsetup_r+0x30>
 c005a2c:	2209      	movs	r2, #9
 c005a2e:	602a      	str	r2, [r5, #0]
 c005a30:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c005a34:	f04f 30ff 	mov.w	r0, #4294967295
 c005a38:	81a3      	strh	r3, [r4, #12]
 c005a3a:	e033      	b.n	c005aa4 <__swsetup_r+0x98>
 c005a3c:	0758      	lsls	r0, r3, #29
 c005a3e:	d512      	bpl.n	c005a66 <__swsetup_r+0x5a>
 c005a40:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c005a42:	b141      	cbz	r1, c005a56 <__swsetup_r+0x4a>
 c005a44:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c005a48:	4299      	cmp	r1, r3
 c005a4a:	d002      	beq.n	c005a52 <__swsetup_r+0x46>
 c005a4c:	4628      	mov	r0, r5
 c005a4e:	f000 f8fd 	bl	c005c4c <_free_r>
 c005a52:	2300      	movs	r3, #0
 c005a54:	6363      	str	r3, [r4, #52]	@ 0x34
 c005a56:	89a3      	ldrh	r3, [r4, #12]
 c005a58:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 c005a5c:	81a3      	strh	r3, [r4, #12]
 c005a5e:	2300      	movs	r3, #0
 c005a60:	6063      	str	r3, [r4, #4]
 c005a62:	6923      	ldr	r3, [r4, #16]
 c005a64:	6023      	str	r3, [r4, #0]
 c005a66:	89a3      	ldrh	r3, [r4, #12]
 c005a68:	f043 0308 	orr.w	r3, r3, #8
 c005a6c:	81a3      	strh	r3, [r4, #12]
 c005a6e:	6923      	ldr	r3, [r4, #16]
 c005a70:	b94b      	cbnz	r3, c005a86 <__swsetup_r+0x7a>
 c005a72:	89a3      	ldrh	r3, [r4, #12]
 c005a74:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 c005a78:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c005a7c:	d003      	beq.n	c005a86 <__swsetup_r+0x7a>
 c005a7e:	4621      	mov	r1, r4
 c005a80:	4628      	mov	r0, r5
 c005a82:	f000 fce2 	bl	c00644a <__smakebuf_r>
 c005a86:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c005a8a:	f013 0201 	ands.w	r2, r3, #1
 c005a8e:	d00a      	beq.n	c005aa6 <__swsetup_r+0x9a>
 c005a90:	2200      	movs	r2, #0
 c005a92:	60a2      	str	r2, [r4, #8]
 c005a94:	6962      	ldr	r2, [r4, #20]
 c005a96:	4252      	negs	r2, r2
 c005a98:	61a2      	str	r2, [r4, #24]
 c005a9a:	6922      	ldr	r2, [r4, #16]
 c005a9c:	b942      	cbnz	r2, c005ab0 <__swsetup_r+0xa4>
 c005a9e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 c005aa2:	d1c5      	bne.n	c005a30 <__swsetup_r+0x24>
 c005aa4:	bd38      	pop	{r3, r4, r5, pc}
 c005aa6:	0799      	lsls	r1, r3, #30
 c005aa8:	bf58      	it	pl
 c005aaa:	6962      	ldrpl	r2, [r4, #20]
 c005aac:	60a2      	str	r2, [r4, #8]
 c005aae:	e7f4      	b.n	c005a9a <__swsetup_r+0x8e>
 c005ab0:	2000      	movs	r0, #0
 c005ab2:	e7f7      	b.n	c005aa4 <__swsetup_r+0x98>
 c005ab4:	3000004c 	.word	0x3000004c

0c005ab8 <memset>:
 c005ab8:	4402      	add	r2, r0
 c005aba:	4603      	mov	r3, r0
 c005abc:	4293      	cmp	r3, r2
 c005abe:	d100      	bne.n	c005ac2 <memset+0xa>
 c005ac0:	4770      	bx	lr
 c005ac2:	f803 1b01 	strb.w	r1, [r3], #1
 c005ac6:	e7f9      	b.n	c005abc <memset+0x4>

0c005ac8 <strncpy>:
 c005ac8:	3901      	subs	r1, #1
 c005aca:	4603      	mov	r3, r0
 c005acc:	b510      	push	{r4, lr}
 c005ace:	b132      	cbz	r2, c005ade <strncpy+0x16>
 c005ad0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 c005ad4:	3a01      	subs	r2, #1
 c005ad6:	f803 4b01 	strb.w	r4, [r3], #1
 c005ada:	2c00      	cmp	r4, #0
 c005adc:	d1f7      	bne.n	c005ace <strncpy+0x6>
 c005ade:	441a      	add	r2, r3
 c005ae0:	2100      	movs	r1, #0
 c005ae2:	4293      	cmp	r3, r2
 c005ae4:	d100      	bne.n	c005ae8 <strncpy+0x20>
 c005ae6:	bd10      	pop	{r4, pc}
 c005ae8:	f803 1b01 	strb.w	r1, [r3], #1
 c005aec:	e7f9      	b.n	c005ae2 <strncpy+0x1a>
	...

0c005af0 <_close_r>:
 c005af0:	b538      	push	{r3, r4, r5, lr}
 c005af2:	2300      	movs	r3, #0
 c005af4:	4d05      	ldr	r5, [pc, #20]	@ (c005b0c <_close_r+0x1c>)
 c005af6:	4604      	mov	r4, r0
 c005af8:	4608      	mov	r0, r1
 c005afa:	602b      	str	r3, [r5, #0]
 c005afc:	f7fd fe0c 	bl	c003718 <_close>
 c005b00:	1c43      	adds	r3, r0, #1
 c005b02:	d102      	bne.n	c005b0a <_close_r+0x1a>
 c005b04:	682b      	ldr	r3, [r5, #0]
 c005b06:	b103      	cbz	r3, c005b0a <_close_r+0x1a>
 c005b08:	6023      	str	r3, [r4, #0]
 c005b0a:	bd38      	pop	{r3, r4, r5, pc}
 c005b0c:	30002e1c 	.word	0x30002e1c

0c005b10 <_lseek_r>:
 c005b10:	b538      	push	{r3, r4, r5, lr}
 c005b12:	4604      	mov	r4, r0
 c005b14:	4d06      	ldr	r5, [pc, #24]	@ (c005b30 <_lseek_r+0x20>)
 c005b16:	4608      	mov	r0, r1
 c005b18:	4611      	mov	r1, r2
 c005b1a:	2200      	movs	r2, #0
 c005b1c:	602a      	str	r2, [r5, #0]
 c005b1e:	461a      	mov	r2, r3
 c005b20:	f7fd fe21 	bl	c003766 <_lseek>
 c005b24:	1c43      	adds	r3, r0, #1
 c005b26:	d102      	bne.n	c005b2e <_lseek_r+0x1e>
 c005b28:	682b      	ldr	r3, [r5, #0]
 c005b2a:	b103      	cbz	r3, c005b2e <_lseek_r+0x1e>
 c005b2c:	6023      	str	r3, [r4, #0]
 c005b2e:	bd38      	pop	{r3, r4, r5, pc}
 c005b30:	30002e1c 	.word	0x30002e1c

0c005b34 <_read_r>:
 c005b34:	b538      	push	{r3, r4, r5, lr}
 c005b36:	4604      	mov	r4, r0
 c005b38:	4d06      	ldr	r5, [pc, #24]	@ (c005b54 <_read_r+0x20>)
 c005b3a:	4608      	mov	r0, r1
 c005b3c:	4611      	mov	r1, r2
 c005b3e:	2200      	movs	r2, #0
 c005b40:	602a      	str	r2, [r5, #0]
 c005b42:	461a      	mov	r2, r3
 c005b44:	f7fd fdaf 	bl	c0036a6 <_read>
 c005b48:	1c43      	adds	r3, r0, #1
 c005b4a:	d102      	bne.n	c005b52 <_read_r+0x1e>
 c005b4c:	682b      	ldr	r3, [r5, #0]
 c005b4e:	b103      	cbz	r3, c005b52 <_read_r+0x1e>
 c005b50:	6023      	str	r3, [r4, #0]
 c005b52:	bd38      	pop	{r3, r4, r5, pc}
 c005b54:	30002e1c 	.word	0x30002e1c

0c005b58 <_sbrk_r>:
 c005b58:	b538      	push	{r3, r4, r5, lr}
 c005b5a:	2300      	movs	r3, #0
 c005b5c:	4d05      	ldr	r5, [pc, #20]	@ (c005b74 <_sbrk_r+0x1c>)
 c005b5e:	4604      	mov	r4, r0
 c005b60:	4608      	mov	r0, r1
 c005b62:	602b      	str	r3, [r5, #0]
 c005b64:	f7fd fe0c 	bl	c003780 <_sbrk>
 c005b68:	1c43      	adds	r3, r0, #1
 c005b6a:	d102      	bne.n	c005b72 <_sbrk_r+0x1a>
 c005b6c:	682b      	ldr	r3, [r5, #0]
 c005b6e:	b103      	cbz	r3, c005b72 <_sbrk_r+0x1a>
 c005b70:	6023      	str	r3, [r4, #0]
 c005b72:	bd38      	pop	{r3, r4, r5, pc}
 c005b74:	30002e1c 	.word	0x30002e1c

0c005b78 <_write_r>:
 c005b78:	b538      	push	{r3, r4, r5, lr}
 c005b7a:	4604      	mov	r4, r0
 c005b7c:	4d06      	ldr	r5, [pc, #24]	@ (c005b98 <_write_r+0x20>)
 c005b7e:	4608      	mov	r0, r1
 c005b80:	4611      	mov	r1, r2
 c005b82:	2200      	movs	r2, #0
 c005b84:	602a      	str	r2, [r5, #0]
 c005b86:	461a      	mov	r2, r3
 c005b88:	f7fd fdaa 	bl	c0036e0 <_write>
 c005b8c:	1c43      	adds	r3, r0, #1
 c005b8e:	d102      	bne.n	c005b96 <_write_r+0x1e>
 c005b90:	682b      	ldr	r3, [r5, #0]
 c005b92:	b103      	cbz	r3, c005b96 <_write_r+0x1e>
 c005b94:	6023      	str	r3, [r4, #0]
 c005b96:	bd38      	pop	{r3, r4, r5, pc}
 c005b98:	30002e1c 	.word	0x30002e1c

0c005b9c <__errno>:
 c005b9c:	4b01      	ldr	r3, [pc, #4]	@ (c005ba4 <__errno+0x8>)
 c005b9e:	6818      	ldr	r0, [r3, #0]
 c005ba0:	4770      	bx	lr
 c005ba2:	bf00      	nop
 c005ba4:	3000004c 	.word	0x3000004c

0c005ba8 <__libc_init_array>:
 c005ba8:	b570      	push	{r4, r5, r6, lr}
 c005baa:	4d0d      	ldr	r5, [pc, #52]	@ (c005be0 <__libc_init_array+0x38>)
 c005bac:	2600      	movs	r6, #0
 c005bae:	4c0d      	ldr	r4, [pc, #52]	@ (c005be4 <__libc_init_array+0x3c>)
 c005bb0:	1b64      	subs	r4, r4, r5
 c005bb2:	10a4      	asrs	r4, r4, #2
 c005bb4:	42a6      	cmp	r6, r4
 c005bb6:	d109      	bne.n	c005bcc <__libc_init_array+0x24>
 c005bb8:	4d0b      	ldr	r5, [pc, #44]	@ (c005be8 <__libc_init_array+0x40>)
 c005bba:	2600      	movs	r6, #0
 c005bbc:	4c0b      	ldr	r4, [pc, #44]	@ (c005bec <__libc_init_array+0x44>)
 c005bbe:	f000 fcfd 	bl	c0065bc <_init>
 c005bc2:	1b64      	subs	r4, r4, r5
 c005bc4:	10a4      	asrs	r4, r4, #2
 c005bc6:	42a6      	cmp	r6, r4
 c005bc8:	d105      	bne.n	c005bd6 <__libc_init_array+0x2e>
 c005bca:	bd70      	pop	{r4, r5, r6, pc}
 c005bcc:	f855 3b04 	ldr.w	r3, [r5], #4
 c005bd0:	3601      	adds	r6, #1
 c005bd2:	4798      	blx	r3
 c005bd4:	e7ee      	b.n	c005bb4 <__libc_init_array+0xc>
 c005bd6:	f855 3b04 	ldr.w	r3, [r5], #4
 c005bda:	3601      	adds	r6, #1
 c005bdc:	4798      	blx	r3
 c005bde:	e7f2      	b.n	c005bc6 <__libc_init_array+0x1e>
 c005be0:	0c006dc8 	.word	0x0c006dc8
 c005be4:	0c006dc8 	.word	0x0c006dc8
 c005be8:	0c006dc8 	.word	0x0c006dc8
 c005bec:	0c006dcc 	.word	0x0c006dcc

0c005bf0 <__retarget_lock_init_recursive>:
 c005bf0:	4770      	bx	lr

0c005bf2 <__retarget_lock_acquire_recursive>:
 c005bf2:	4770      	bx	lr

0c005bf4 <__retarget_lock_release_recursive>:
 c005bf4:	4770      	bx	lr

0c005bf6 <memcpy>:
 c005bf6:	440a      	add	r2, r1
 c005bf8:	1e43      	subs	r3, r0, #1
 c005bfa:	4291      	cmp	r1, r2
 c005bfc:	d100      	bne.n	c005c00 <memcpy+0xa>
 c005bfe:	4770      	bx	lr
 c005c00:	b510      	push	{r4, lr}
 c005c02:	f811 4b01 	ldrb.w	r4, [r1], #1
 c005c06:	4291      	cmp	r1, r2
 c005c08:	f803 4f01 	strb.w	r4, [r3, #1]!
 c005c0c:	d1f9      	bne.n	c005c02 <memcpy+0xc>
 c005c0e:	bd10      	pop	{r4, pc}

0c005c10 <__assert_func>:
 c005c10:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c005c12:	4614      	mov	r4, r2
 c005c14:	461a      	mov	r2, r3
 c005c16:	4b09      	ldr	r3, [pc, #36]	@ (c005c3c <__assert_func+0x2c>)
 c005c18:	4605      	mov	r5, r0
 c005c1a:	681b      	ldr	r3, [r3, #0]
 c005c1c:	68d8      	ldr	r0, [r3, #12]
 c005c1e:	b14c      	cbz	r4, c005c34 <__assert_func+0x24>
 c005c20:	4b07      	ldr	r3, [pc, #28]	@ (c005c40 <__assert_func+0x30>)
 c005c22:	9100      	str	r1, [sp, #0]
 c005c24:	4907      	ldr	r1, [pc, #28]	@ (c005c44 <__assert_func+0x34>)
 c005c26:	e9cd 3401 	strd	r3, r4, [sp, #4]
 c005c2a:	462b      	mov	r3, r5
 c005c2c:	f000 fbd6 	bl	c0063dc <fiprintf>
 c005c30:	f000 fc78 	bl	c006524 <abort>
 c005c34:	4b04      	ldr	r3, [pc, #16]	@ (c005c48 <__assert_func+0x38>)
 c005c36:	461c      	mov	r4, r3
 c005c38:	e7f3      	b.n	c005c22 <__assert_func+0x12>
 c005c3a:	bf00      	nop
 c005c3c:	3000004c 	.word	0x3000004c
 c005c40:	0c006d4b 	.word	0x0c006d4b
 c005c44:	0c006d58 	.word	0x0c006d58
 c005c48:	0c006d86 	.word	0x0c006d86

0c005c4c <_free_r>:
 c005c4c:	b538      	push	{r3, r4, r5, lr}
 c005c4e:	4605      	mov	r5, r0
 c005c50:	2900      	cmp	r1, #0
 c005c52:	d041      	beq.n	c005cd8 <_free_r+0x8c>
 c005c54:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c005c58:	1f0c      	subs	r4, r1, #4
 c005c5a:	2b00      	cmp	r3, #0
 c005c5c:	bfb8      	it	lt
 c005c5e:	18e4      	addlt	r4, r4, r3
 c005c60:	f7ff fca8 	bl	c0055b4 <__malloc_lock>
 c005c64:	4a1d      	ldr	r2, [pc, #116]	@ (c005cdc <_free_r+0x90>)
 c005c66:	6813      	ldr	r3, [r2, #0]
 c005c68:	b933      	cbnz	r3, c005c78 <_free_r+0x2c>
 c005c6a:	6063      	str	r3, [r4, #4]
 c005c6c:	6014      	str	r4, [r2, #0]
 c005c6e:	4628      	mov	r0, r5
 c005c70:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c005c74:	f7ff bca4 	b.w	c0055c0 <__malloc_unlock>
 c005c78:	42a3      	cmp	r3, r4
 c005c7a:	d908      	bls.n	c005c8e <_free_r+0x42>
 c005c7c:	6820      	ldr	r0, [r4, #0]
 c005c7e:	1821      	adds	r1, r4, r0
 c005c80:	428b      	cmp	r3, r1
 c005c82:	bf01      	itttt	eq
 c005c84:	6819      	ldreq	r1, [r3, #0]
 c005c86:	685b      	ldreq	r3, [r3, #4]
 c005c88:	1809      	addeq	r1, r1, r0
 c005c8a:	6021      	streq	r1, [r4, #0]
 c005c8c:	e7ed      	b.n	c005c6a <_free_r+0x1e>
 c005c8e:	461a      	mov	r2, r3
 c005c90:	685b      	ldr	r3, [r3, #4]
 c005c92:	b10b      	cbz	r3, c005c98 <_free_r+0x4c>
 c005c94:	42a3      	cmp	r3, r4
 c005c96:	d9fa      	bls.n	c005c8e <_free_r+0x42>
 c005c98:	6811      	ldr	r1, [r2, #0]
 c005c9a:	1850      	adds	r0, r2, r1
 c005c9c:	42a0      	cmp	r0, r4
 c005c9e:	d10b      	bne.n	c005cb8 <_free_r+0x6c>
 c005ca0:	6820      	ldr	r0, [r4, #0]
 c005ca2:	4401      	add	r1, r0
 c005ca4:	1850      	adds	r0, r2, r1
 c005ca6:	6011      	str	r1, [r2, #0]
 c005ca8:	4283      	cmp	r3, r0
 c005caa:	d1e0      	bne.n	c005c6e <_free_r+0x22>
 c005cac:	6818      	ldr	r0, [r3, #0]
 c005cae:	685b      	ldr	r3, [r3, #4]
 c005cb0:	4408      	add	r0, r1
 c005cb2:	6053      	str	r3, [r2, #4]
 c005cb4:	6010      	str	r0, [r2, #0]
 c005cb6:	e7da      	b.n	c005c6e <_free_r+0x22>
 c005cb8:	d902      	bls.n	c005cc0 <_free_r+0x74>
 c005cba:	230c      	movs	r3, #12
 c005cbc:	602b      	str	r3, [r5, #0]
 c005cbe:	e7d6      	b.n	c005c6e <_free_r+0x22>
 c005cc0:	6820      	ldr	r0, [r4, #0]
 c005cc2:	1821      	adds	r1, r4, r0
 c005cc4:	428b      	cmp	r3, r1
 c005cc6:	bf02      	ittt	eq
 c005cc8:	6819      	ldreq	r1, [r3, #0]
 c005cca:	685b      	ldreq	r3, [r3, #4]
 c005ccc:	1809      	addeq	r1, r1, r0
 c005cce:	6063      	str	r3, [r4, #4]
 c005cd0:	bf08      	it	eq
 c005cd2:	6021      	streq	r1, [r4, #0]
 c005cd4:	6054      	str	r4, [r2, #4]
 c005cd6:	e7ca      	b.n	c005c6e <_free_r+0x22>
 c005cd8:	bd38      	pop	{r3, r4, r5, pc}
 c005cda:	bf00      	nop
 c005cdc:	30002cdc 	.word	0x30002cdc

0c005ce0 <__sfputc_r>:
 c005ce0:	6893      	ldr	r3, [r2, #8]
 c005ce2:	3b01      	subs	r3, #1
 c005ce4:	2b00      	cmp	r3, #0
 c005ce6:	b410      	push	{r4}
 c005ce8:	6093      	str	r3, [r2, #8]
 c005cea:	da08      	bge.n	c005cfe <__sfputc_r+0x1e>
 c005cec:	6994      	ldr	r4, [r2, #24]
 c005cee:	42a3      	cmp	r3, r4
 c005cf0:	db01      	blt.n	c005cf6 <__sfputc_r+0x16>
 c005cf2:	290a      	cmp	r1, #10
 c005cf4:	d103      	bne.n	c005cfe <__sfputc_r+0x1e>
 c005cf6:	f85d 4b04 	ldr.w	r4, [sp], #4
 c005cfa:	f7ff be48 	b.w	c00598e <__swbuf_r>
 c005cfe:	6813      	ldr	r3, [r2, #0]
 c005d00:	1c58      	adds	r0, r3, #1
 c005d02:	6010      	str	r0, [r2, #0]
 c005d04:	4608      	mov	r0, r1
 c005d06:	7019      	strb	r1, [r3, #0]
 c005d08:	f85d 4b04 	ldr.w	r4, [sp], #4
 c005d0c:	4770      	bx	lr

0c005d0e <__sfputs_r>:
 c005d0e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005d10:	4606      	mov	r6, r0
 c005d12:	460f      	mov	r7, r1
 c005d14:	4614      	mov	r4, r2
 c005d16:	18d5      	adds	r5, r2, r3
 c005d18:	42ac      	cmp	r4, r5
 c005d1a:	d101      	bne.n	c005d20 <__sfputs_r+0x12>
 c005d1c:	2000      	movs	r0, #0
 c005d1e:	e007      	b.n	c005d30 <__sfputs_r+0x22>
 c005d20:	463a      	mov	r2, r7
 c005d22:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005d26:	4630      	mov	r0, r6
 c005d28:	f7ff ffda 	bl	c005ce0 <__sfputc_r>
 c005d2c:	1c43      	adds	r3, r0, #1
 c005d2e:	d1f3      	bne.n	c005d18 <__sfputs_r+0xa>
 c005d30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c005d34 <_vfiprintf_r>:
 c005d34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c005d38:	460d      	mov	r5, r1
 c005d3a:	b09d      	sub	sp, #116	@ 0x74
 c005d3c:	4614      	mov	r4, r2
 c005d3e:	4698      	mov	r8, r3
 c005d40:	4606      	mov	r6, r0
 c005d42:	b118      	cbz	r0, c005d4c <_vfiprintf_r+0x18>
 c005d44:	6a03      	ldr	r3, [r0, #32]
 c005d46:	b90b      	cbnz	r3, c005d4c <_vfiprintf_r+0x18>
 c005d48:	f7ff fd38 	bl	c0057bc <__sinit>
 c005d4c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005d4e:	07d9      	lsls	r1, r3, #31
 c005d50:	d405      	bmi.n	c005d5e <_vfiprintf_r+0x2a>
 c005d52:	89ab      	ldrh	r3, [r5, #12]
 c005d54:	059a      	lsls	r2, r3, #22
 c005d56:	d402      	bmi.n	c005d5e <_vfiprintf_r+0x2a>
 c005d58:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005d5a:	f7ff ff4a 	bl	c005bf2 <__retarget_lock_acquire_recursive>
 c005d5e:	89ab      	ldrh	r3, [r5, #12]
 c005d60:	071b      	lsls	r3, r3, #28
 c005d62:	d501      	bpl.n	c005d68 <_vfiprintf_r+0x34>
 c005d64:	692b      	ldr	r3, [r5, #16]
 c005d66:	b99b      	cbnz	r3, c005d90 <_vfiprintf_r+0x5c>
 c005d68:	4629      	mov	r1, r5
 c005d6a:	4630      	mov	r0, r6
 c005d6c:	f7ff fe4e 	bl	c005a0c <__swsetup_r>
 c005d70:	b170      	cbz	r0, c005d90 <_vfiprintf_r+0x5c>
 c005d72:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005d74:	07dc      	lsls	r4, r3, #31
 c005d76:	d504      	bpl.n	c005d82 <_vfiprintf_r+0x4e>
 c005d78:	f04f 30ff 	mov.w	r0, #4294967295
 c005d7c:	b01d      	add	sp, #116	@ 0x74
 c005d7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c005d82:	89ab      	ldrh	r3, [r5, #12]
 c005d84:	0598      	lsls	r0, r3, #22
 c005d86:	d4f7      	bmi.n	c005d78 <_vfiprintf_r+0x44>
 c005d88:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005d8a:	f7ff ff33 	bl	c005bf4 <__retarget_lock_release_recursive>
 c005d8e:	e7f3      	b.n	c005d78 <_vfiprintf_r+0x44>
 c005d90:	2300      	movs	r3, #0
 c005d92:	f8cd 800c 	str.w	r8, [sp, #12]
 c005d96:	f04f 0901 	mov.w	r9, #1
 c005d9a:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ c005f50 <_vfiprintf_r+0x21c>
 c005d9e:	9309      	str	r3, [sp, #36]	@ 0x24
 c005da0:	2320      	movs	r3, #32
 c005da2:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 c005da6:	2330      	movs	r3, #48	@ 0x30
 c005da8:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 c005dac:	4623      	mov	r3, r4
 c005dae:	469a      	mov	sl, r3
 c005db0:	f813 2b01 	ldrb.w	r2, [r3], #1
 c005db4:	b10a      	cbz	r2, c005dba <_vfiprintf_r+0x86>
 c005db6:	2a25      	cmp	r2, #37	@ 0x25
 c005db8:	d1f9      	bne.n	c005dae <_vfiprintf_r+0x7a>
 c005dba:	ebba 0b04 	subs.w	fp, sl, r4
 c005dbe:	d00b      	beq.n	c005dd8 <_vfiprintf_r+0xa4>
 c005dc0:	465b      	mov	r3, fp
 c005dc2:	4622      	mov	r2, r4
 c005dc4:	4629      	mov	r1, r5
 c005dc6:	4630      	mov	r0, r6
 c005dc8:	f7ff ffa1 	bl	c005d0e <__sfputs_r>
 c005dcc:	3001      	adds	r0, #1
 c005dce:	f000 80a7 	beq.w	c005f20 <_vfiprintf_r+0x1ec>
 c005dd2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c005dd4:	445a      	add	r2, fp
 c005dd6:	9209      	str	r2, [sp, #36]	@ 0x24
 c005dd8:	f89a 3000 	ldrb.w	r3, [sl]
 c005ddc:	2b00      	cmp	r3, #0
 c005dde:	f000 809f 	beq.w	c005f20 <_vfiprintf_r+0x1ec>
 c005de2:	2300      	movs	r3, #0
 c005de4:	f04f 32ff 	mov.w	r2, #4294967295
 c005de8:	f10a 0a01 	add.w	sl, sl, #1
 c005dec:	9304      	str	r3, [sp, #16]
 c005dee:	9307      	str	r3, [sp, #28]
 c005df0:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 c005df4:	931a      	str	r3, [sp, #104]	@ 0x68
 c005df6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c005dfa:	4654      	mov	r4, sl
 c005dfc:	2205      	movs	r2, #5
 c005dfe:	4854      	ldr	r0, [pc, #336]	@ (c005f50 <_vfiprintf_r+0x21c>)
 c005e00:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005e04:	f000 fb80 	bl	c006508 <memchr>
 c005e08:	9a04      	ldr	r2, [sp, #16]
 c005e0a:	b9d8      	cbnz	r0, c005e44 <_vfiprintf_r+0x110>
 c005e0c:	06d1      	lsls	r1, r2, #27
 c005e0e:	bf44      	itt	mi
 c005e10:	2320      	movmi	r3, #32
 c005e12:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c005e16:	0713      	lsls	r3, r2, #28
 c005e18:	bf44      	itt	mi
 c005e1a:	232b      	movmi	r3, #43	@ 0x2b
 c005e1c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c005e20:	f89a 3000 	ldrb.w	r3, [sl]
 c005e24:	2b2a      	cmp	r3, #42	@ 0x2a
 c005e26:	d015      	beq.n	c005e54 <_vfiprintf_r+0x120>
 c005e28:	9a07      	ldr	r2, [sp, #28]
 c005e2a:	4654      	mov	r4, sl
 c005e2c:	2000      	movs	r0, #0
 c005e2e:	f04f 0c0a 	mov.w	ip, #10
 c005e32:	4621      	mov	r1, r4
 c005e34:	f811 3b01 	ldrb.w	r3, [r1], #1
 c005e38:	3b30      	subs	r3, #48	@ 0x30
 c005e3a:	2b09      	cmp	r3, #9
 c005e3c:	d94b      	bls.n	c005ed6 <_vfiprintf_r+0x1a2>
 c005e3e:	b1b0      	cbz	r0, c005e6e <_vfiprintf_r+0x13a>
 c005e40:	9207      	str	r2, [sp, #28]
 c005e42:	e014      	b.n	c005e6e <_vfiprintf_r+0x13a>
 c005e44:	eba0 0308 	sub.w	r3, r0, r8
 c005e48:	46a2      	mov	sl, r4
 c005e4a:	fa09 f303 	lsl.w	r3, r9, r3
 c005e4e:	4313      	orrs	r3, r2
 c005e50:	9304      	str	r3, [sp, #16]
 c005e52:	e7d2      	b.n	c005dfa <_vfiprintf_r+0xc6>
 c005e54:	9b03      	ldr	r3, [sp, #12]
 c005e56:	1d19      	adds	r1, r3, #4
 c005e58:	681b      	ldr	r3, [r3, #0]
 c005e5a:	2b00      	cmp	r3, #0
 c005e5c:	9103      	str	r1, [sp, #12]
 c005e5e:	bfbb      	ittet	lt
 c005e60:	425b      	neglt	r3, r3
 c005e62:	f042 0202 	orrlt.w	r2, r2, #2
 c005e66:	9307      	strge	r3, [sp, #28]
 c005e68:	9307      	strlt	r3, [sp, #28]
 c005e6a:	bfb8      	it	lt
 c005e6c:	9204      	strlt	r2, [sp, #16]
 c005e6e:	7823      	ldrb	r3, [r4, #0]
 c005e70:	2b2e      	cmp	r3, #46	@ 0x2e
 c005e72:	d10a      	bne.n	c005e8a <_vfiprintf_r+0x156>
 c005e74:	7863      	ldrb	r3, [r4, #1]
 c005e76:	2b2a      	cmp	r3, #42	@ 0x2a
 c005e78:	d132      	bne.n	c005ee0 <_vfiprintf_r+0x1ac>
 c005e7a:	9b03      	ldr	r3, [sp, #12]
 c005e7c:	3402      	adds	r4, #2
 c005e7e:	1d1a      	adds	r2, r3, #4
 c005e80:	681b      	ldr	r3, [r3, #0]
 c005e82:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 c005e86:	9203      	str	r2, [sp, #12]
 c005e88:	9305      	str	r3, [sp, #20]
 c005e8a:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ c005f60 <_vfiprintf_r+0x22c>
 c005e8e:	2203      	movs	r2, #3
 c005e90:	7821      	ldrb	r1, [r4, #0]
 c005e92:	4650      	mov	r0, sl
 c005e94:	f000 fb38 	bl	c006508 <memchr>
 c005e98:	b138      	cbz	r0, c005eaa <_vfiprintf_r+0x176>
 c005e9a:	eba0 000a 	sub.w	r0, r0, sl
 c005e9e:	2240      	movs	r2, #64	@ 0x40
 c005ea0:	9b04      	ldr	r3, [sp, #16]
 c005ea2:	3401      	adds	r4, #1
 c005ea4:	4082      	lsls	r2, r0
 c005ea6:	4313      	orrs	r3, r2
 c005ea8:	9304      	str	r3, [sp, #16]
 c005eaa:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005eae:	2206      	movs	r2, #6
 c005eb0:	4828      	ldr	r0, [pc, #160]	@ (c005f54 <_vfiprintf_r+0x220>)
 c005eb2:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 c005eb6:	f000 fb27 	bl	c006508 <memchr>
 c005eba:	2800      	cmp	r0, #0
 c005ebc:	d03f      	beq.n	c005f3e <_vfiprintf_r+0x20a>
 c005ebe:	4b26      	ldr	r3, [pc, #152]	@ (c005f58 <_vfiprintf_r+0x224>)
 c005ec0:	bb1b      	cbnz	r3, c005f0a <_vfiprintf_r+0x1d6>
 c005ec2:	9b03      	ldr	r3, [sp, #12]
 c005ec4:	3307      	adds	r3, #7
 c005ec6:	f023 0307 	bic.w	r3, r3, #7
 c005eca:	3308      	adds	r3, #8
 c005ecc:	9303      	str	r3, [sp, #12]
 c005ece:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c005ed0:	443b      	add	r3, r7
 c005ed2:	9309      	str	r3, [sp, #36]	@ 0x24
 c005ed4:	e76a      	b.n	c005dac <_vfiprintf_r+0x78>
 c005ed6:	fb0c 3202 	mla	r2, ip, r2, r3
 c005eda:	460c      	mov	r4, r1
 c005edc:	2001      	movs	r0, #1
 c005ede:	e7a8      	b.n	c005e32 <_vfiprintf_r+0xfe>
 c005ee0:	2300      	movs	r3, #0
 c005ee2:	3401      	adds	r4, #1
 c005ee4:	f04f 0c0a 	mov.w	ip, #10
 c005ee8:	4619      	mov	r1, r3
 c005eea:	9305      	str	r3, [sp, #20]
 c005eec:	4620      	mov	r0, r4
 c005eee:	f810 2b01 	ldrb.w	r2, [r0], #1
 c005ef2:	3a30      	subs	r2, #48	@ 0x30
 c005ef4:	2a09      	cmp	r2, #9
 c005ef6:	d903      	bls.n	c005f00 <_vfiprintf_r+0x1cc>
 c005ef8:	2b00      	cmp	r3, #0
 c005efa:	d0c6      	beq.n	c005e8a <_vfiprintf_r+0x156>
 c005efc:	9105      	str	r1, [sp, #20]
 c005efe:	e7c4      	b.n	c005e8a <_vfiprintf_r+0x156>
 c005f00:	fb0c 2101 	mla	r1, ip, r1, r2
 c005f04:	4604      	mov	r4, r0
 c005f06:	2301      	movs	r3, #1
 c005f08:	e7f0      	b.n	c005eec <_vfiprintf_r+0x1b8>
 c005f0a:	ab03      	add	r3, sp, #12
 c005f0c:	462a      	mov	r2, r5
 c005f0e:	a904      	add	r1, sp, #16
 c005f10:	4630      	mov	r0, r6
 c005f12:	9300      	str	r3, [sp, #0]
 c005f14:	4b11      	ldr	r3, [pc, #68]	@ (c005f5c <_vfiprintf_r+0x228>)
 c005f16:	f3af 8000 	nop.w
 c005f1a:	4607      	mov	r7, r0
 c005f1c:	1c78      	adds	r0, r7, #1
 c005f1e:	d1d6      	bne.n	c005ece <_vfiprintf_r+0x19a>
 c005f20:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005f22:	07d9      	lsls	r1, r3, #31
 c005f24:	d405      	bmi.n	c005f32 <_vfiprintf_r+0x1fe>
 c005f26:	89ab      	ldrh	r3, [r5, #12]
 c005f28:	059a      	lsls	r2, r3, #22
 c005f2a:	d402      	bmi.n	c005f32 <_vfiprintf_r+0x1fe>
 c005f2c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005f2e:	f7ff fe61 	bl	c005bf4 <__retarget_lock_release_recursive>
 c005f32:	89ab      	ldrh	r3, [r5, #12]
 c005f34:	065b      	lsls	r3, r3, #25
 c005f36:	f53f af1f 	bmi.w	c005d78 <_vfiprintf_r+0x44>
 c005f3a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c005f3c:	e71e      	b.n	c005d7c <_vfiprintf_r+0x48>
 c005f3e:	ab03      	add	r3, sp, #12
 c005f40:	462a      	mov	r2, r5
 c005f42:	a904      	add	r1, sp, #16
 c005f44:	4630      	mov	r0, r6
 c005f46:	9300      	str	r3, [sp, #0]
 c005f48:	4b04      	ldr	r3, [pc, #16]	@ (c005f5c <_vfiprintf_r+0x228>)
 c005f4a:	f000 f87d 	bl	c006048 <_printf_i>
 c005f4e:	e7e4      	b.n	c005f1a <_vfiprintf_r+0x1e6>
 c005f50:	0c006d87 	.word	0x0c006d87
 c005f54:	0c006d91 	.word	0x0c006d91
 c005f58:	00000000 	.word	0x00000000
 c005f5c:	0c005d0f 	.word	0x0c005d0f
 c005f60:	0c006d8d 	.word	0x0c006d8d

0c005f64 <_printf_common>:
 c005f64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c005f68:	4616      	mov	r6, r2
 c005f6a:	4698      	mov	r8, r3
 c005f6c:	688a      	ldr	r2, [r1, #8]
 c005f6e:	4607      	mov	r7, r0
 c005f70:	690b      	ldr	r3, [r1, #16]
 c005f72:	460c      	mov	r4, r1
 c005f74:	f8dd 9020 	ldr.w	r9, [sp, #32]
 c005f78:	4293      	cmp	r3, r2
 c005f7a:	bfb8      	it	lt
 c005f7c:	4613      	movlt	r3, r2
 c005f7e:	6033      	str	r3, [r6, #0]
 c005f80:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 c005f84:	b10a      	cbz	r2, c005f8a <_printf_common+0x26>
 c005f86:	3301      	adds	r3, #1
 c005f88:	6033      	str	r3, [r6, #0]
 c005f8a:	6823      	ldr	r3, [r4, #0]
 c005f8c:	0699      	lsls	r1, r3, #26
 c005f8e:	bf42      	ittt	mi
 c005f90:	6833      	ldrmi	r3, [r6, #0]
 c005f92:	3302      	addmi	r3, #2
 c005f94:	6033      	strmi	r3, [r6, #0]
 c005f96:	6825      	ldr	r5, [r4, #0]
 c005f98:	f015 0506 	ands.w	r5, r5, #6
 c005f9c:	d106      	bne.n	c005fac <_printf_common+0x48>
 c005f9e:	f104 0a19 	add.w	sl, r4, #25
 c005fa2:	68e3      	ldr	r3, [r4, #12]
 c005fa4:	6832      	ldr	r2, [r6, #0]
 c005fa6:	1a9b      	subs	r3, r3, r2
 c005fa8:	42ab      	cmp	r3, r5
 c005faa:	dc2b      	bgt.n	c006004 <_printf_common+0xa0>
 c005fac:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 c005fb0:	6822      	ldr	r2, [r4, #0]
 c005fb2:	3b00      	subs	r3, #0
 c005fb4:	bf18      	it	ne
 c005fb6:	2301      	movne	r3, #1
 c005fb8:	0692      	lsls	r2, r2, #26
 c005fba:	d430      	bmi.n	c00601e <_printf_common+0xba>
 c005fbc:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 c005fc0:	4641      	mov	r1, r8
 c005fc2:	4638      	mov	r0, r7
 c005fc4:	47c8      	blx	r9
 c005fc6:	3001      	adds	r0, #1
 c005fc8:	d023      	beq.n	c006012 <_printf_common+0xae>
 c005fca:	6823      	ldr	r3, [r4, #0]
 c005fcc:	341a      	adds	r4, #26
 c005fce:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c005fd2:	f003 0306 	and.w	r3, r3, #6
 c005fd6:	2b04      	cmp	r3, #4
 c005fd8:	bf0a      	itet	eq
 c005fda:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 c005fde:	2500      	movne	r5, #0
 c005fe0:	6833      	ldreq	r3, [r6, #0]
 c005fe2:	f04f 0600 	mov.w	r6, #0
 c005fe6:	bf08      	it	eq
 c005fe8:	1aed      	subeq	r5, r5, r3
 c005fea:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c005fee:	bf08      	it	eq
 c005ff0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c005ff4:	4293      	cmp	r3, r2
 c005ff6:	bfc4      	itt	gt
 c005ff8:	1a9b      	subgt	r3, r3, r2
 c005ffa:	18ed      	addgt	r5, r5, r3
 c005ffc:	42b5      	cmp	r5, r6
 c005ffe:	d11a      	bne.n	c006036 <_printf_common+0xd2>
 c006000:	2000      	movs	r0, #0
 c006002:	e008      	b.n	c006016 <_printf_common+0xb2>
 c006004:	2301      	movs	r3, #1
 c006006:	4652      	mov	r2, sl
 c006008:	4641      	mov	r1, r8
 c00600a:	4638      	mov	r0, r7
 c00600c:	47c8      	blx	r9
 c00600e:	3001      	adds	r0, #1
 c006010:	d103      	bne.n	c00601a <_printf_common+0xb6>
 c006012:	f04f 30ff 	mov.w	r0, #4294967295
 c006016:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00601a:	3501      	adds	r5, #1
 c00601c:	e7c1      	b.n	c005fa2 <_printf_common+0x3e>
 c00601e:	18e1      	adds	r1, r4, r3
 c006020:	1c5a      	adds	r2, r3, #1
 c006022:	2030      	movs	r0, #48	@ 0x30
 c006024:	3302      	adds	r3, #2
 c006026:	4422      	add	r2, r4
 c006028:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 c00602c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 c006030:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 c006034:	e7c2      	b.n	c005fbc <_printf_common+0x58>
 c006036:	2301      	movs	r3, #1
 c006038:	4622      	mov	r2, r4
 c00603a:	4641      	mov	r1, r8
 c00603c:	4638      	mov	r0, r7
 c00603e:	47c8      	blx	r9
 c006040:	3001      	adds	r0, #1
 c006042:	d0e6      	beq.n	c006012 <_printf_common+0xae>
 c006044:	3601      	adds	r6, #1
 c006046:	e7d9      	b.n	c005ffc <_printf_common+0x98>

0c006048 <_printf_i>:
 c006048:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c00604c:	7e0f      	ldrb	r7, [r1, #24]
 c00604e:	4691      	mov	r9, r2
 c006050:	4680      	mov	r8, r0
 c006052:	460c      	mov	r4, r1
 c006054:	2f78      	cmp	r7, #120	@ 0x78
 c006056:	469a      	mov	sl, r3
 c006058:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 c00605a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 c00605e:	d807      	bhi.n	c006070 <_printf_i+0x28>
 c006060:	2f62      	cmp	r7, #98	@ 0x62
 c006062:	d80a      	bhi.n	c00607a <_printf_i+0x32>
 c006064:	2f00      	cmp	r7, #0
 c006066:	f000 80d1 	beq.w	c00620c <_printf_i+0x1c4>
 c00606a:	2f58      	cmp	r7, #88	@ 0x58
 c00606c:	f000 80b8 	beq.w	c0061e0 <_printf_i+0x198>
 c006070:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c006074:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 c006078:	e03a      	b.n	c0060f0 <_printf_i+0xa8>
 c00607a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 c00607e:	2b15      	cmp	r3, #21
 c006080:	d8f6      	bhi.n	c006070 <_printf_i+0x28>
 c006082:	a101      	add	r1, pc, #4	@ (adr r1, c006088 <_printf_i+0x40>)
 c006084:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 c006088:	0c0060e1 	.word	0x0c0060e1
 c00608c:	0c0060f5 	.word	0x0c0060f5
 c006090:	0c006071 	.word	0x0c006071
 c006094:	0c006071 	.word	0x0c006071
 c006098:	0c006071 	.word	0x0c006071
 c00609c:	0c006071 	.word	0x0c006071
 c0060a0:	0c0060f5 	.word	0x0c0060f5
 c0060a4:	0c006071 	.word	0x0c006071
 c0060a8:	0c006071 	.word	0x0c006071
 c0060ac:	0c006071 	.word	0x0c006071
 c0060b0:	0c006071 	.word	0x0c006071
 c0060b4:	0c0061f3 	.word	0x0c0061f3
 c0060b8:	0c00611f 	.word	0x0c00611f
 c0060bc:	0c0061ad 	.word	0x0c0061ad
 c0060c0:	0c006071 	.word	0x0c006071
 c0060c4:	0c006071 	.word	0x0c006071
 c0060c8:	0c006215 	.word	0x0c006215
 c0060cc:	0c006071 	.word	0x0c006071
 c0060d0:	0c00611f 	.word	0x0c00611f
 c0060d4:	0c006071 	.word	0x0c006071
 c0060d8:	0c006071 	.word	0x0c006071
 c0060dc:	0c0061b5 	.word	0x0c0061b5
 c0060e0:	6833      	ldr	r3, [r6, #0]
 c0060e2:	1d1a      	adds	r2, r3, #4
 c0060e4:	681b      	ldr	r3, [r3, #0]
 c0060e6:	6032      	str	r2, [r6, #0]
 c0060e8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c0060ec:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 c0060f0:	2301      	movs	r3, #1
 c0060f2:	e09c      	b.n	c00622e <_printf_i+0x1e6>
 c0060f4:	6833      	ldr	r3, [r6, #0]
 c0060f6:	6820      	ldr	r0, [r4, #0]
 c0060f8:	1d19      	adds	r1, r3, #4
 c0060fa:	6031      	str	r1, [r6, #0]
 c0060fc:	0606      	lsls	r6, r0, #24
 c0060fe:	d501      	bpl.n	c006104 <_printf_i+0xbc>
 c006100:	681d      	ldr	r5, [r3, #0]
 c006102:	e003      	b.n	c00610c <_printf_i+0xc4>
 c006104:	0645      	lsls	r5, r0, #25
 c006106:	d5fb      	bpl.n	c006100 <_printf_i+0xb8>
 c006108:	f9b3 5000 	ldrsh.w	r5, [r3]
 c00610c:	2d00      	cmp	r5, #0
 c00610e:	da03      	bge.n	c006118 <_printf_i+0xd0>
 c006110:	232d      	movs	r3, #45	@ 0x2d
 c006112:	426d      	negs	r5, r5
 c006114:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c006118:	4858      	ldr	r0, [pc, #352]	@ (c00627c <_printf_i+0x234>)
 c00611a:	230a      	movs	r3, #10
 c00611c:	e011      	b.n	c006142 <_printf_i+0xfa>
 c00611e:	6821      	ldr	r1, [r4, #0]
 c006120:	6833      	ldr	r3, [r6, #0]
 c006122:	0608      	lsls	r0, r1, #24
 c006124:	f853 5b04 	ldr.w	r5, [r3], #4
 c006128:	d402      	bmi.n	c006130 <_printf_i+0xe8>
 c00612a:	0649      	lsls	r1, r1, #25
 c00612c:	bf48      	it	mi
 c00612e:	b2ad      	uxthmi	r5, r5
 c006130:	2f6f      	cmp	r7, #111	@ 0x6f
 c006132:	6033      	str	r3, [r6, #0]
 c006134:	4851      	ldr	r0, [pc, #324]	@ (c00627c <_printf_i+0x234>)
 c006136:	bf14      	ite	ne
 c006138:	230a      	movne	r3, #10
 c00613a:	2308      	moveq	r3, #8
 c00613c:	2100      	movs	r1, #0
 c00613e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 c006142:	6866      	ldr	r6, [r4, #4]
 c006144:	2e00      	cmp	r6, #0
 c006146:	60a6      	str	r6, [r4, #8]
 c006148:	db05      	blt.n	c006156 <_printf_i+0x10e>
 c00614a:	6821      	ldr	r1, [r4, #0]
 c00614c:	432e      	orrs	r6, r5
 c00614e:	f021 0104 	bic.w	r1, r1, #4
 c006152:	6021      	str	r1, [r4, #0]
 c006154:	d04b      	beq.n	c0061ee <_printf_i+0x1a6>
 c006156:	4616      	mov	r6, r2
 c006158:	fbb5 f1f3 	udiv	r1, r5, r3
 c00615c:	fb03 5711 	mls	r7, r3, r1, r5
 c006160:	5dc7      	ldrb	r7, [r0, r7]
 c006162:	f806 7d01 	strb.w	r7, [r6, #-1]!
 c006166:	462f      	mov	r7, r5
 c006168:	460d      	mov	r5, r1
 c00616a:	42bb      	cmp	r3, r7
 c00616c:	d9f4      	bls.n	c006158 <_printf_i+0x110>
 c00616e:	2b08      	cmp	r3, #8
 c006170:	d10b      	bne.n	c00618a <_printf_i+0x142>
 c006172:	6823      	ldr	r3, [r4, #0]
 c006174:	07df      	lsls	r7, r3, #31
 c006176:	d508      	bpl.n	c00618a <_printf_i+0x142>
 c006178:	6923      	ldr	r3, [r4, #16]
 c00617a:	6861      	ldr	r1, [r4, #4]
 c00617c:	4299      	cmp	r1, r3
 c00617e:	bfde      	ittt	le
 c006180:	2330      	movle	r3, #48	@ 0x30
 c006182:	f806 3c01 	strble.w	r3, [r6, #-1]
 c006186:	f106 36ff 	addle.w	r6, r6, #4294967295
 c00618a:	1b92      	subs	r2, r2, r6
 c00618c:	6122      	str	r2, [r4, #16]
 c00618e:	464b      	mov	r3, r9
 c006190:	aa03      	add	r2, sp, #12
 c006192:	4621      	mov	r1, r4
 c006194:	4640      	mov	r0, r8
 c006196:	f8cd a000 	str.w	sl, [sp]
 c00619a:	f7ff fee3 	bl	c005f64 <_printf_common>
 c00619e:	3001      	adds	r0, #1
 c0061a0:	d14a      	bne.n	c006238 <_printf_i+0x1f0>
 c0061a2:	f04f 30ff 	mov.w	r0, #4294967295
 c0061a6:	b004      	add	sp, #16
 c0061a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c0061ac:	6823      	ldr	r3, [r4, #0]
 c0061ae:	f043 0320 	orr.w	r3, r3, #32
 c0061b2:	6023      	str	r3, [r4, #0]
 c0061b4:	2778      	movs	r7, #120	@ 0x78
 c0061b6:	4832      	ldr	r0, [pc, #200]	@ (c006280 <_printf_i+0x238>)
 c0061b8:	6823      	ldr	r3, [r4, #0]
 c0061ba:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 c0061be:	061f      	lsls	r7, r3, #24
 c0061c0:	6831      	ldr	r1, [r6, #0]
 c0061c2:	f851 5b04 	ldr.w	r5, [r1], #4
 c0061c6:	d402      	bmi.n	c0061ce <_printf_i+0x186>
 c0061c8:	065f      	lsls	r7, r3, #25
 c0061ca:	bf48      	it	mi
 c0061cc:	b2ad      	uxthmi	r5, r5
 c0061ce:	6031      	str	r1, [r6, #0]
 c0061d0:	07d9      	lsls	r1, r3, #31
 c0061d2:	bf44      	itt	mi
 c0061d4:	f043 0320 	orrmi.w	r3, r3, #32
 c0061d8:	6023      	strmi	r3, [r4, #0]
 c0061da:	b11d      	cbz	r5, c0061e4 <_printf_i+0x19c>
 c0061dc:	2310      	movs	r3, #16
 c0061de:	e7ad      	b.n	c00613c <_printf_i+0xf4>
 c0061e0:	4826      	ldr	r0, [pc, #152]	@ (c00627c <_printf_i+0x234>)
 c0061e2:	e7e9      	b.n	c0061b8 <_printf_i+0x170>
 c0061e4:	6823      	ldr	r3, [r4, #0]
 c0061e6:	f023 0320 	bic.w	r3, r3, #32
 c0061ea:	6023      	str	r3, [r4, #0]
 c0061ec:	e7f6      	b.n	c0061dc <_printf_i+0x194>
 c0061ee:	4616      	mov	r6, r2
 c0061f0:	e7bd      	b.n	c00616e <_printf_i+0x126>
 c0061f2:	6833      	ldr	r3, [r6, #0]
 c0061f4:	6825      	ldr	r5, [r4, #0]
 c0061f6:	1d18      	adds	r0, r3, #4
 c0061f8:	6961      	ldr	r1, [r4, #20]
 c0061fa:	6030      	str	r0, [r6, #0]
 c0061fc:	062e      	lsls	r6, r5, #24
 c0061fe:	681b      	ldr	r3, [r3, #0]
 c006200:	d501      	bpl.n	c006206 <_printf_i+0x1be>
 c006202:	6019      	str	r1, [r3, #0]
 c006204:	e002      	b.n	c00620c <_printf_i+0x1c4>
 c006206:	0668      	lsls	r0, r5, #25
 c006208:	d5fb      	bpl.n	c006202 <_printf_i+0x1ba>
 c00620a:	8019      	strh	r1, [r3, #0]
 c00620c:	2300      	movs	r3, #0
 c00620e:	4616      	mov	r6, r2
 c006210:	6123      	str	r3, [r4, #16]
 c006212:	e7bc      	b.n	c00618e <_printf_i+0x146>
 c006214:	6833      	ldr	r3, [r6, #0]
 c006216:	2100      	movs	r1, #0
 c006218:	1d1a      	adds	r2, r3, #4
 c00621a:	6032      	str	r2, [r6, #0]
 c00621c:	681e      	ldr	r6, [r3, #0]
 c00621e:	6862      	ldr	r2, [r4, #4]
 c006220:	4630      	mov	r0, r6
 c006222:	f000 f971 	bl	c006508 <memchr>
 c006226:	b108      	cbz	r0, c00622c <_printf_i+0x1e4>
 c006228:	1b80      	subs	r0, r0, r6
 c00622a:	6060      	str	r0, [r4, #4]
 c00622c:	6863      	ldr	r3, [r4, #4]
 c00622e:	6123      	str	r3, [r4, #16]
 c006230:	2300      	movs	r3, #0
 c006232:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c006236:	e7aa      	b.n	c00618e <_printf_i+0x146>
 c006238:	6923      	ldr	r3, [r4, #16]
 c00623a:	4632      	mov	r2, r6
 c00623c:	4649      	mov	r1, r9
 c00623e:	4640      	mov	r0, r8
 c006240:	47d0      	blx	sl
 c006242:	3001      	adds	r0, #1
 c006244:	d0ad      	beq.n	c0061a2 <_printf_i+0x15a>
 c006246:	6823      	ldr	r3, [r4, #0]
 c006248:	079b      	lsls	r3, r3, #30
 c00624a:	d413      	bmi.n	c006274 <_printf_i+0x22c>
 c00624c:	68e0      	ldr	r0, [r4, #12]
 c00624e:	9b03      	ldr	r3, [sp, #12]
 c006250:	4298      	cmp	r0, r3
 c006252:	bfb8      	it	lt
 c006254:	4618      	movlt	r0, r3
 c006256:	e7a6      	b.n	c0061a6 <_printf_i+0x15e>
 c006258:	2301      	movs	r3, #1
 c00625a:	4632      	mov	r2, r6
 c00625c:	4649      	mov	r1, r9
 c00625e:	4640      	mov	r0, r8
 c006260:	47d0      	blx	sl
 c006262:	3001      	adds	r0, #1
 c006264:	d09d      	beq.n	c0061a2 <_printf_i+0x15a>
 c006266:	3501      	adds	r5, #1
 c006268:	68e3      	ldr	r3, [r4, #12]
 c00626a:	9903      	ldr	r1, [sp, #12]
 c00626c:	1a5b      	subs	r3, r3, r1
 c00626e:	42ab      	cmp	r3, r5
 c006270:	dcf2      	bgt.n	c006258 <_printf_i+0x210>
 c006272:	e7eb      	b.n	c00624c <_printf_i+0x204>
 c006274:	2500      	movs	r5, #0
 c006276:	f104 0619 	add.w	r6, r4, #25
 c00627a:	e7f5      	b.n	c006268 <_printf_i+0x220>
 c00627c:	0c006d98 	.word	0x0c006d98
 c006280:	0c006da9 	.word	0x0c006da9

0c006284 <__sflush_r>:
 c006284:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 c006288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00628c:	0716      	lsls	r6, r2, #28
 c00628e:	4605      	mov	r5, r0
 c006290:	460c      	mov	r4, r1
 c006292:	d454      	bmi.n	c00633e <__sflush_r+0xba>
 c006294:	684b      	ldr	r3, [r1, #4]
 c006296:	2b00      	cmp	r3, #0
 c006298:	dc02      	bgt.n	c0062a0 <__sflush_r+0x1c>
 c00629a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 c00629c:	2b00      	cmp	r3, #0
 c00629e:	dd48      	ble.n	c006332 <__sflush_r+0xae>
 c0062a0:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c0062a2:	2e00      	cmp	r6, #0
 c0062a4:	d045      	beq.n	c006332 <__sflush_r+0xae>
 c0062a6:	2300      	movs	r3, #0
 c0062a8:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 c0062ac:	682f      	ldr	r7, [r5, #0]
 c0062ae:	6a21      	ldr	r1, [r4, #32]
 c0062b0:	602b      	str	r3, [r5, #0]
 c0062b2:	d030      	beq.n	c006316 <__sflush_r+0x92>
 c0062b4:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 c0062b6:	89a3      	ldrh	r3, [r4, #12]
 c0062b8:	0759      	lsls	r1, r3, #29
 c0062ba:	d505      	bpl.n	c0062c8 <__sflush_r+0x44>
 c0062bc:	6863      	ldr	r3, [r4, #4]
 c0062be:	1ad2      	subs	r2, r2, r3
 c0062c0:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c0062c2:	b10b      	cbz	r3, c0062c8 <__sflush_r+0x44>
 c0062c4:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c0062c6:	1ad2      	subs	r2, r2, r3
 c0062c8:	2300      	movs	r3, #0
 c0062ca:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c0062cc:	6a21      	ldr	r1, [r4, #32]
 c0062ce:	4628      	mov	r0, r5
 c0062d0:	47b0      	blx	r6
 c0062d2:	1c43      	adds	r3, r0, #1
 c0062d4:	89a3      	ldrh	r3, [r4, #12]
 c0062d6:	d106      	bne.n	c0062e6 <__sflush_r+0x62>
 c0062d8:	6829      	ldr	r1, [r5, #0]
 c0062da:	291d      	cmp	r1, #29
 c0062dc:	d82b      	bhi.n	c006336 <__sflush_r+0xb2>
 c0062de:	4a2a      	ldr	r2, [pc, #168]	@ (c006388 <__sflush_r+0x104>)
 c0062e0:	40ca      	lsrs	r2, r1
 c0062e2:	07d6      	lsls	r6, r2, #31
 c0062e4:	d527      	bpl.n	c006336 <__sflush_r+0xb2>
 c0062e6:	2200      	movs	r2, #0
 c0062e8:	04d9      	lsls	r1, r3, #19
 c0062ea:	6062      	str	r2, [r4, #4]
 c0062ec:	6922      	ldr	r2, [r4, #16]
 c0062ee:	6022      	str	r2, [r4, #0]
 c0062f0:	d504      	bpl.n	c0062fc <__sflush_r+0x78>
 c0062f2:	1c42      	adds	r2, r0, #1
 c0062f4:	d101      	bne.n	c0062fa <__sflush_r+0x76>
 c0062f6:	682b      	ldr	r3, [r5, #0]
 c0062f8:	b903      	cbnz	r3, c0062fc <__sflush_r+0x78>
 c0062fa:	6560      	str	r0, [r4, #84]	@ 0x54
 c0062fc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c0062fe:	602f      	str	r7, [r5, #0]
 c006300:	b1b9      	cbz	r1, c006332 <__sflush_r+0xae>
 c006302:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c006306:	4299      	cmp	r1, r3
 c006308:	d002      	beq.n	c006310 <__sflush_r+0x8c>
 c00630a:	4628      	mov	r0, r5
 c00630c:	f7ff fc9e 	bl	c005c4c <_free_r>
 c006310:	2300      	movs	r3, #0
 c006312:	6363      	str	r3, [r4, #52]	@ 0x34
 c006314:	e00d      	b.n	c006332 <__sflush_r+0xae>
 c006316:	2301      	movs	r3, #1
 c006318:	4628      	mov	r0, r5
 c00631a:	47b0      	blx	r6
 c00631c:	4602      	mov	r2, r0
 c00631e:	1c50      	adds	r0, r2, #1
 c006320:	d1c9      	bne.n	c0062b6 <__sflush_r+0x32>
 c006322:	682b      	ldr	r3, [r5, #0]
 c006324:	2b00      	cmp	r3, #0
 c006326:	d0c6      	beq.n	c0062b6 <__sflush_r+0x32>
 c006328:	2b1d      	cmp	r3, #29
 c00632a:	d001      	beq.n	c006330 <__sflush_r+0xac>
 c00632c:	2b16      	cmp	r3, #22
 c00632e:	d11d      	bne.n	c00636c <__sflush_r+0xe8>
 c006330:	602f      	str	r7, [r5, #0]
 c006332:	2000      	movs	r0, #0
 c006334:	e021      	b.n	c00637a <__sflush_r+0xf6>
 c006336:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c00633a:	b21b      	sxth	r3, r3
 c00633c:	e01a      	b.n	c006374 <__sflush_r+0xf0>
 c00633e:	690f      	ldr	r7, [r1, #16]
 c006340:	2f00      	cmp	r7, #0
 c006342:	d0f6      	beq.n	c006332 <__sflush_r+0xae>
 c006344:	0793      	lsls	r3, r2, #30
 c006346:	680e      	ldr	r6, [r1, #0]
 c006348:	600f      	str	r7, [r1, #0]
 c00634a:	bf0c      	ite	eq
 c00634c:	694b      	ldreq	r3, [r1, #20]
 c00634e:	2300      	movne	r3, #0
 c006350:	eba6 0807 	sub.w	r8, r6, r7
 c006354:	608b      	str	r3, [r1, #8]
 c006356:	f1b8 0f00 	cmp.w	r8, #0
 c00635a:	ddea      	ble.n	c006332 <__sflush_r+0xae>
 c00635c:	4643      	mov	r3, r8
 c00635e:	463a      	mov	r2, r7
 c006360:	6a21      	ldr	r1, [r4, #32]
 c006362:	4628      	mov	r0, r5
 c006364:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 c006366:	47b0      	blx	r6
 c006368:	2800      	cmp	r0, #0
 c00636a:	dc08      	bgt.n	c00637e <__sflush_r+0xfa>
 c00636c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c006370:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c006374:	f04f 30ff 	mov.w	r0, #4294967295
 c006378:	81a3      	strh	r3, [r4, #12]
 c00637a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c00637e:	4407      	add	r7, r0
 c006380:	eba8 0800 	sub.w	r8, r8, r0
 c006384:	e7e7      	b.n	c006356 <__sflush_r+0xd2>
 c006386:	bf00      	nop
 c006388:	20400001 	.word	0x20400001

0c00638c <_fflush_r>:
 c00638c:	b538      	push	{r3, r4, r5, lr}
 c00638e:	690b      	ldr	r3, [r1, #16]
 c006390:	4605      	mov	r5, r0
 c006392:	460c      	mov	r4, r1
 c006394:	b913      	cbnz	r3, c00639c <_fflush_r+0x10>
 c006396:	2500      	movs	r5, #0
 c006398:	4628      	mov	r0, r5
 c00639a:	bd38      	pop	{r3, r4, r5, pc}
 c00639c:	b118      	cbz	r0, c0063a6 <_fflush_r+0x1a>
 c00639e:	6a03      	ldr	r3, [r0, #32]
 c0063a0:	b90b      	cbnz	r3, c0063a6 <_fflush_r+0x1a>
 c0063a2:	f7ff fa0b 	bl	c0057bc <__sinit>
 c0063a6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0063aa:	2b00      	cmp	r3, #0
 c0063ac:	d0f3      	beq.n	c006396 <_fflush_r+0xa>
 c0063ae:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 c0063b0:	07d0      	lsls	r0, r2, #31
 c0063b2:	d404      	bmi.n	c0063be <_fflush_r+0x32>
 c0063b4:	0599      	lsls	r1, r3, #22
 c0063b6:	d402      	bmi.n	c0063be <_fflush_r+0x32>
 c0063b8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c0063ba:	f7ff fc1a 	bl	c005bf2 <__retarget_lock_acquire_recursive>
 c0063be:	4628      	mov	r0, r5
 c0063c0:	4621      	mov	r1, r4
 c0063c2:	f7ff ff5f 	bl	c006284 <__sflush_r>
 c0063c6:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c0063c8:	4605      	mov	r5, r0
 c0063ca:	07da      	lsls	r2, r3, #31
 c0063cc:	d4e4      	bmi.n	c006398 <_fflush_r+0xc>
 c0063ce:	89a3      	ldrh	r3, [r4, #12]
 c0063d0:	059b      	lsls	r3, r3, #22
 c0063d2:	d4e1      	bmi.n	c006398 <_fflush_r+0xc>
 c0063d4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c0063d6:	f7ff fc0d 	bl	c005bf4 <__retarget_lock_release_recursive>
 c0063da:	e7dd      	b.n	c006398 <_fflush_r+0xc>

0c0063dc <fiprintf>:
 c0063dc:	b40e      	push	{r1, r2, r3}
 c0063de:	b503      	push	{r0, r1, lr}
 c0063e0:	ab03      	add	r3, sp, #12
 c0063e2:	4601      	mov	r1, r0
 c0063e4:	4805      	ldr	r0, [pc, #20]	@ (c0063fc <fiprintf+0x20>)
 c0063e6:	f853 2b04 	ldr.w	r2, [r3], #4
 c0063ea:	6800      	ldr	r0, [r0, #0]
 c0063ec:	9301      	str	r3, [sp, #4]
 c0063ee:	f7ff fca1 	bl	c005d34 <_vfiprintf_r>
 c0063f2:	b002      	add	sp, #8
 c0063f4:	f85d eb04 	ldr.w	lr, [sp], #4
 c0063f8:	b003      	add	sp, #12
 c0063fa:	4770      	bx	lr
 c0063fc:	3000004c 	.word	0x3000004c

0c006400 <__swhatbuf_r>:
 c006400:	b570      	push	{r4, r5, r6, lr}
 c006402:	460c      	mov	r4, r1
 c006404:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c006408:	b096      	sub	sp, #88	@ 0x58
 c00640a:	4615      	mov	r5, r2
 c00640c:	2900      	cmp	r1, #0
 c00640e:	461e      	mov	r6, r3
 c006410:	da0c      	bge.n	c00642c <__swhatbuf_r+0x2c>
 c006412:	89a3      	ldrh	r3, [r4, #12]
 c006414:	2100      	movs	r1, #0
 c006416:	f013 0f80 	tst.w	r3, #128	@ 0x80
 c00641a:	bf14      	ite	ne
 c00641c:	2340      	movne	r3, #64	@ 0x40
 c00641e:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 c006422:	2000      	movs	r0, #0
 c006424:	6031      	str	r1, [r6, #0]
 c006426:	602b      	str	r3, [r5, #0]
 c006428:	b016      	add	sp, #88	@ 0x58
 c00642a:	bd70      	pop	{r4, r5, r6, pc}
 c00642c:	466a      	mov	r2, sp
 c00642e:	f000 f849 	bl	c0064c4 <_fstat_r>
 c006432:	2800      	cmp	r0, #0
 c006434:	dbed      	blt.n	c006412 <__swhatbuf_r+0x12>
 c006436:	9901      	ldr	r1, [sp, #4]
 c006438:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 c00643c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 c006440:	4259      	negs	r1, r3
 c006442:	4159      	adcs	r1, r3
 c006444:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 c006448:	e7eb      	b.n	c006422 <__swhatbuf_r+0x22>

0c00644a <__smakebuf_r>:
 c00644a:	898b      	ldrh	r3, [r1, #12]
 c00644c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c00644e:	079d      	lsls	r5, r3, #30
 c006450:	4606      	mov	r6, r0
 c006452:	460c      	mov	r4, r1
 c006454:	d507      	bpl.n	c006466 <__smakebuf_r+0x1c>
 c006456:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 c00645a:	6023      	str	r3, [r4, #0]
 c00645c:	6123      	str	r3, [r4, #16]
 c00645e:	2301      	movs	r3, #1
 c006460:	6163      	str	r3, [r4, #20]
 c006462:	b003      	add	sp, #12
 c006464:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c006466:	ab01      	add	r3, sp, #4
 c006468:	466a      	mov	r2, sp
 c00646a:	f7ff ffc9 	bl	c006400 <__swhatbuf_r>
 c00646e:	9f00      	ldr	r7, [sp, #0]
 c006470:	4605      	mov	r5, r0
 c006472:	4630      	mov	r0, r6
 c006474:	4639      	mov	r1, r7
 c006476:	f7ff f81d 	bl	c0054b4 <_malloc_r>
 c00647a:	b948      	cbnz	r0, c006490 <__smakebuf_r+0x46>
 c00647c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c006480:	059a      	lsls	r2, r3, #22
 c006482:	d4ee      	bmi.n	c006462 <__smakebuf_r+0x18>
 c006484:	f023 0303 	bic.w	r3, r3, #3
 c006488:	f043 0302 	orr.w	r3, r3, #2
 c00648c:	81a3      	strh	r3, [r4, #12]
 c00648e:	e7e2      	b.n	c006456 <__smakebuf_r+0xc>
 c006490:	89a3      	ldrh	r3, [r4, #12]
 c006492:	6020      	str	r0, [r4, #0]
 c006494:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c006498:	81a3      	strh	r3, [r4, #12]
 c00649a:	9b01      	ldr	r3, [sp, #4]
 c00649c:	e9c4 0704 	strd	r0, r7, [r4, #16]
 c0064a0:	b15b      	cbz	r3, c0064ba <__smakebuf_r+0x70>
 c0064a2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c0064a6:	4630      	mov	r0, r6
 c0064a8:	f000 f81e 	bl	c0064e8 <_isatty_r>
 c0064ac:	b128      	cbz	r0, c0064ba <__smakebuf_r+0x70>
 c0064ae:	89a3      	ldrh	r3, [r4, #12]
 c0064b0:	f023 0303 	bic.w	r3, r3, #3
 c0064b4:	f043 0301 	orr.w	r3, r3, #1
 c0064b8:	81a3      	strh	r3, [r4, #12]
 c0064ba:	89a3      	ldrh	r3, [r4, #12]
 c0064bc:	431d      	orrs	r5, r3
 c0064be:	81a5      	strh	r5, [r4, #12]
 c0064c0:	e7cf      	b.n	c006462 <__smakebuf_r+0x18>
	...

0c0064c4 <_fstat_r>:
 c0064c4:	b538      	push	{r3, r4, r5, lr}
 c0064c6:	2300      	movs	r3, #0
 c0064c8:	4d06      	ldr	r5, [pc, #24]	@ (c0064e4 <_fstat_r+0x20>)
 c0064ca:	4604      	mov	r4, r0
 c0064cc:	4608      	mov	r0, r1
 c0064ce:	4611      	mov	r1, r2
 c0064d0:	602b      	str	r3, [r5, #0]
 c0064d2:	f7fd f92d 	bl	c003730 <_fstat>
 c0064d6:	1c43      	adds	r3, r0, #1
 c0064d8:	d102      	bne.n	c0064e0 <_fstat_r+0x1c>
 c0064da:	682b      	ldr	r3, [r5, #0]
 c0064dc:	b103      	cbz	r3, c0064e0 <_fstat_r+0x1c>
 c0064de:	6023      	str	r3, [r4, #0]
 c0064e0:	bd38      	pop	{r3, r4, r5, pc}
 c0064e2:	bf00      	nop
 c0064e4:	30002e1c 	.word	0x30002e1c

0c0064e8 <_isatty_r>:
 c0064e8:	b538      	push	{r3, r4, r5, lr}
 c0064ea:	2300      	movs	r3, #0
 c0064ec:	4d05      	ldr	r5, [pc, #20]	@ (c006504 <_isatty_r+0x1c>)
 c0064ee:	4604      	mov	r4, r0
 c0064f0:	4608      	mov	r0, r1
 c0064f2:	602b      	str	r3, [r5, #0]
 c0064f4:	f7fd f92c 	bl	c003750 <_isatty>
 c0064f8:	1c43      	adds	r3, r0, #1
 c0064fa:	d102      	bne.n	c006502 <_isatty_r+0x1a>
 c0064fc:	682b      	ldr	r3, [r5, #0]
 c0064fe:	b103      	cbz	r3, c006502 <_isatty_r+0x1a>
 c006500:	6023      	str	r3, [r4, #0]
 c006502:	bd38      	pop	{r3, r4, r5, pc}
 c006504:	30002e1c 	.word	0x30002e1c

0c006508 <memchr>:
 c006508:	b2c9      	uxtb	r1, r1
 c00650a:	4603      	mov	r3, r0
 c00650c:	4402      	add	r2, r0
 c00650e:	b510      	push	{r4, lr}
 c006510:	4293      	cmp	r3, r2
 c006512:	4618      	mov	r0, r3
 c006514:	d101      	bne.n	c00651a <memchr+0x12>
 c006516:	2000      	movs	r0, #0
 c006518:	e003      	b.n	c006522 <memchr+0x1a>
 c00651a:	7804      	ldrb	r4, [r0, #0]
 c00651c:	3301      	adds	r3, #1
 c00651e:	428c      	cmp	r4, r1
 c006520:	d1f6      	bne.n	c006510 <memchr+0x8>
 c006522:	bd10      	pop	{r4, pc}

0c006524 <abort>:
 c006524:	2006      	movs	r0, #6
 c006526:	b508      	push	{r3, lr}
 c006528:	f000 f82c 	bl	c006584 <raise>
 c00652c:	2001      	movs	r0, #1
 c00652e:	f7fd f8af 	bl	c003690 <_exit>

0c006532 <_raise_r>:
 c006532:	291f      	cmp	r1, #31
 c006534:	b538      	push	{r3, r4, r5, lr}
 c006536:	4605      	mov	r5, r0
 c006538:	460c      	mov	r4, r1
 c00653a:	d904      	bls.n	c006546 <_raise_r+0x14>
 c00653c:	2316      	movs	r3, #22
 c00653e:	6003      	str	r3, [r0, #0]
 c006540:	f04f 30ff 	mov.w	r0, #4294967295
 c006544:	bd38      	pop	{r3, r4, r5, pc}
 c006546:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 c006548:	b112      	cbz	r2, c006550 <_raise_r+0x1e>
 c00654a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 c00654e:	b94b      	cbnz	r3, c006564 <_raise_r+0x32>
 c006550:	4628      	mov	r0, r5
 c006552:	f000 f831 	bl	c0065b8 <_getpid_r>
 c006556:	4622      	mov	r2, r4
 c006558:	4601      	mov	r1, r0
 c00655a:	4628      	mov	r0, r5
 c00655c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c006560:	f000 b818 	b.w	c006594 <_kill_r>
 c006564:	2b01      	cmp	r3, #1
 c006566:	d00a      	beq.n	c00657e <_raise_r+0x4c>
 c006568:	1c59      	adds	r1, r3, #1
 c00656a:	d103      	bne.n	c006574 <_raise_r+0x42>
 c00656c:	2316      	movs	r3, #22
 c00656e:	6003      	str	r3, [r0, #0]
 c006570:	2001      	movs	r0, #1
 c006572:	e7e7      	b.n	c006544 <_raise_r+0x12>
 c006574:	2100      	movs	r1, #0
 c006576:	4620      	mov	r0, r4
 c006578:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 c00657c:	4798      	blx	r3
 c00657e:	2000      	movs	r0, #0
 c006580:	e7e0      	b.n	c006544 <_raise_r+0x12>
	...

0c006584 <raise>:
 c006584:	4b02      	ldr	r3, [pc, #8]	@ (c006590 <raise+0xc>)
 c006586:	4601      	mov	r1, r0
 c006588:	6818      	ldr	r0, [r3, #0]
 c00658a:	f7ff bfd2 	b.w	c006532 <_raise_r>
 c00658e:	bf00      	nop
 c006590:	3000004c 	.word	0x3000004c

0c006594 <_kill_r>:
 c006594:	b538      	push	{r3, r4, r5, lr}
 c006596:	2300      	movs	r3, #0
 c006598:	4d06      	ldr	r5, [pc, #24]	@ (c0065b4 <_kill_r+0x20>)
 c00659a:	4604      	mov	r4, r0
 c00659c:	4608      	mov	r0, r1
 c00659e:	4611      	mov	r1, r2
 c0065a0:	602b      	str	r3, [r5, #0]
 c0065a2:	f7fd f865 	bl	c003670 <_kill>
 c0065a6:	1c43      	adds	r3, r0, #1
 c0065a8:	d102      	bne.n	c0065b0 <_kill_r+0x1c>
 c0065aa:	682b      	ldr	r3, [r5, #0]
 c0065ac:	b103      	cbz	r3, c0065b0 <_kill_r+0x1c>
 c0065ae:	6023      	str	r3, [r4, #0]
 c0065b0:	bd38      	pop	{r3, r4, r5, pc}
 c0065b2:	bf00      	nop
 c0065b4:	30002e1c 	.word	0x30002e1c

0c0065b8 <_getpid_r>:
 c0065b8:	f7fd b852 	b.w	c003660 <_getpid>

0c0065bc <_init>:
 c0065bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0065be:	bf00      	nop
 c0065c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c0065c2:	bc08      	pop	{r3}
 c0065c4:	469e      	mov	lr, r3
 c0065c6:	4770      	bx	lr

0c0065c8 <_fini>:
 c0065c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0065ca:	bf00      	nop
 c0065cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c0065ce:	bc08      	pop	{r3}
 c0065d0:	469e      	mov	lr, r3
 c0065d2:	4770      	bx	lr
 c0065d4:	0000      	movs	r0, r0
	...

Disassembly of section .gnu.sgstubs:

0c03e000 <SECURE_RegisterPrintCallback>:
 c03e000:	e97f e97f 	sg
 c03e004:	f7c3 bb22 	b.w	c00164c <__acle_se_SECURE_RegisterPrintCallback>

0c03e008 <Secure_WriteFlash_128KB_2>:
 c03e008:	e97f e97f 	sg
 c03e00c:	f7c4 beb0 	b.w	c002d70 <__acle_se_Secure_WriteFlash_128KB_2>

0c03e010 <SecureInit_DePrioritizeNSExceptions>:
 c03e010:	e97f e97f 	sg
 c03e014:	f7c7 b97e 	b.w	c005314 <__acle_se_SecureInit_DePrioritizeNSExceptions>

0c03e018 <SECURE_SystemCoreClockUpdate>:
 c03e018:	e97f e97f 	sg
 c03e01c:	f7c5 bda4 	b.w	c003b68 <__acle_se_SECURE_SystemCoreClockUpdate>

0c03e020 <SecureContext_AllocateContext>:
 c03e020:	e97f e97f 	sg
 c03e024:	f7c6 be5f 	b.w	c004ce6 <__acle_se_SecureContext_AllocateContext>

0c03e028 <Secure_WriteFlash_128KB>:
 c03e028:	e97f e97f 	sg
 c03e02c:	f7c4 bd80 	b.w	c002b30 <__acle_se_Secure_WriteFlash_128KB>

0c03e030 <SECURE_SMARM>:
 c03e030:	e97f e97f 	sg
 c03e034:	f7c4 b85a 	b.w	c0020ec <__acle_se_SECURE_SMARM>

0c03e038 <SECURE_ShuffledHMAC>:
 c03e038:	e97f e97f 	sg
 c03e03c:	f7c3 bd8e 	b.w	c001b5c <__acle_se_SECURE_ShuffledHMAC>

0c03e040 <SECURE_LEDToggle>:
 c03e040:	e97f e97f 	sg
 c03e044:	f7c3 bbe6 	b.w	c001814 <__acle_se_SECURE_LEDToggle>

0c03e048 <SECURE_ShuffledHMAC_secure>:
 c03e048:	e97f e97f 	sg
 c03e04c:	f7c3 bf44 	b.w	c001ed8 <__acle_se_SECURE_ShuffledHMAC_secure>

0c03e050 <Secure_Flash256KB>:
 c03e050:	e97f e97f 	sg
 c03e054:	f7c4 bfac 	b.w	c002fb0 <__acle_se_Secure_Flash256KB>

0c03e058 <SecureContext_Init>:
 c03e058:	e97f e97f 	sg
 c03e05c:	f7c6 bdf8 	b.w	c004c50 <__acle_se_SecureContext_Init>

0c03e060 <SECURE_LinearHMAC>:
 c03e060:	e97f e97f 	sg
 c03e064:	f7c3 bcfe 	b.w	c001a64 <__acle_se_SECURE_LinearHMAC>

0c03e068 <Secure_FlashTest>:
 c03e068:	e97f e97f 	sg
 c03e06c:	f7c4 ba6c 	b.w	c002548 <__acle_se_Secure_FlashTest>

0c03e070 <Secure_EraseWriteVerify>:
 c03e070:	e97f e97f 	sg
 c03e074:	f7c4 bc2c 	b.w	c0028d0 <__acle_se_Secure_EraseWriteVerify>

0c03e078 <SECURE_TEST>:
 c03e078:	e97f e97f 	sg
 c03e07c:	f7c4 b956 	b.w	c00232c <__acle_se_SECURE_TEST>

0c03e080 <SecureContext_LoadContext>:
 c03e080:	e97f e97f 	sg
 c03e084:	f7c6 beec 	b.w	c004e60 <__acle_se_SecureContext_LoadContext>

0c03e088 <SECURE_RegisterCallback>:
 c03e088:	e97f e97f 	sg
 c03e08c:	f7c3 bb6c 	b.w	c001768 <__acle_se_SECURE_RegisterCallback>

0c03e090 <SECURE_Print>:
 c03e090:	e97f e97f 	sg
 c03e094:	f7c3 bb20 	b.w	c0016d8 <__acle_se_SECURE_Print>

0c03e098 <SecureContext_SaveContext>:
 c03e098:	e97f e97f 	sg
 c03e09c:	f7c6 bf26 	b.w	c004eec <__acle_se_SecureContext_SaveContext>

0c03e0a0 <SecureInit_EnableNSFPUAccess>:
 c03e0a0:	e97f e97f 	sg
 c03e0a4:	f7c7 b984 	b.w	c0053b0 <__acle_se_SecureInit_EnableNSFPUAccess>

0c03e0a8 <SecureContext_FreeContext>:
 c03e0a8:	e97f e97f 	sg
 c03e0ac:	f7c6 be82 	b.w	c004db4 <__acle_se_SecureContext_FreeContext>

0c03e0b0 <SECURE_CopyMessage>:
 c03e0b0:	e97f e97f 	sg
 c03e0b4:	f7c3 bbec 	b.w	c001890 <__acle_se_SECURE_CopyMessage>

0c03e0b8 <SECURE_ComputeHMAC>:
 c03e0b8:	e97f e97f 	sg
 c03e0bc:	f7c3 bc3e 	b.w	c00193c <__acle_se_SECURE_ComputeHMAC>
