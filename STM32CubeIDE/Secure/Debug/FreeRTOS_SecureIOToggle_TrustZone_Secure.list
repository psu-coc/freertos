
FreeRTOS_SecureIOToggle_TrustZone_Secure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  0c000000  0c000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000063b0  0c0001f8  0c0001f8  000011f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000007e8  0c0065a8  0c0065a8  000075a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0c006d90  0c006d90  000090c0  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  0c006d90  0c006d90  00007d90  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0c006d98  0c006d98  000090c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0c006d98  0c006d98  00007d98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000008  0c006da0  0c006da0  00007da0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         000000a0  30000000  0c006da8  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .gnu.sgstubs  000000c0  0c03e000  0c03e000  00009000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .bss          00003388  300000a0  300000a0  0000a0a0  2**2
                  ALLOC
 11 .gnu.linkonce.b._ns_work_buffer 00000100  30003428  30003428  0000a0a0  2**3
                  ALLOC, LINK_ONCE_DISCARD
 12 ._user_heap_stack 00000600  30003528  30003528  0000a0a0  2**0
                  ALLOC
 13 .ARM.attributes 00000036  00000000  00000000  000090c0  2**0
                  CONTENTS, READONLY
 14 .debug_line   000105c4  00000000  00000000  000090f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line_str 000000ae  00000000  00000000  000196ba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_info   0000c752  00000000  00000000  00019768  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00002bec  00000000  00000000  00025eba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00000d30  00000000  00000000  00028aa8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00110ff6  00000000  00000000  000297d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_rnglists 000009d2  00000000  00000000  0013a7ce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0002b458  00000000  00000000  0013b1a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .comment      00000043  00000000  00000000  001665f8  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00003e78  00000000  00000000  0016663c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0c0001f8 <__do_global_dtors_aux>:
 c0001f8:	b510      	push	{r4, lr}
 c0001fa:	4c05      	ldr	r4, [pc, #20]	@ (c000210 <__do_global_dtors_aux+0x18>)
 c0001fc:	7823      	ldrb	r3, [r4, #0]
 c0001fe:	b933      	cbnz	r3, c00020e <__do_global_dtors_aux+0x16>
 c000200:	4b04      	ldr	r3, [pc, #16]	@ (c000214 <__do_global_dtors_aux+0x1c>)
 c000202:	b113      	cbz	r3, c00020a <__do_global_dtors_aux+0x12>
 c000204:	4804      	ldr	r0, [pc, #16]	@ (c000218 <__do_global_dtors_aux+0x20>)
 c000206:	f3af 8000 	nop.w
 c00020a:	2301      	movs	r3, #1
 c00020c:	7023      	strb	r3, [r4, #0]
 c00020e:	bd10      	pop	{r4, pc}
 c000210:	300000a0 	.word	0x300000a0
 c000214:	00000000 	.word	0x00000000
 c000218:	0c00658c 	.word	0x0c00658c

0c00021c <frame_dummy>:
 c00021c:	b508      	push	{r3, lr}
 c00021e:	4b03      	ldr	r3, [pc, #12]	@ (c00022c <frame_dummy+0x10>)
 c000220:	b11b      	cbz	r3, c00022a <frame_dummy+0xe>
 c000222:	4903      	ldr	r1, [pc, #12]	@ (c000230 <frame_dummy+0x14>)
 c000224:	4803      	ldr	r0, [pc, #12]	@ (c000234 <frame_dummy+0x18>)
 c000226:	f3af 8000 	nop.w
 c00022a:	bd08      	pop	{r3, pc}
 c00022c:	00000000 	.word	0x00000000
 c000230:	300000a4 	.word	0x300000a4
 c000234:	0c00658c 	.word	0x0c00658c

0c000238 <strlen>:
 c000238:	4603      	mov	r3, r0
 c00023a:	f813 2b01 	ldrb.w	r2, [r3], #1
 c00023e:	2a00      	cmp	r2, #0
 c000240:	d1fb      	bne.n	c00023a <strlen+0x2>
 c000242:	1a18      	subs	r0, r3, r0
 c000244:	3801      	subs	r0, #1
 c000246:	4770      	bx	lr

0c000248 <__gnu_cmse_nonsecure_call>:
 c000248:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
 c00024c:	4627      	mov	r7, r4
 c00024e:	46a0      	mov	r8, r4
 c000250:	46a1      	mov	r9, r4
 c000252:	46a2      	mov	sl, r4
 c000254:	46a3      	mov	fp, r4
 c000256:	46a4      	mov	ip, r4
 c000258:	ed2d 8b10 	vpush	{d8-d15}
 c00025c:	f04f 0500 	mov.w	r5, #0
 c000260:	ec45 5b18 	vmov	d8, r5, r5
 c000264:	ec45 5a19 	vmov	s18, s19, r5, r5
 c000268:	ec45 5a1a 	vmov	s20, s21, r5, r5
 c00026c:	ec45 5a1b 	vmov	s22, s23, r5, r5
 c000270:	ec45 5a1c 	vmov	s24, s25, r5, r5
 c000274:	ec45 5a1d 	vmov	s26, s27, r5, r5
 c000278:	ec45 5a1e 	vmov	s28, s29, r5, r5
 c00027c:	ec45 5a1f 	vmov	s30, s31, r5, r5
 c000280:	eef1 5a10 	vmrs	r5, fpscr
 c000284:	f64f 7660 	movw	r6, #65376	@ 0xff60
 c000288:	f6c0 76ff 	movt	r6, #4095	@ 0xfff
 c00028c:	4035      	ands	r5, r6
 c00028e:	eee1 5a10 	vmsr	fpscr, r5
 c000292:	f384 8800 	msr	CPSR_f, r4
 c000296:	4625      	mov	r5, r4
 c000298:	4626      	mov	r6, r4
 c00029a:	47a4      	blxns	r4
 c00029c:	ecbd 8b10 	vpop	{d8-d15}
 c0002a0:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0c0002a4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
Reset_Handler:

  ldr   sp, =_estack    /* set stack pointer */
 c0002a4:	f8df d034 	ldr.w	sp, [pc, #52]	@ c0002dc <LoopForever+0x2>
	.type	Reset_Handler, %function

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 c0002a8:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 c0002aa:	e003      	b.n	c0002b4 <LoopCopyDataInit>

0c0002ac <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 c0002ac:	4b0c      	ldr	r3, [pc, #48]	@ (c0002e0 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 c0002ae:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 c0002b0:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 c0002b2:	3104      	adds	r1, #4

0c0002b4 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 c0002b4:	480b      	ldr	r0, [pc, #44]	@ (c0002e4 <LoopForever+0xa>)
	ldr	r3, =_edata
 c0002b6:	4b0c      	ldr	r3, [pc, #48]	@ (c0002e8 <LoopForever+0xe>)
	adds	r2, r0, r1
 c0002b8:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 c0002ba:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 c0002bc:	d3f6      	bcc.n	c0002ac <CopyDataInit>
	ldr	r2, =_sbss
 c0002be:	4a0b      	ldr	r2, [pc, #44]	@ (c0002ec <LoopForever+0x12>)
	b	LoopFillZerobss
 c0002c0:	e002      	b.n	c0002c8 <LoopFillZerobss>

0c0002c2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 c0002c2:	2300      	movs	r3, #0
	str	r3, [r2], #4
 c0002c4:	f842 3b04 	str.w	r3, [r2], #4

0c0002c8 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 c0002c8:	4b09      	ldr	r3, [pc, #36]	@ (c0002f0 <LoopForever+0x16>)
	cmp	r2, r3
 c0002ca:	429a      	cmp	r2, r3
	bcc	FillZerobss
 c0002cc:	d3f9      	bcc.n	c0002c2 <FillZerobss>

/* Call the clock system initialization function.*/
    bl  SystemInit
 c0002ce:	f003 fb6d 	bl	c0039ac <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 c0002d2:	f005 fc51 	bl	c005b78 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 c0002d6:	f000 ffff 	bl	c0012d8 <main>

0c0002da <LoopForever>:

LoopForever:
    b LoopForever
 c0002da:	e7fe      	b.n	c0002da <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 c0002dc:	30018000 	.word	0x30018000
	ldr	r3, =_sidata
 c0002e0:	0c006da8 	.word	0x0c006da8
	ldr	r0, =_sdata
 c0002e4:	30000000 	.word	0x30000000
	ldr	r3, =_edata
 c0002e8:	300000a0 	.word	0x300000a0
	ldr	r2, =_sbss
 c0002ec:	300000a0 	.word	0x300000a0
	ldr	r3, = _ebss
 c0002f0:	30003428 	.word	0x30003428

0c0002f4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 c0002f4:	e7fe      	b.n	c0002f4 <ADC1_2_IRQHandler>
	...

0c0002f8 <KeyExpansion>:
*/
#define getSBoxValue(num) (sbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states.
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
 c0002f8:	b480      	push	{r7}
 c0002fa:	b089      	sub	sp, #36	@ 0x24
 c0002fc:	af00      	add	r7, sp, #0
 c0002fe:	6078      	str	r0, [r7, #4]
 c000300:	6039      	str	r1, [r7, #0]
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations

  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
 c000302:	2300      	movs	r3, #0
 c000304:	61fb      	str	r3, [r7, #28]
 c000306:	e030      	b.n	c00036a <KeyExpansion+0x72>
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
 c000308:	69fb      	ldr	r3, [r7, #28]
 c00030a:	009b      	lsls	r3, r3, #2
 c00030c:	683a      	ldr	r2, [r7, #0]
 c00030e:	441a      	add	r2, r3
 c000310:	69fb      	ldr	r3, [r7, #28]
 c000312:	009b      	lsls	r3, r3, #2
 c000314:	6879      	ldr	r1, [r7, #4]
 c000316:	440b      	add	r3, r1
 c000318:	7812      	ldrb	r2, [r2, #0]
 c00031a:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
 c00031c:	69fb      	ldr	r3, [r7, #28]
 c00031e:	009b      	lsls	r3, r3, #2
 c000320:	3301      	adds	r3, #1
 c000322:	683a      	ldr	r2, [r7, #0]
 c000324:	441a      	add	r2, r3
 c000326:	69fb      	ldr	r3, [r7, #28]
 c000328:	009b      	lsls	r3, r3, #2
 c00032a:	3301      	adds	r3, #1
 c00032c:	6879      	ldr	r1, [r7, #4]
 c00032e:	440b      	add	r3, r1
 c000330:	7812      	ldrb	r2, [r2, #0]
 c000332:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
 c000334:	69fb      	ldr	r3, [r7, #28]
 c000336:	009b      	lsls	r3, r3, #2
 c000338:	3302      	adds	r3, #2
 c00033a:	683a      	ldr	r2, [r7, #0]
 c00033c:	441a      	add	r2, r3
 c00033e:	69fb      	ldr	r3, [r7, #28]
 c000340:	009b      	lsls	r3, r3, #2
 c000342:	3302      	adds	r3, #2
 c000344:	6879      	ldr	r1, [r7, #4]
 c000346:	440b      	add	r3, r1
 c000348:	7812      	ldrb	r2, [r2, #0]
 c00034a:	701a      	strb	r2, [r3, #0]
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
 c00034c:	69fb      	ldr	r3, [r7, #28]
 c00034e:	009b      	lsls	r3, r3, #2
 c000350:	3303      	adds	r3, #3
 c000352:	683a      	ldr	r2, [r7, #0]
 c000354:	441a      	add	r2, r3
 c000356:	69fb      	ldr	r3, [r7, #28]
 c000358:	009b      	lsls	r3, r3, #2
 c00035a:	3303      	adds	r3, #3
 c00035c:	6879      	ldr	r1, [r7, #4]
 c00035e:	440b      	add	r3, r1
 c000360:	7812      	ldrb	r2, [r2, #0]
 c000362:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < Nk; ++i)
 c000364:	69fb      	ldr	r3, [r7, #28]
 c000366:	3301      	adds	r3, #1
 c000368:	61fb      	str	r3, [r7, #28]
 c00036a:	69fb      	ldr	r3, [r7, #28]
 c00036c:	2b03      	cmp	r3, #3
 c00036e:	d9cb      	bls.n	c000308 <KeyExpansion+0x10>
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
 c000370:	2304      	movs	r3, #4
 c000372:	61fb      	str	r3, [r7, #28]
 c000374:	e081      	b.n	c00047a <KeyExpansion+0x182>
  {
    {
      k = (i - 1) * 4;
 c000376:	69fb      	ldr	r3, [r7, #28]
 c000378:	3b01      	subs	r3, #1
 c00037a:	009b      	lsls	r3, r3, #2
 c00037c:	61bb      	str	r3, [r7, #24]
      tempa[0]=RoundKey[k + 0];
 c00037e:	687a      	ldr	r2, [r7, #4]
 c000380:	69bb      	ldr	r3, [r7, #24]
 c000382:	4413      	add	r3, r2
 c000384:	781b      	ldrb	r3, [r3, #0]
 c000386:	733b      	strb	r3, [r7, #12]
      tempa[1]=RoundKey[k + 1];
 c000388:	69bb      	ldr	r3, [r7, #24]
 c00038a:	3301      	adds	r3, #1
 c00038c:	687a      	ldr	r2, [r7, #4]
 c00038e:	4413      	add	r3, r2
 c000390:	781b      	ldrb	r3, [r3, #0]
 c000392:	737b      	strb	r3, [r7, #13]
      tempa[2]=RoundKey[k + 2];
 c000394:	69bb      	ldr	r3, [r7, #24]
 c000396:	3302      	adds	r3, #2
 c000398:	687a      	ldr	r2, [r7, #4]
 c00039a:	4413      	add	r3, r2
 c00039c:	781b      	ldrb	r3, [r3, #0]
 c00039e:	73bb      	strb	r3, [r7, #14]
      tempa[3]=RoundKey[k + 3];
 c0003a0:	69bb      	ldr	r3, [r7, #24]
 c0003a2:	3303      	adds	r3, #3
 c0003a4:	687a      	ldr	r2, [r7, #4]
 c0003a6:	4413      	add	r3, r2
 c0003a8:	781b      	ldrb	r3, [r3, #0]
 c0003aa:	73fb      	strb	r3, [r7, #15]

    }

    if (i % Nk == 0)
 c0003ac:	69fb      	ldr	r3, [r7, #28]
 c0003ae:	f003 0303 	and.w	r3, r3, #3
 c0003b2:	2b00      	cmp	r3, #0
 c0003b4:	d125      	bne.n	c000402 <KeyExpansion+0x10a>
      // This function shifts the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        const uint8_t u8tmp = tempa[0];
 c0003b6:	7b3b      	ldrb	r3, [r7, #12]
 c0003b8:	75fb      	strb	r3, [r7, #23]
        tempa[0] = tempa[1];
 c0003ba:	7b7b      	ldrb	r3, [r7, #13]
 c0003bc:	733b      	strb	r3, [r7, #12]
        tempa[1] = tempa[2];
 c0003be:	7bbb      	ldrb	r3, [r7, #14]
 c0003c0:	737b      	strb	r3, [r7, #13]
        tempa[2] = tempa[3];
 c0003c2:	7bfb      	ldrb	r3, [r7, #15]
 c0003c4:	73bb      	strb	r3, [r7, #14]
        tempa[3] = u8tmp;
 c0003c6:	7dfb      	ldrb	r3, [r7, #23]
 c0003c8:	73fb      	strb	r3, [r7, #15]
      // SubWord() is a function that takes a four-byte input word and
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
 c0003ca:	7b3b      	ldrb	r3, [r7, #12]
 c0003cc:	461a      	mov	r2, r3
 c0003ce:	4b30      	ldr	r3, [pc, #192]	@ (c000490 <KeyExpansion+0x198>)
 c0003d0:	5c9b      	ldrb	r3, [r3, r2]
 c0003d2:	733b      	strb	r3, [r7, #12]
        tempa[1] = getSBoxValue(tempa[1]);
 c0003d4:	7b7b      	ldrb	r3, [r7, #13]
 c0003d6:	461a      	mov	r2, r3
 c0003d8:	4b2d      	ldr	r3, [pc, #180]	@ (c000490 <KeyExpansion+0x198>)
 c0003da:	5c9b      	ldrb	r3, [r3, r2]
 c0003dc:	737b      	strb	r3, [r7, #13]
        tempa[2] = getSBoxValue(tempa[2]);
 c0003de:	7bbb      	ldrb	r3, [r7, #14]
 c0003e0:	461a      	mov	r2, r3
 c0003e2:	4b2b      	ldr	r3, [pc, #172]	@ (c000490 <KeyExpansion+0x198>)
 c0003e4:	5c9b      	ldrb	r3, [r3, r2]
 c0003e6:	73bb      	strb	r3, [r7, #14]
        tempa[3] = getSBoxValue(tempa[3]);
 c0003e8:	7bfb      	ldrb	r3, [r7, #15]
 c0003ea:	461a      	mov	r2, r3
 c0003ec:	4b28      	ldr	r3, [pc, #160]	@ (c000490 <KeyExpansion+0x198>)
 c0003ee:	5c9b      	ldrb	r3, [r3, r2]
 c0003f0:	73fb      	strb	r3, [r7, #15]
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
 c0003f2:	7b3a      	ldrb	r2, [r7, #12]
 c0003f4:	69fb      	ldr	r3, [r7, #28]
 c0003f6:	089b      	lsrs	r3, r3, #2
 c0003f8:	4926      	ldr	r1, [pc, #152]	@ (c000494 <KeyExpansion+0x19c>)
 c0003fa:	5ccb      	ldrb	r3, [r1, r3]
 c0003fc:	4053      	eors	r3, r2
 c0003fe:	b2db      	uxtb	r3, r3
 c000400:	733b      	strb	r3, [r7, #12]
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
 c000402:	69fb      	ldr	r3, [r7, #28]
 c000404:	009b      	lsls	r3, r3, #2
 c000406:	613b      	str	r3, [r7, #16]
 c000408:	69fb      	ldr	r3, [r7, #28]
 c00040a:	3b04      	subs	r3, #4
 c00040c:	009b      	lsls	r3, r3, #2
 c00040e:	61bb      	str	r3, [r7, #24]
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
 c000410:	687a      	ldr	r2, [r7, #4]
 c000412:	69bb      	ldr	r3, [r7, #24]
 c000414:	4413      	add	r3, r2
 c000416:	7819      	ldrb	r1, [r3, #0]
 c000418:	7b3a      	ldrb	r2, [r7, #12]
 c00041a:	6878      	ldr	r0, [r7, #4]
 c00041c:	693b      	ldr	r3, [r7, #16]
 c00041e:	4403      	add	r3, r0
 c000420:	404a      	eors	r2, r1
 c000422:	b2d2      	uxtb	r2, r2
 c000424:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
 c000426:	69bb      	ldr	r3, [r7, #24]
 c000428:	3301      	adds	r3, #1
 c00042a:	687a      	ldr	r2, [r7, #4]
 c00042c:	4413      	add	r3, r2
 c00042e:	7819      	ldrb	r1, [r3, #0]
 c000430:	7b7a      	ldrb	r2, [r7, #13]
 c000432:	693b      	ldr	r3, [r7, #16]
 c000434:	3301      	adds	r3, #1
 c000436:	6878      	ldr	r0, [r7, #4]
 c000438:	4403      	add	r3, r0
 c00043a:	404a      	eors	r2, r1
 c00043c:	b2d2      	uxtb	r2, r2
 c00043e:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
 c000440:	69bb      	ldr	r3, [r7, #24]
 c000442:	3302      	adds	r3, #2
 c000444:	687a      	ldr	r2, [r7, #4]
 c000446:	4413      	add	r3, r2
 c000448:	7819      	ldrb	r1, [r3, #0]
 c00044a:	7bba      	ldrb	r2, [r7, #14]
 c00044c:	693b      	ldr	r3, [r7, #16]
 c00044e:	3302      	adds	r3, #2
 c000450:	6878      	ldr	r0, [r7, #4]
 c000452:	4403      	add	r3, r0
 c000454:	404a      	eors	r2, r1
 c000456:	b2d2      	uxtb	r2, r2
 c000458:	701a      	strb	r2, [r3, #0]
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
 c00045a:	69bb      	ldr	r3, [r7, #24]
 c00045c:	3303      	adds	r3, #3
 c00045e:	687a      	ldr	r2, [r7, #4]
 c000460:	4413      	add	r3, r2
 c000462:	7819      	ldrb	r1, [r3, #0]
 c000464:	7bfa      	ldrb	r2, [r7, #15]
 c000466:	693b      	ldr	r3, [r7, #16]
 c000468:	3303      	adds	r3, #3
 c00046a:	6878      	ldr	r0, [r7, #4]
 c00046c:	4403      	add	r3, r0
 c00046e:	404a      	eors	r2, r1
 c000470:	b2d2      	uxtb	r2, r2
 c000472:	701a      	strb	r2, [r3, #0]
  for (i = Nk; i < Nb * (Nr + 1); ++i)
 c000474:	69fb      	ldr	r3, [r7, #28]
 c000476:	3301      	adds	r3, #1
 c000478:	61fb      	str	r3, [r7, #28]
 c00047a:	69fb      	ldr	r3, [r7, #28]
 c00047c:	2b2b      	cmp	r3, #43	@ 0x2b
 c00047e:	f67f af7a 	bls.w	c000376 <KeyExpansion+0x7e>
  }
}
 c000482:	bf00      	nop
 c000484:	bf00      	nop
 c000486:	3724      	adds	r7, #36	@ 0x24
 c000488:	46bd      	mov	sp, r7
 c00048a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00048e:	4770      	bx	lr
 c000490:	0c006b34 	.word	0x0c006b34
 c000494:	0c006c34 	.word	0x0c006c34

0c000498 <AES_init_ctx_iv>:
{
  KeyExpansion(ctx->RoundKey, key);
}
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
{
 c000498:	b580      	push	{r7, lr}
 c00049a:	b084      	sub	sp, #16
 c00049c:	af00      	add	r7, sp, #0
 c00049e:	60f8      	str	r0, [r7, #12]
 c0004a0:	60b9      	str	r1, [r7, #8]
 c0004a2:	607a      	str	r2, [r7, #4]
  KeyExpansion(ctx->RoundKey, key);
 c0004a4:	68fb      	ldr	r3, [r7, #12]
 c0004a6:	68b9      	ldr	r1, [r7, #8]
 c0004a8:	4618      	mov	r0, r3
 c0004aa:	f7ff ff25 	bl	c0002f8 <KeyExpansion>
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
 c0004ae:	68fb      	ldr	r3, [r7, #12]
 c0004b0:	33b0      	adds	r3, #176	@ 0xb0
 c0004b2:	2210      	movs	r2, #16
 c0004b4:	6879      	ldr	r1, [r7, #4]
 c0004b6:	4618      	mov	r0, r3
 c0004b8:	f005 fb85 	bl	c005bc6 <memcpy>
}
 c0004bc:	bf00      	nop
 c0004be:	3710      	adds	r7, #16
 c0004c0:	46bd      	mov	sp, r7
 c0004c2:	bd80      	pop	{r7, pc}

0c0004c4 <AddRoundKey>:
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)
{
 c0004c4:	b480      	push	{r7}
 c0004c6:	b087      	sub	sp, #28
 c0004c8:	af00      	add	r7, sp, #0
 c0004ca:	4603      	mov	r3, r0
 c0004cc:	60b9      	str	r1, [r7, #8]
 c0004ce:	607a      	str	r2, [r7, #4]
 c0004d0:	73fb      	strb	r3, [r7, #15]
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
 c0004d2:	2300      	movs	r3, #0
 c0004d4:	75fb      	strb	r3, [r7, #23]
 c0004d6:	e027      	b.n	c000528 <AddRoundKey+0x64>
  {
    for (j = 0; j < 4; ++j)
 c0004d8:	2300      	movs	r3, #0
 c0004da:	75bb      	strb	r3, [r7, #22]
 c0004dc:	e01e      	b.n	c00051c <AddRoundKey+0x58>
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
 c0004de:	7dfa      	ldrb	r2, [r7, #23]
 c0004e0:	7dbb      	ldrb	r3, [r7, #22]
 c0004e2:	68b9      	ldr	r1, [r7, #8]
 c0004e4:	0092      	lsls	r2, r2, #2
 c0004e6:	440a      	add	r2, r1
 c0004e8:	4413      	add	r3, r2
 c0004ea:	7818      	ldrb	r0, [r3, #0]
 c0004ec:	7bfb      	ldrb	r3, [r7, #15]
 c0004ee:	009a      	lsls	r2, r3, #2
 c0004f0:	7dfb      	ldrb	r3, [r7, #23]
 c0004f2:	4413      	add	r3, r2
 c0004f4:	009a      	lsls	r2, r3, #2
 c0004f6:	7dbb      	ldrb	r3, [r7, #22]
 c0004f8:	4413      	add	r3, r2
 c0004fa:	461a      	mov	r2, r3
 c0004fc:	687b      	ldr	r3, [r7, #4]
 c0004fe:	4413      	add	r3, r2
 c000500:	7819      	ldrb	r1, [r3, #0]
 c000502:	7dfa      	ldrb	r2, [r7, #23]
 c000504:	7dbb      	ldrb	r3, [r7, #22]
 c000506:	4041      	eors	r1, r0
 c000508:	b2c8      	uxtb	r0, r1
 c00050a:	68b9      	ldr	r1, [r7, #8]
 c00050c:	0092      	lsls	r2, r2, #2
 c00050e:	440a      	add	r2, r1
 c000510:	4413      	add	r3, r2
 c000512:	4602      	mov	r2, r0
 c000514:	701a      	strb	r2, [r3, #0]
    for (j = 0; j < 4; ++j)
 c000516:	7dbb      	ldrb	r3, [r7, #22]
 c000518:	3301      	adds	r3, #1
 c00051a:	75bb      	strb	r3, [r7, #22]
 c00051c:	7dbb      	ldrb	r3, [r7, #22]
 c00051e:	2b03      	cmp	r3, #3
 c000520:	d9dd      	bls.n	c0004de <AddRoundKey+0x1a>
  for (i = 0; i < 4; ++i)
 c000522:	7dfb      	ldrb	r3, [r7, #23]
 c000524:	3301      	adds	r3, #1
 c000526:	75fb      	strb	r3, [r7, #23]
 c000528:	7dfb      	ldrb	r3, [r7, #23]
 c00052a:	2b03      	cmp	r3, #3
 c00052c:	d9d4      	bls.n	c0004d8 <AddRoundKey+0x14>
    }
  }
}
 c00052e:	bf00      	nop
 c000530:	bf00      	nop
 c000532:	371c      	adds	r7, #28
 c000534:	46bd      	mov	sp, r7
 c000536:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00053a:	4770      	bx	lr

0c00053c <SubBytes>:

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
 c00053c:	b480      	push	{r7}
 c00053e:	b085      	sub	sp, #20
 c000540:	af00      	add	r7, sp, #0
 c000542:	6078      	str	r0, [r7, #4]
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
 c000544:	2300      	movs	r3, #0
 c000546:	73fb      	strb	r3, [r7, #15]
 c000548:	e01d      	b.n	c000586 <SubBytes+0x4a>
  {
    for (j = 0; j < 4; ++j)
 c00054a:	2300      	movs	r3, #0
 c00054c:	73bb      	strb	r3, [r7, #14]
 c00054e:	e014      	b.n	c00057a <SubBytes+0x3e>
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
 c000550:	7bba      	ldrb	r2, [r7, #14]
 c000552:	7bfb      	ldrb	r3, [r7, #15]
 c000554:	6879      	ldr	r1, [r7, #4]
 c000556:	0092      	lsls	r2, r2, #2
 c000558:	440a      	add	r2, r1
 c00055a:	4413      	add	r3, r2
 c00055c:	781b      	ldrb	r3, [r3, #0]
 c00055e:	4618      	mov	r0, r3
 c000560:	7bba      	ldrb	r2, [r7, #14]
 c000562:	7bfb      	ldrb	r3, [r7, #15]
 c000564:	490d      	ldr	r1, [pc, #52]	@ (c00059c <SubBytes+0x60>)
 c000566:	5c08      	ldrb	r0, [r1, r0]
 c000568:	6879      	ldr	r1, [r7, #4]
 c00056a:	0092      	lsls	r2, r2, #2
 c00056c:	440a      	add	r2, r1
 c00056e:	4413      	add	r3, r2
 c000570:	4602      	mov	r2, r0
 c000572:	701a      	strb	r2, [r3, #0]
    for (j = 0; j < 4; ++j)
 c000574:	7bbb      	ldrb	r3, [r7, #14]
 c000576:	3301      	adds	r3, #1
 c000578:	73bb      	strb	r3, [r7, #14]
 c00057a:	7bbb      	ldrb	r3, [r7, #14]
 c00057c:	2b03      	cmp	r3, #3
 c00057e:	d9e7      	bls.n	c000550 <SubBytes+0x14>
  for (i = 0; i < 4; ++i)
 c000580:	7bfb      	ldrb	r3, [r7, #15]
 c000582:	3301      	adds	r3, #1
 c000584:	73fb      	strb	r3, [r7, #15]
 c000586:	7bfb      	ldrb	r3, [r7, #15]
 c000588:	2b03      	cmp	r3, #3
 c00058a:	d9de      	bls.n	c00054a <SubBytes+0xe>
    }
  }
}
 c00058c:	bf00      	nop
 c00058e:	bf00      	nop
 c000590:	3714      	adds	r7, #20
 c000592:	46bd      	mov	sp, r7
 c000594:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000598:	4770      	bx	lr
 c00059a:	bf00      	nop
 c00059c:	0c006b34 	.word	0x0c006b34

0c0005a0 <ShiftRows>:

// The ShiftRows() function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
static void ShiftRows(state_t* state)
{
 c0005a0:	b480      	push	{r7}
 c0005a2:	b085      	sub	sp, #20
 c0005a4:	af00      	add	r7, sp, #0
 c0005a6:	6078      	str	r0, [r7, #4]
  uint8_t temp;

  // Rotate first row 1 columns to left
  temp           = (*state)[0][1];
 c0005a8:	687b      	ldr	r3, [r7, #4]
 c0005aa:	785b      	ldrb	r3, [r3, #1]
 c0005ac:	73fb      	strb	r3, [r7, #15]
  (*state)[0][1] = (*state)[1][1];
 c0005ae:	687b      	ldr	r3, [r7, #4]
 c0005b0:	795a      	ldrb	r2, [r3, #5]
 c0005b2:	687b      	ldr	r3, [r7, #4]
 c0005b4:	705a      	strb	r2, [r3, #1]
  (*state)[1][1] = (*state)[2][1];
 c0005b6:	687b      	ldr	r3, [r7, #4]
 c0005b8:	7a5a      	ldrb	r2, [r3, #9]
 c0005ba:	687b      	ldr	r3, [r7, #4]
 c0005bc:	715a      	strb	r2, [r3, #5]
  (*state)[2][1] = (*state)[3][1];
 c0005be:	687b      	ldr	r3, [r7, #4]
 c0005c0:	7b5a      	ldrb	r2, [r3, #13]
 c0005c2:	687b      	ldr	r3, [r7, #4]
 c0005c4:	725a      	strb	r2, [r3, #9]
  (*state)[3][1] = temp;
 c0005c6:	687b      	ldr	r3, [r7, #4]
 c0005c8:	7bfa      	ldrb	r2, [r7, #15]
 c0005ca:	735a      	strb	r2, [r3, #13]

  // Rotate second row 2 columns to left
  temp           = (*state)[0][2];
 c0005cc:	687b      	ldr	r3, [r7, #4]
 c0005ce:	789b      	ldrb	r3, [r3, #2]
 c0005d0:	73fb      	strb	r3, [r7, #15]
  (*state)[0][2] = (*state)[2][2];
 c0005d2:	687b      	ldr	r3, [r7, #4]
 c0005d4:	7a9a      	ldrb	r2, [r3, #10]
 c0005d6:	687b      	ldr	r3, [r7, #4]
 c0005d8:	709a      	strb	r2, [r3, #2]
  (*state)[2][2] = temp;
 c0005da:	687b      	ldr	r3, [r7, #4]
 c0005dc:	7bfa      	ldrb	r2, [r7, #15]
 c0005de:	729a      	strb	r2, [r3, #10]

  temp           = (*state)[1][2];
 c0005e0:	687b      	ldr	r3, [r7, #4]
 c0005e2:	799b      	ldrb	r3, [r3, #6]
 c0005e4:	73fb      	strb	r3, [r7, #15]
  (*state)[1][2] = (*state)[3][2];
 c0005e6:	687b      	ldr	r3, [r7, #4]
 c0005e8:	7b9a      	ldrb	r2, [r3, #14]
 c0005ea:	687b      	ldr	r3, [r7, #4]
 c0005ec:	719a      	strb	r2, [r3, #6]
  (*state)[3][2] = temp;
 c0005ee:	687b      	ldr	r3, [r7, #4]
 c0005f0:	7bfa      	ldrb	r2, [r7, #15]
 c0005f2:	739a      	strb	r2, [r3, #14]

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
 c0005f4:	687b      	ldr	r3, [r7, #4]
 c0005f6:	78db      	ldrb	r3, [r3, #3]
 c0005f8:	73fb      	strb	r3, [r7, #15]
  (*state)[0][3] = (*state)[3][3];
 c0005fa:	687b      	ldr	r3, [r7, #4]
 c0005fc:	7bda      	ldrb	r2, [r3, #15]
 c0005fe:	687b      	ldr	r3, [r7, #4]
 c000600:	70da      	strb	r2, [r3, #3]
  (*state)[3][3] = (*state)[2][3];
 c000602:	687b      	ldr	r3, [r7, #4]
 c000604:	7ada      	ldrb	r2, [r3, #11]
 c000606:	687b      	ldr	r3, [r7, #4]
 c000608:	73da      	strb	r2, [r3, #15]
  (*state)[2][3] = (*state)[1][3];
 c00060a:	687b      	ldr	r3, [r7, #4]
 c00060c:	79da      	ldrb	r2, [r3, #7]
 c00060e:	687b      	ldr	r3, [r7, #4]
 c000610:	72da      	strb	r2, [r3, #11]
  (*state)[1][3] = temp;
 c000612:	687b      	ldr	r3, [r7, #4]
 c000614:	7bfa      	ldrb	r2, [r7, #15]
 c000616:	71da      	strb	r2, [r3, #7]
}
 c000618:	bf00      	nop
 c00061a:	3714      	adds	r7, #20
 c00061c:	46bd      	mov	sp, r7
 c00061e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000622:	4770      	bx	lr

0c000624 <xtime>:

static uint8_t xtime(uint8_t x)
{
 c000624:	b480      	push	{r7}
 c000626:	b083      	sub	sp, #12
 c000628:	af00      	add	r7, sp, #0
 c00062a:	4603      	mov	r3, r0
 c00062c:	71fb      	strb	r3, [r7, #7]
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
 c00062e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c000632:	005b      	lsls	r3, r3, #1
 c000634:	b25a      	sxtb	r2, r3
 c000636:	79fb      	ldrb	r3, [r7, #7]
 c000638:	09db      	lsrs	r3, r3, #7
 c00063a:	b2db      	uxtb	r3, r3
 c00063c:	b25b      	sxtb	r3, r3
 c00063e:	4619      	mov	r1, r3
 c000640:	0049      	lsls	r1, r1, #1
 c000642:	440b      	add	r3, r1
 c000644:	4619      	mov	r1, r3
 c000646:	00c8      	lsls	r0, r1, #3
 c000648:	4619      	mov	r1, r3
 c00064a:	4603      	mov	r3, r0
 c00064c:	440b      	add	r3, r1
 c00064e:	b25b      	sxtb	r3, r3
 c000650:	4053      	eors	r3, r2
 c000652:	b25b      	sxtb	r3, r3
 c000654:	b2db      	uxtb	r3, r3
}
 c000656:	4618      	mov	r0, r3
 c000658:	370c      	adds	r7, #12
 c00065a:	46bd      	mov	sp, r7
 c00065c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000660:	4770      	bx	lr

0c000662 <MixColumns>:

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
 c000662:	b580      	push	{r7, lr}
 c000664:	b084      	sub	sp, #16
 c000666:	af00      	add	r7, sp, #0
 c000668:	6078      	str	r0, [r7, #4]
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
 c00066a:	2300      	movs	r3, #0
 c00066c:	73fb      	strb	r3, [r7, #15]
 c00066e:	e0a4      	b.n	c0007ba <MixColumns+0x158>
  {
    t   = (*state)[i][0];
 c000670:	7bfa      	ldrb	r2, [r7, #15]
 c000672:	687b      	ldr	r3, [r7, #4]
 c000674:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
 c000678:	73bb      	strb	r3, [r7, #14]
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
 c00067a:	7bfa      	ldrb	r2, [r7, #15]
 c00067c:	687b      	ldr	r3, [r7, #4]
 c00067e:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
 c000682:	7bfb      	ldrb	r3, [r7, #15]
 c000684:	6879      	ldr	r1, [r7, #4]
 c000686:	009b      	lsls	r3, r3, #2
 c000688:	440b      	add	r3, r1
 c00068a:	785b      	ldrb	r3, [r3, #1]
 c00068c:	4053      	eors	r3, r2
 c00068e:	b2da      	uxtb	r2, r3
 c000690:	7bfb      	ldrb	r3, [r7, #15]
 c000692:	6879      	ldr	r1, [r7, #4]
 c000694:	009b      	lsls	r3, r3, #2
 c000696:	440b      	add	r3, r1
 c000698:	789b      	ldrb	r3, [r3, #2]
 c00069a:	4053      	eors	r3, r2
 c00069c:	b2da      	uxtb	r2, r3
 c00069e:	7bfb      	ldrb	r3, [r7, #15]
 c0006a0:	6879      	ldr	r1, [r7, #4]
 c0006a2:	009b      	lsls	r3, r3, #2
 c0006a4:	440b      	add	r3, r1
 c0006a6:	78db      	ldrb	r3, [r3, #3]
 c0006a8:	4053      	eors	r3, r2
 c0006aa:	737b      	strb	r3, [r7, #13]
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
 c0006ac:	7bfa      	ldrb	r2, [r7, #15]
 c0006ae:	687b      	ldr	r3, [r7, #4]
 c0006b0:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
 c0006b4:	7bfb      	ldrb	r3, [r7, #15]
 c0006b6:	6879      	ldr	r1, [r7, #4]
 c0006b8:	009b      	lsls	r3, r3, #2
 c0006ba:	440b      	add	r3, r1
 c0006bc:	785b      	ldrb	r3, [r3, #1]
 c0006be:	4053      	eors	r3, r2
 c0006c0:	733b      	strb	r3, [r7, #12]
 c0006c2:	7b3b      	ldrb	r3, [r7, #12]
 c0006c4:	4618      	mov	r0, r3
 c0006c6:	f7ff ffad 	bl	c000624 <xtime>
 c0006ca:	4603      	mov	r3, r0
 c0006cc:	733b      	strb	r3, [r7, #12]
 c0006ce:	7bfa      	ldrb	r2, [r7, #15]
 c0006d0:	687b      	ldr	r3, [r7, #4]
 c0006d2:	f813 1022 	ldrb.w	r1, [r3, r2, lsl #2]
 c0006d6:	7b3a      	ldrb	r2, [r7, #12]
 c0006d8:	7b7b      	ldrb	r3, [r7, #13]
 c0006da:	4053      	eors	r3, r2
 c0006dc:	b2db      	uxtb	r3, r3
 c0006de:	7bfa      	ldrb	r2, [r7, #15]
 c0006e0:	404b      	eors	r3, r1
 c0006e2:	b2d9      	uxtb	r1, r3
 c0006e4:	687b      	ldr	r3, [r7, #4]
 c0006e6:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
 c0006ea:	7bfb      	ldrb	r3, [r7, #15]
 c0006ec:	687a      	ldr	r2, [r7, #4]
 c0006ee:	009b      	lsls	r3, r3, #2
 c0006f0:	4413      	add	r3, r2
 c0006f2:	785a      	ldrb	r2, [r3, #1]
 c0006f4:	7bfb      	ldrb	r3, [r7, #15]
 c0006f6:	6879      	ldr	r1, [r7, #4]
 c0006f8:	009b      	lsls	r3, r3, #2
 c0006fa:	440b      	add	r3, r1
 c0006fc:	789b      	ldrb	r3, [r3, #2]
 c0006fe:	4053      	eors	r3, r2
 c000700:	733b      	strb	r3, [r7, #12]
 c000702:	7b3b      	ldrb	r3, [r7, #12]
 c000704:	4618      	mov	r0, r3
 c000706:	f7ff ff8d 	bl	c000624 <xtime>
 c00070a:	4603      	mov	r3, r0
 c00070c:	733b      	strb	r3, [r7, #12]
 c00070e:	7bfb      	ldrb	r3, [r7, #15]
 c000710:	687a      	ldr	r2, [r7, #4]
 c000712:	009b      	lsls	r3, r3, #2
 c000714:	4413      	add	r3, r2
 c000716:	7859      	ldrb	r1, [r3, #1]
 c000718:	7b3a      	ldrb	r2, [r7, #12]
 c00071a:	7b7b      	ldrb	r3, [r7, #13]
 c00071c:	4053      	eors	r3, r2
 c00071e:	b2da      	uxtb	r2, r3
 c000720:	7bfb      	ldrb	r3, [r7, #15]
 c000722:	404a      	eors	r2, r1
 c000724:	b2d1      	uxtb	r1, r2
 c000726:	687a      	ldr	r2, [r7, #4]
 c000728:	009b      	lsls	r3, r3, #2
 c00072a:	4413      	add	r3, r2
 c00072c:	460a      	mov	r2, r1
 c00072e:	705a      	strb	r2, [r3, #1]
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
 c000730:	7bfb      	ldrb	r3, [r7, #15]
 c000732:	687a      	ldr	r2, [r7, #4]
 c000734:	009b      	lsls	r3, r3, #2
 c000736:	4413      	add	r3, r2
 c000738:	789a      	ldrb	r2, [r3, #2]
 c00073a:	7bfb      	ldrb	r3, [r7, #15]
 c00073c:	6879      	ldr	r1, [r7, #4]
 c00073e:	009b      	lsls	r3, r3, #2
 c000740:	440b      	add	r3, r1
 c000742:	78db      	ldrb	r3, [r3, #3]
 c000744:	4053      	eors	r3, r2
 c000746:	733b      	strb	r3, [r7, #12]
 c000748:	7b3b      	ldrb	r3, [r7, #12]
 c00074a:	4618      	mov	r0, r3
 c00074c:	f7ff ff6a 	bl	c000624 <xtime>
 c000750:	4603      	mov	r3, r0
 c000752:	733b      	strb	r3, [r7, #12]
 c000754:	7bfb      	ldrb	r3, [r7, #15]
 c000756:	687a      	ldr	r2, [r7, #4]
 c000758:	009b      	lsls	r3, r3, #2
 c00075a:	4413      	add	r3, r2
 c00075c:	7899      	ldrb	r1, [r3, #2]
 c00075e:	7b3a      	ldrb	r2, [r7, #12]
 c000760:	7b7b      	ldrb	r3, [r7, #13]
 c000762:	4053      	eors	r3, r2
 c000764:	b2da      	uxtb	r2, r3
 c000766:	7bfb      	ldrb	r3, [r7, #15]
 c000768:	404a      	eors	r2, r1
 c00076a:	b2d1      	uxtb	r1, r2
 c00076c:	687a      	ldr	r2, [r7, #4]
 c00076e:	009b      	lsls	r3, r3, #2
 c000770:	4413      	add	r3, r2
 c000772:	460a      	mov	r2, r1
 c000774:	709a      	strb	r2, [r3, #2]
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
 c000776:	7bfb      	ldrb	r3, [r7, #15]
 c000778:	687a      	ldr	r2, [r7, #4]
 c00077a:	009b      	lsls	r3, r3, #2
 c00077c:	4413      	add	r3, r2
 c00077e:	78da      	ldrb	r2, [r3, #3]
 c000780:	7bbb      	ldrb	r3, [r7, #14]
 c000782:	4053      	eors	r3, r2
 c000784:	733b      	strb	r3, [r7, #12]
 c000786:	7b3b      	ldrb	r3, [r7, #12]
 c000788:	4618      	mov	r0, r3
 c00078a:	f7ff ff4b 	bl	c000624 <xtime>
 c00078e:	4603      	mov	r3, r0
 c000790:	733b      	strb	r3, [r7, #12]
 c000792:	7bfb      	ldrb	r3, [r7, #15]
 c000794:	687a      	ldr	r2, [r7, #4]
 c000796:	009b      	lsls	r3, r3, #2
 c000798:	4413      	add	r3, r2
 c00079a:	78d9      	ldrb	r1, [r3, #3]
 c00079c:	7b3a      	ldrb	r2, [r7, #12]
 c00079e:	7b7b      	ldrb	r3, [r7, #13]
 c0007a0:	4053      	eors	r3, r2
 c0007a2:	b2da      	uxtb	r2, r3
 c0007a4:	7bfb      	ldrb	r3, [r7, #15]
 c0007a6:	404a      	eors	r2, r1
 c0007a8:	b2d1      	uxtb	r1, r2
 c0007aa:	687a      	ldr	r2, [r7, #4]
 c0007ac:	009b      	lsls	r3, r3, #2
 c0007ae:	4413      	add	r3, r2
 c0007b0:	460a      	mov	r2, r1
 c0007b2:	70da      	strb	r2, [r3, #3]
  for (i = 0; i < 4; ++i)
 c0007b4:	7bfb      	ldrb	r3, [r7, #15]
 c0007b6:	3301      	adds	r3, #1
 c0007b8:	73fb      	strb	r3, [r7, #15]
 c0007ba:	7bfb      	ldrb	r3, [r7, #15]
 c0007bc:	2b03      	cmp	r3, #3
 c0007be:	f67f af57 	bls.w	c000670 <MixColumns+0xe>
  }
}
 c0007c2:	bf00      	nop
 c0007c4:	bf00      	nop
 c0007c6:	3710      	adds	r7, #16
 c0007c8:	46bd      	mov	sp, r7
 c0007ca:	bd80      	pop	{r7, pc}

0c0007cc <Cipher>:
}
#endif // #if (defined(CBC) && CBC == 1) || (defined(ECB) && ECB == 1)

// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, const uint8_t* RoundKey)
{
 c0007cc:	b580      	push	{r7, lr}
 c0007ce:	b084      	sub	sp, #16
 c0007d0:	af00      	add	r7, sp, #0
 c0007d2:	6078      	str	r0, [r7, #4]
 c0007d4:	6039      	str	r1, [r7, #0]
  uint8_t round = 0;
 c0007d6:	2300      	movs	r3, #0
 c0007d8:	73fb      	strb	r3, [r7, #15]

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey);
 c0007da:	683a      	ldr	r2, [r7, #0]
 c0007dc:	6879      	ldr	r1, [r7, #4]
 c0007de:	2000      	movs	r0, #0
 c0007e0:	f7ff fe70 	bl	c0004c4 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr rounds are executed in the loop below.
  // Last one without MixColumns()
  for (round = 1; ; ++round)
 c0007e4:	2301      	movs	r3, #1
 c0007e6:	73fb      	strb	r3, [r7, #15]
  {
    SubBytes(state);
 c0007e8:	6878      	ldr	r0, [r7, #4]
 c0007ea:	f7ff fea7 	bl	c00053c <SubBytes>
    ShiftRows(state);
 c0007ee:	6878      	ldr	r0, [r7, #4]
 c0007f0:	f7ff fed6 	bl	c0005a0 <ShiftRows>
    if (round == Nr) {
 c0007f4:	7bfb      	ldrb	r3, [r7, #15]
 c0007f6:	2b0a      	cmp	r3, #10
 c0007f8:	d00c      	beq.n	c000814 <Cipher+0x48>
      break;
    }
    MixColumns(state);
 c0007fa:	6878      	ldr	r0, [r7, #4]
 c0007fc:	f7ff ff31 	bl	c000662 <MixColumns>
    AddRoundKey(round, state, RoundKey);
 c000800:	7bfb      	ldrb	r3, [r7, #15]
 c000802:	683a      	ldr	r2, [r7, #0]
 c000804:	6879      	ldr	r1, [r7, #4]
 c000806:	4618      	mov	r0, r3
 c000808:	f7ff fe5c 	bl	c0004c4 <AddRoundKey>
  for (round = 1; ; ++round)
 c00080c:	7bfb      	ldrb	r3, [r7, #15]
 c00080e:	3301      	adds	r3, #1
 c000810:	73fb      	strb	r3, [r7, #15]
    SubBytes(state);
 c000812:	e7e9      	b.n	c0007e8 <Cipher+0x1c>
      break;
 c000814:	bf00      	nop
  }
  // Add round key to last round
  AddRoundKey(Nr, state, RoundKey);
 c000816:	683a      	ldr	r2, [r7, #0]
 c000818:	6879      	ldr	r1, [r7, #4]
 c00081a:	200a      	movs	r0, #10
 c00081c:	f7ff fe52 	bl	c0004c4 <AddRoundKey>
}
 c000820:	bf00      	nop
 c000822:	3710      	adds	r7, #16
 c000824:	46bd      	mov	sp, r7
 c000826:	bd80      	pop	{r7, pc}

0c000828 <AES_CTR_xcrypt_buffer>:

#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, size_t length)
{
 c000828:	b590      	push	{r4, r7, lr}
 c00082a:	b08b      	sub	sp, #44	@ 0x2c
 c00082c:	af00      	add	r7, sp, #0
 c00082e:	60f8      	str	r0, [r7, #12]
 c000830:	60b9      	str	r1, [r7, #8]
 c000832:	607a      	str	r2, [r7, #4]
  uint8_t buffer[AES_BLOCKLEN];

  size_t i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
 c000834:	2300      	movs	r3, #0
 c000836:	627b      	str	r3, [r7, #36]	@ 0x24
 c000838:	2310      	movs	r3, #16
 c00083a:	623b      	str	r3, [r7, #32]
 c00083c:	e04e      	b.n	c0008dc <AES_CTR_xcrypt_buffer+0xb4>
  {
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
 c00083e:	6a3b      	ldr	r3, [r7, #32]
 c000840:	2b10      	cmp	r3, #16
 c000842:	d136      	bne.n	c0008b2 <AES_CTR_xcrypt_buffer+0x8a>
    {

      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
 c000844:	68fb      	ldr	r3, [r7, #12]
 c000846:	33b0      	adds	r3, #176	@ 0xb0
 c000848:	f107 0410 	add.w	r4, r7, #16
 c00084c:	6818      	ldr	r0, [r3, #0]
 c00084e:	6859      	ldr	r1, [r3, #4]
 c000850:	689a      	ldr	r2, [r3, #8]
 c000852:	68db      	ldr	r3, [r3, #12]
 c000854:	c40f      	stmia	r4!, {r0, r1, r2, r3}
      Cipher((state_t*)buffer,ctx->RoundKey);
 c000856:	68fa      	ldr	r2, [r7, #12]
 c000858:	f107 0310 	add.w	r3, r7, #16
 c00085c:	4611      	mov	r1, r2
 c00085e:	4618      	mov	r0, r3
 c000860:	f7ff ffb4 	bl	c0007cc <Cipher>

      /* Increment Iv and handle overflow */
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
 c000864:	230f      	movs	r3, #15
 c000866:	623b      	str	r3, [r7, #32]
 c000868:	e01e      	b.n	c0008a8 <AES_CTR_xcrypt_buffer+0x80>
      {
	/* inc will overflow */
        if (ctx->Iv[bi] == 255)
 c00086a:	68fa      	ldr	r2, [r7, #12]
 c00086c:	6a3b      	ldr	r3, [r7, #32]
 c00086e:	4413      	add	r3, r2
 c000870:	33b0      	adds	r3, #176	@ 0xb0
 c000872:	781b      	ldrb	r3, [r3, #0]
 c000874:	2bff      	cmp	r3, #255	@ 0xff
 c000876:	d106      	bne.n	c000886 <AES_CTR_xcrypt_buffer+0x5e>
	{
          ctx->Iv[bi] = 0;
 c000878:	68fa      	ldr	r2, [r7, #12]
 c00087a:	6a3b      	ldr	r3, [r7, #32]
 c00087c:	4413      	add	r3, r2
 c00087e:	33b0      	adds	r3, #176	@ 0xb0
 c000880:	2200      	movs	r2, #0
 c000882:	701a      	strb	r2, [r3, #0]
          continue;
 c000884:	e00d      	b.n	c0008a2 <AES_CTR_xcrypt_buffer+0x7a>
        }
        ctx->Iv[bi] += 1;
 c000886:	68fa      	ldr	r2, [r7, #12]
 c000888:	6a3b      	ldr	r3, [r7, #32]
 c00088a:	4413      	add	r3, r2
 c00088c:	33b0      	adds	r3, #176	@ 0xb0
 c00088e:	781b      	ldrb	r3, [r3, #0]
 c000890:	3301      	adds	r3, #1
 c000892:	b2d9      	uxtb	r1, r3
 c000894:	68fa      	ldr	r2, [r7, #12]
 c000896:	6a3b      	ldr	r3, [r7, #32]
 c000898:	4413      	add	r3, r2
 c00089a:	33b0      	adds	r3, #176	@ 0xb0
 c00089c:	460a      	mov	r2, r1
 c00089e:	701a      	strb	r2, [r3, #0]
        break;
 c0008a0:	e005      	b.n	c0008ae <AES_CTR_xcrypt_buffer+0x86>
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
 c0008a2:	6a3b      	ldr	r3, [r7, #32]
 c0008a4:	3b01      	subs	r3, #1
 c0008a6:	623b      	str	r3, [r7, #32]
 c0008a8:	6a3b      	ldr	r3, [r7, #32]
 c0008aa:	2b00      	cmp	r3, #0
 c0008ac:	dadd      	bge.n	c00086a <AES_CTR_xcrypt_buffer+0x42>
      }
      bi = 0;
 c0008ae:	2300      	movs	r3, #0
 c0008b0:	623b      	str	r3, [r7, #32]
    }

    buf[i] = (buf[i] ^ buffer[bi]);
 c0008b2:	68ba      	ldr	r2, [r7, #8]
 c0008b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008b6:	4413      	add	r3, r2
 c0008b8:	7819      	ldrb	r1, [r3, #0]
 c0008ba:	f107 0210 	add.w	r2, r7, #16
 c0008be:	6a3b      	ldr	r3, [r7, #32]
 c0008c0:	4413      	add	r3, r2
 c0008c2:	781a      	ldrb	r2, [r3, #0]
 c0008c4:	68b8      	ldr	r0, [r7, #8]
 c0008c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008c8:	4403      	add	r3, r0
 c0008ca:	404a      	eors	r2, r1
 c0008cc:	b2d2      	uxtb	r2, r2
 c0008ce:	701a      	strb	r2, [r3, #0]
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
 c0008d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 c0008d2:	3301      	adds	r3, #1
 c0008d4:	627b      	str	r3, [r7, #36]	@ 0x24
 c0008d6:	6a3b      	ldr	r3, [r7, #32]
 c0008d8:	3301      	adds	r3, #1
 c0008da:	623b      	str	r3, [r7, #32]
 c0008dc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 c0008de:	687b      	ldr	r3, [r7, #4]
 c0008e0:	429a      	cmp	r2, r3
 c0008e2:	d3ac      	bcc.n	c00083e <AES_CTR_xcrypt_buffer+0x16>
  }
}
 c0008e4:	bf00      	nop
 c0008e6:	bf00      	nop
 c0008e8:	372c      	adds	r7, #44	@ 0x2c
 c0008ea:	46bd      	mov	sp, r7
 c0008ec:	bd90      	pop	{r4, r7, pc}
	...

0c0008f0 <sha256_initialize>:
    uint32_t	buffer[16];	// Changed by RKW, unsigned long becomes uint32_t
    uint32_t	state[8];	// Changed by RKW, unsinged long becomes uint32_t
    uint8_t		length[8];	// Changed by RKW, unsigned char becomes uint8_t
} sha256;

void sha256_initialize(sha256 *sha) {
 c0008f0:	b480      	push	{r7}
 c0008f2:	b085      	sub	sp, #20
 c0008f4:	af00      	add	r7, sp, #0
 c0008f6:	6078      	str	r0, [r7, #4]
    int i;
    for (i = 0; i < 17; ++i) sha->buffer[i] = 0;
 c0008f8:	2300      	movs	r3, #0
 c0008fa:	60fb      	str	r3, [r7, #12]
 c0008fc:	e008      	b.n	c000910 <sha256_initialize+0x20>
 c0008fe:	687b      	ldr	r3, [r7, #4]
 c000900:	68fa      	ldr	r2, [r7, #12]
 c000902:	3208      	adds	r2, #8
 c000904:	2100      	movs	r1, #0
 c000906:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 c00090a:	68fb      	ldr	r3, [r7, #12]
 c00090c:	3301      	adds	r3, #1
 c00090e:	60fb      	str	r3, [r7, #12]
 c000910:	68fb      	ldr	r3, [r7, #12]
 c000912:	2b10      	cmp	r3, #16
 c000914:	ddf3      	ble.n	c0008fe <sha256_initialize+0xe>
    sha->state[0] = 0x6a09e667;
 c000916:	687b      	ldr	r3, [r7, #4]
 c000918:	4a16      	ldr	r2, [pc, #88]	@ (c000974 <sha256_initialize+0x84>)
 c00091a:	661a      	str	r2, [r3, #96]	@ 0x60
    sha->state[1] = 0xbb67ae85;
 c00091c:	687b      	ldr	r3, [r7, #4]
 c00091e:	4a16      	ldr	r2, [pc, #88]	@ (c000978 <sha256_initialize+0x88>)
 c000920:	665a      	str	r2, [r3, #100]	@ 0x64
    sha->state[2] = 0x3c6ef372;
 c000922:	687b      	ldr	r3, [r7, #4]
 c000924:	4a15      	ldr	r2, [pc, #84]	@ (c00097c <sha256_initialize+0x8c>)
 c000926:	669a      	str	r2, [r3, #104]	@ 0x68
    sha->state[3] = 0xa54ff53a;
 c000928:	687b      	ldr	r3, [r7, #4]
 c00092a:	4a15      	ldr	r2, [pc, #84]	@ (c000980 <sha256_initialize+0x90>)
 c00092c:	66da      	str	r2, [r3, #108]	@ 0x6c
    sha->state[4] = 0x510e527f;
 c00092e:	687b      	ldr	r3, [r7, #4]
 c000930:	4a14      	ldr	r2, [pc, #80]	@ (c000984 <sha256_initialize+0x94>)
 c000932:	671a      	str	r2, [r3, #112]	@ 0x70
    sha->state[5] = 0x9b05688c;
 c000934:	687b      	ldr	r3, [r7, #4]
 c000936:	4a14      	ldr	r2, [pc, #80]	@ (c000988 <sha256_initialize+0x98>)
 c000938:	675a      	str	r2, [r3, #116]	@ 0x74
    sha->state[6] = 0x1f83d9ab;
 c00093a:	687b      	ldr	r3, [r7, #4]
 c00093c:	4a13      	ldr	r2, [pc, #76]	@ (c00098c <sha256_initialize+0x9c>)
 c00093e:	679a      	str	r2, [r3, #120]	@ 0x78
    sha->state[7] = 0x5be0cd19;
 c000940:	687b      	ldr	r3, [r7, #4]
 c000942:	4a13      	ldr	r2, [pc, #76]	@ (c000990 <sha256_initialize+0xa0>)
 c000944:	67da      	str	r2, [r3, #124]	@ 0x7c
    for (i = 0; i < 8; ++i) sha->length[i] = 0;
 c000946:	2300      	movs	r3, #0
 c000948:	60fb      	str	r3, [r7, #12]
 c00094a:	e008      	b.n	c00095e <sha256_initialize+0x6e>
 c00094c:	687a      	ldr	r2, [r7, #4]
 c00094e:	68fb      	ldr	r3, [r7, #12]
 c000950:	4413      	add	r3, r2
 c000952:	3380      	adds	r3, #128	@ 0x80
 c000954:	2200      	movs	r2, #0
 c000956:	701a      	strb	r2, [r3, #0]
 c000958:	68fb      	ldr	r3, [r7, #12]
 c00095a:	3301      	adds	r3, #1
 c00095c:	60fb      	str	r3, [r7, #12]
 c00095e:	68fb      	ldr	r3, [r7, #12]
 c000960:	2b07      	cmp	r3, #7
 c000962:	ddf3      	ble.n	c00094c <sha256_initialize+0x5c>
}
 c000964:	bf00      	nop
 c000966:	bf00      	nop
 c000968:	3714      	adds	r7, #20
 c00096a:	46bd      	mov	sp, r7
 c00096c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c000970:	4770      	bx	lr
 c000972:	bf00      	nop
 c000974:	6a09e667 	.word	0x6a09e667
 c000978:	bb67ae85 	.word	0xbb67ae85
 c00097c:	3c6ef372 	.word	0x3c6ef372
 c000980:	a54ff53a 	.word	0xa54ff53a
 c000984:	510e527f 	.word	0x510e527f
 c000988:	9b05688c 	.word	0x9b05688c
 c00098c:	1f83d9ab 	.word	0x1f83d9ab
 c000990:	5be0cd19 	.word	0x5be0cd19

0c000994 <sha256_update>:

//  Changed by RKW, formal args are now const uint8_t, uint_32
//    from const unsigned char, unsigned long respectively
void sha256_update(sha256 *sha,
                   const uint8_t *message,
                   uint32_t length) {
 c000994:	b590      	push	{r4, r7, lr}
 c000996:	f5ad 7d19 	sub.w	sp, sp, #612	@ 0x264
 c00099a:	af00      	add	r7, sp, #0
 c00099c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009a0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c0009a4:	6018      	str	r0, [r3, #0]
 c0009a6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009aa:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c0009ae:	6019      	str	r1, [r3, #0]
 c0009b0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009b4:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c0009b8:	601a      	str	r2, [r3, #0]
    int i, j;
    /* Add the length of the received message, counted in
     * bytes, to the total length of the messages hashed to
     * date, counted in bits and stored in 8 separate bytes. */
    for (i = 7; i >= 0; --i) {
 c0009ba:	2307      	movs	r3, #7
 c0009bc:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
 c0009c0:	e086      	b.n	c000ad0 <sha256_update+0x13c>
        int bits;
		if (i == 7)
 c0009c2:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009c6:	2b07      	cmp	r3, #7
 c0009c8:	d108      	bne.n	c0009dc <sha256_update+0x48>
			bits = length << 3;
 c0009ca:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c0009ce:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c0009d2:	681b      	ldr	r3, [r3, #0]
 c0009d4:	00db      	lsls	r3, r3, #3
 c0009d6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 c0009da:	e01d      	b.n	c000a18 <sha256_update+0x84>
		else if (i == 0 || i == 1 || i == 2)
 c0009dc:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009e0:	2b00      	cmp	r3, #0
 c0009e2:	d007      	beq.n	c0009f4 <sha256_update+0x60>
 c0009e4:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009e8:	2b01      	cmp	r3, #1
 c0009ea:	d003      	beq.n	c0009f4 <sha256_update+0x60>
 c0009ec:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c0009f0:	2b02      	cmp	r3, #2
 c0009f2:	d103      	bne.n	c0009fc <sha256_update+0x68>
			bits = 0;
 c0009f4:	2300      	movs	r3, #0
 c0009f6:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
 c0009fa:	e00d      	b.n	c000a18 <sha256_update+0x84>
		else
			bits = length >> (53 - 8 * i);
 c0009fc:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a00:	00db      	lsls	r3, r3, #3
 c000a02:	f1c3 0335 	rsb	r3, r3, #53	@ 0x35
 c000a06:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000a0a:	f5a2 7217 	sub.w	r2, r2, #604	@ 0x25c
 c000a0e:	6812      	ldr	r2, [r2, #0]
 c000a10:	fa22 f303 	lsr.w	r3, r2, r3
 c000a14:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
		bits &= 0xff;
 c000a18:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000a1c:	b2db      	uxtb	r3, r3
 c000a1e:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254
        if (sha->length[i] + bits > 0xff) {
 c000a22:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a26:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a2a:	681a      	ldr	r2, [r3, #0]
 c000a2c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a30:	4413      	add	r3, r2
 c000a32:	3380      	adds	r3, #128	@ 0x80
 c000a34:	781b      	ldrb	r3, [r3, #0]
 c000a36:	461a      	mov	r2, r3
 c000a38:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000a3c:	4413      	add	r3, r2
 c000a3e:	2bff      	cmp	r3, #255	@ 0xff
 c000a40:	dd27      	ble.n	c000a92 <sha256_update+0xfe>
            for (j = i - 1; j >= 0 && sha->length[j]++ == 0xff; --j);
 c000a42:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000a46:	3b01      	subs	r3, #1
 c000a48:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
 c000a4c:	e004      	b.n	c000a58 <sha256_update+0xc4>
 c000a4e:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a52:	3b01      	subs	r3, #1
 c000a54:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
 c000a58:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a5c:	2b00      	cmp	r3, #0
 c000a5e:	db18      	blt.n	c000a92 <sha256_update+0xfe>
 c000a60:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a64:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a68:	681a      	ldr	r2, [r3, #0]
 c000a6a:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 c000a6e:	4413      	add	r3, r2
 c000a70:	3380      	adds	r3, #128	@ 0x80
 c000a72:	781b      	ldrb	r3, [r3, #0]
 c000a74:	1c5a      	adds	r2, r3, #1
 c000a76:	b2d0      	uxtb	r0, r2
 c000a78:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000a7c:	f5a2 7215 	sub.w	r2, r2, #596	@ 0x254
 c000a80:	6811      	ldr	r1, [r2, #0]
 c000a82:	f8d7 2258 	ldr.w	r2, [r7, #600]	@ 0x258
 c000a86:	440a      	add	r2, r1
 c000a88:	3280      	adds	r2, #128	@ 0x80
 c000a8a:	4601      	mov	r1, r0
 c000a8c:	7011      	strb	r1, [r2, #0]
 c000a8e:	2bff      	cmp	r3, #255	@ 0xff
 c000a90:	d0dd      	beq.n	c000a4e <sha256_update+0xba>
        }
        sha->length[i] += bits;
 c000a92:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000a96:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000a9a:	681a      	ldr	r2, [r3, #0]
 c000a9c:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000aa0:	4413      	add	r3, r2
 c000aa2:	3380      	adds	r3, #128	@ 0x80
 c000aa4:	781a      	ldrb	r2, [r3, #0]
 c000aa6:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 c000aaa:	b2db      	uxtb	r3, r3
 c000aac:	4413      	add	r3, r2
 c000aae:	b2d9      	uxtb	r1, r3
 c000ab0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ab4:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ab8:	681a      	ldr	r2, [r3, #0]
 c000aba:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000abe:	4413      	add	r3, r2
 c000ac0:	3380      	adds	r3, #128	@ 0x80
 c000ac2:	460a      	mov	r2, r1
 c000ac4:	701a      	strb	r2, [r3, #0]
    for (i = 7; i >= 0; --i) {
 c000ac6:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000aca:	3b01      	subs	r3, #1
 c000acc:	f8c7 325c 	str.w	r3, [r7, #604]	@ 0x25c
 c000ad0:	f8d7 325c 	ldr.w	r3, [r7, #604]	@ 0x25c
 c000ad4:	2b00      	cmp	r3, #0
 c000ad6:	f6bf af74 	bge.w	c0009c2 <sha256_update+0x2e>
    }
    /* Add the received message to the SHA buffer, updating the
     * hash at each block (each time the buffer is filled). */
    while (length > 0) {
 c000ada:	e294      	b.n	c001006 <sha256_update+0x672>
        /* Find the index in the SHA buffer at which to
         * append what's left of the received message. */
        int index = sha->length[6] % 2 * 32 + sha->length[7] / 8;
 c000adc:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ae0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ae4:	681b      	ldr	r3, [r3, #0]
 c000ae6:	f893 3086 	ldrb.w	r3, [r3, #134]	@ 0x86
 c000aea:	f003 0301 	and.w	r3, r3, #1
 c000aee:	015b      	lsls	r3, r3, #5
 c000af0:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000af4:	f5a2 7215 	sub.w	r2, r2, #596	@ 0x254
 c000af8:	6812      	ldr	r2, [r2, #0]
 c000afa:	f892 2087 	ldrb.w	r2, [r2, #135]	@ 0x87
 c000afe:	08d2      	lsrs	r2, r2, #3
 c000b00:	b2d2      	uxtb	r2, r2
 c000b02:	4413      	add	r3, r2
 c000b04:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
        index = (index + 64 - length % 64) % 64;
 c000b08:	f8d7 2250 	ldr.w	r2, [r7, #592]	@ 0x250
 c000b0c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b10:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000b14:	681b      	ldr	r3, [r3, #0]
 c000b16:	1ad3      	subs	r3, r2, r3
 c000b18:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 c000b1c:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
        /* Append the received message bytes to the SHA buffer until
         * we run out of message bytes or until the buffer is filled. */
        for (;length > 0 && index < 64; ++message, ++index, --length) {
 c000b20:	e048      	b.n	c000bb4 <sha256_update+0x220>
            sha->buffer[index / 4] |= *message << (24 - index % 4 * 8);
 c000b22:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b26:	2b00      	cmp	r3, #0
 c000b28:	da00      	bge.n	c000b2c <sha256_update+0x198>
 c000b2a:	3303      	adds	r3, #3
 c000b2c:	109b      	asrs	r3, r3, #2
 c000b2e:	461a      	mov	r2, r3
 c000b30:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b34:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000b38:	681b      	ldr	r3, [r3, #0]
 c000b3a:	f102 0108 	add.w	r1, r2, #8
 c000b3e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 c000b42:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b46:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c000b4a:	681b      	ldr	r3, [r3, #0]
 c000b4c:	781b      	ldrb	r3, [r3, #0]
 c000b4e:	461c      	mov	r4, r3
 c000b50:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b54:	4258      	negs	r0, r3
 c000b56:	f003 0303 	and.w	r3, r3, #3
 c000b5a:	f000 0003 	and.w	r0, r0, #3
 c000b5e:	bf58      	it	pl
 c000b60:	4243      	negpl	r3, r0
 c000b62:	f1c3 0303 	rsb	r3, r3, #3
 c000b66:	00db      	lsls	r3, r3, #3
 c000b68:	fa04 f303 	lsl.w	r3, r4, r3
 c000b6c:	4319      	orrs	r1, r3
 c000b6e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b72:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000b76:	681b      	ldr	r3, [r3, #0]
 c000b78:	3208      	adds	r2, #8
 c000b7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (;length > 0 && index < 64; ++message, ++index, --length) {
 c000b7e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000b82:	f5a3 7316 	sub.w	r3, r3, #600	@ 0x258
 c000b86:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000b8a:	f5a2 7216 	sub.w	r2, r2, #600	@ 0x258
 c000b8e:	6812      	ldr	r2, [r2, #0]
 c000b90:	3201      	adds	r2, #1
 c000b92:	601a      	str	r2, [r3, #0]
 c000b94:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000b98:	3301      	adds	r3, #1
 c000b9a:	f8c7 3250 	str.w	r3, [r7, #592]	@ 0x250
 c000b9e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ba2:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000ba6:	f507 7218 	add.w	r2, r7, #608	@ 0x260
 c000baa:	f5a2 7217 	sub.w	r2, r2, #604	@ 0x25c
 c000bae:	6812      	ldr	r2, [r2, #0]
 c000bb0:	3a01      	subs	r2, #1
 c000bb2:	601a      	str	r2, [r3, #0]
 c000bb4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bb8:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c000bbc:	681b      	ldr	r3, [r3, #0]
 c000bbe:	2b00      	cmp	r3, #0
 c000bc0:	d003      	beq.n	c000bca <sha256_update+0x236>
 c000bc2:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000bc6:	2b3f      	cmp	r3, #63	@ 0x3f
 c000bc8:	ddab      	ble.n	c000b22 <sha256_update+0x18e>
        }
        /* Update the hash with the buffer contents if the buffer is full. */
        if (index == 64) {
 c000bca:	f8d7 3250 	ldr.w	r3, [r7, #592]	@ 0x250
 c000bce:	2b40      	cmp	r3, #64	@ 0x40
 c000bd0:	f040 8219 	bne.w	c001006 <sha256_update+0x672>
            /* Update the hash with a block of message content. See FIPS 180-2
             * (<csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf>)
             * for a description of and details on the algorithm used here. */
			// Changed by RKW, const unsigned long becomes const uint32_t
            const uint32_t k[64] = {
 c000bd4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bd8:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 c000bdc:	4a80      	ldr	r2, [pc, #512]	@ (c000de0 <sha256_update+0x44c>)
 c000bde:	4618      	mov	r0, r3
 c000be0:	4611      	mov	r1, r2
 c000be2:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c000be6:	461a      	mov	r2, r3
 c000be8:	f004 ffed 	bl	c005bc6 <memcpy>
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            };
			// Changed by RKW, unsigned long becomes uint32_t
            uint32_t w[64], a, b, c, d, e, f, g, h;
            int t;
            for (t = 0; t < 16; ++t) {
 c000bec:	2300      	movs	r3, #0
 c000bee:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000bf2:	e021      	b.n	c000c38 <sha256_update+0x2a4>
                w[t] = sha->buffer[t];
 c000bf4:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000bf8:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000bfc:	681b      	ldr	r3, [r3, #0]
 c000bfe:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c02:	3208      	adds	r2, #8
 c000c04:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c000c08:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c0c:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c10:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c14:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                sha->buffer[t] = 0;
 c000c18:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c1c:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000c20:	681b      	ldr	r3, [r3, #0]
 c000c22:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000c26:	3208      	adds	r2, #8
 c000c28:	2100      	movs	r1, #0
 c000c2a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            for (t = 0; t < 16; ++t) {
 c000c2e:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c32:	3301      	adds	r3, #1
 c000c34:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000c38:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c3c:	2b0f      	cmp	r3, #15
 c000c3e:	ddd9      	ble.n	c000bf4 <sha256_update+0x260>
            }
            for (t = 16; t < 64; ++t) {
 c000c40:	2310      	movs	r3, #16
 c000c42:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000c46:	e081      	b.n	c000d4c <sha256_update+0x3b8>
				// Changed by RKW, unsigned long becomes uint32_t
                uint32_t s0, s1;
                s0 = (w[t - 15] >> 7 | w[t - 15] << 25);
 c000c48:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c4c:	f1a3 020f 	sub.w	r2, r3, #15
 c000c50:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c54:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c5c:	ea4f 13f3 	mov.w	r3, r3, ror #7
 c000c60:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s0 ^= (w[t - 15] >> 18 | w[t - 15] << 14);
 c000c64:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c68:	f1a3 020f 	sub.w	r2, r3, #15
 c000c6c:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c70:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c78:	ea4f 43b3 	mov.w	r3, r3, ror #18
 c000c7c:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 c000c80:	4053      	eors	r3, r2
 c000c82:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s0 ^= (w[t - 15] >> 3);
 c000c86:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000c8a:	f1a3 020f 	sub.w	r2, r3, #15
 c000c8e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000c92:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000c96:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000c9a:	08db      	lsrs	r3, r3, #3
 c000c9c:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 c000ca0:	4053      	eors	r3, r2
 c000ca2:	f8c7 3218 	str.w	r3, [r7, #536]	@ 0x218
                s1 = (w[t - 2] >> 17 | w[t - 2] << 15);
 c000ca6:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000caa:	1e9a      	subs	r2, r3, #2
 c000cac:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cb0:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cb8:	ea4f 4373 	mov.w	r3, r3, ror #17
 c000cbc:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                s1 ^= (w[t - 2] >> 19 | w[t - 2] << 13);
 c000cc0:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000cc4:	1e9a      	subs	r2, r3, #2
 c000cc6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cca:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cd2:	ea4f 43f3 	mov.w	r3, r3, ror #19
 c000cd6:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 c000cda:	4053      	eors	r3, r2
 c000cdc:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                s1 ^= (w[t - 2] >> 10);
 c000ce0:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000ce4:	1e9a      	subs	r2, r3, #2
 c000ce6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000cea:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000cee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c000cf2:	0a9b      	lsrs	r3, r3, #10
 c000cf4:	f8d7 2214 	ldr.w	r2, [r7, #532]	@ 0x214
 c000cf8:	4053      	eors	r3, r2
 c000cfa:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
                w[t] = (s1 + w[t - 7] + s0 + w[t - 16]) & 0xffffffffU;
 c000cfe:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d02:	1fda      	subs	r2, r3, #7
 c000d04:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d08:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d0c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c000d10:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 c000d14:	441a      	add	r2, r3
 c000d16:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 c000d1a:	441a      	add	r2, r3
 c000d1c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d20:	f1a3 0110 	sub.w	r1, r3, #16
 c000d24:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d28:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d2c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000d30:	18d1      	adds	r1, r2, r3
 c000d32:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d36:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000d3a:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 c000d3e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            for (t = 16; t < 64; ++t) {
 c000d42:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d46:	3301      	adds	r3, #1
 c000d48:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000d4c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000d50:	2b3f      	cmp	r3, #63	@ 0x3f
 c000d52:	f77f af79 	ble.w	c000c48 <sha256_update+0x2b4>
            }
            a = sha->state[0];
 c000d56:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d5a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d5e:	681b      	ldr	r3, [r3, #0]
 c000d60:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c000d62:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
            b = sha->state[1];
 c000d66:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d6a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d6e:	681b      	ldr	r3, [r3, #0]
 c000d70:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 c000d72:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
            c = sha->state[2];
 c000d76:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d7a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d7e:	681b      	ldr	r3, [r3, #0]
 c000d80:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 c000d82:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
            d = sha->state[3];
 c000d86:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d8a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d8e:	681b      	ldr	r3, [r3, #0]
 c000d90:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 c000d92:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
            e = sha->state[4];
 c000d96:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000d9a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000d9e:	681b      	ldr	r3, [r3, #0]
 c000da0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 c000da2:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
            f = sha->state[5];
 c000da6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000daa:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dae:	681b      	ldr	r3, [r3, #0]
 c000db0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 c000db2:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
            g = sha->state[6];
 c000db6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000dba:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dbe:	681b      	ldr	r3, [r3, #0]
 c000dc0:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 c000dc2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
            h = sha->state[7];
 c000dc6:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000dca:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000dce:	681b      	ldr	r3, [r3, #0]
 c000dd0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 c000dd2:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
            for (t = 0; t < 64; ++t) {
 c000dd6:	2300      	movs	r3, #0
 c000dd8:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000ddc:	e096      	b.n	c000f0c <sha256_update+0x578>
 c000dde:	bf00      	nop
 c000de0:	0c0065a8 	.word	0x0c0065a8
				// Changed by RKW, unsigned long becomes uint32_t
                uint32_t e0, e1, t1, t2;
                e0 = (a >> 2 | a << 30);
 c000de4:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000de8:	ea4f 03b3 	mov.w	r3, r3, ror #2
 c000dec:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e0 ^= (a >> 13 | a << 19);
 c000df0:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000df4:	ea4f 3373 	mov.w	r3, r3, ror #13
 c000df8:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000dfc:	4053      	eors	r3, r2
 c000dfe:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e0 ^= (a >> 22 | a << 10);
 c000e02:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000e06:	ea4f 53b3 	mov.w	r3, r3, ror #22
 c000e0a:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000e0e:	4053      	eors	r3, r2
 c000e10:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
                e1 = (e >> 6 | e << 26);
 c000e14:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e18:	ea4f 13b3 	mov.w	r3, r3, ror #6
 c000e1c:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                e1 ^= (e >> 11 | e << 21);
 c000e20:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e24:	ea4f 23f3 	mov.w	r3, r3, ror #11
 c000e28:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 c000e2c:	4053      	eors	r3, r2
 c000e2e:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                e1 ^= (e >> 25 | e << 7);
 c000e32:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e36:	ea4f 6373 	mov.w	r3, r3, ror #25
 c000e3a:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 c000e3e:	4053      	eors	r3, r2
 c000e40:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
                t1 = h + e1 + ((e & f) ^ (~e & g)) + k[t] + w[t];
 c000e44:	f8d7 2230 	ldr.w	r2, [r7, #560]	@ 0x230
 c000e48:	f8d7 3224 	ldr.w	r3, [r7, #548]	@ 0x224
 c000e4c:	441a      	add	r2, r3
 c000e4e:	f8d7 123c 	ldr.w	r1, [r7, #572]	@ 0x23c
 c000e52:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000e56:	4019      	ands	r1, r3
 c000e58:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000e5c:	43d8      	mvns	r0, r3
 c000e5e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000e62:	4003      	ands	r3, r0
 c000e64:	404b      	eors	r3, r1
 c000e66:	441a      	add	r2, r3
 c000e68:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000e6c:	f5a3 7313 	sub.w	r3, r3, #588	@ 0x24c
 c000e70:	f8d7 122c 	ldr.w	r1, [r7, #556]	@ 0x22c
 c000e74:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000e78:	441a      	add	r2, r3
 c000e7a:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000e7e:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 c000e82:	f8d7 122c 	ldr.w	r1, [r7, #556]	@ 0x22c
 c000e86:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c000e8a:	4413      	add	r3, r2
 c000e8c:	f8c7 3220 	str.w	r3, [r7, #544]	@ 0x220
                t2 = e0 + ((a & b) ^ (a & c) ^ (b & c));
 c000e90:	f8d7 2248 	ldr.w	r2, [r7, #584]	@ 0x248
 c000e94:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000e98:	405a      	eors	r2, r3
 c000e9a:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000e9e:	401a      	ands	r2, r3
 c000ea0:	f8d7 1248 	ldr.w	r1, [r7, #584]	@ 0x248
 c000ea4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000ea8:	400b      	ands	r3, r1
 c000eaa:	4053      	eors	r3, r2
 c000eac:	f8d7 2228 	ldr.w	r2, [r7, #552]	@ 0x228
 c000eb0:	4413      	add	r3, r2
 c000eb2:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
                h = g;
 c000eb6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000eba:	f8c7 3230 	str.w	r3, [r7, #560]	@ 0x230
                g = f;
 c000ebe:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000ec2:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
                f = e;
 c000ec6:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000eca:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
                e = d + t1;
 c000ece:	f8d7 2240 	ldr.w	r2, [r7, #576]	@ 0x240
 c000ed2:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 c000ed6:	4413      	add	r3, r2
 c000ed8:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
                d = c;
 c000edc:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000ee0:	f8c7 3240 	str.w	r3, [r7, #576]	@ 0x240
                c = b;
 c000ee4:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 c000ee8:	f8c7 3244 	str.w	r3, [r7, #580]	@ 0x244
                b = a;
 c000eec:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000ef0:	f8c7 3248 	str.w	r3, [r7, #584]	@ 0x248
                a = t1 + t2;
 c000ef4:	f8d7 2220 	ldr.w	r2, [r7, #544]	@ 0x220
 c000ef8:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 c000efc:	4413      	add	r3, r2
 c000efe:	f8c7 324c 	str.w	r3, [r7, #588]	@ 0x24c
            for (t = 0; t < 64; ++t) {
 c000f02:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000f06:	3301      	adds	r3, #1
 c000f08:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 c000f0c:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 c000f10:	2b3f      	cmp	r3, #63	@ 0x3f
 c000f12:	f77f af67 	ble.w	c000de4 <sha256_update+0x450>
            }
            sha->state[0] = (sha->state[0] + a) & 0xffffffffU;
 c000f16:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f1a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f1e:	681b      	ldr	r3, [r3, #0]
 c000f20:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 c000f22:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 c000f26:	441a      	add	r2, r3
 c000f28:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f2c:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f30:	681b      	ldr	r3, [r3, #0]
 c000f32:	661a      	str	r2, [r3, #96]	@ 0x60
            sha->state[1] = (sha->state[1] + b) & 0xffffffffU;
 c000f34:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f38:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f3c:	681b      	ldr	r3, [r3, #0]
 c000f3e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 c000f40:	f8d7 3248 	ldr.w	r3, [r7, #584]	@ 0x248
 c000f44:	441a      	add	r2, r3
 c000f46:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f4a:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f4e:	681b      	ldr	r3, [r3, #0]
 c000f50:	665a      	str	r2, [r3, #100]	@ 0x64
            sha->state[2] = (sha->state[2] + c) & 0xffffffffU;
 c000f52:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f56:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f5a:	681b      	ldr	r3, [r3, #0]
 c000f5c:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 c000f5e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 c000f62:	441a      	add	r2, r3
 c000f64:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f68:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f6c:	681b      	ldr	r3, [r3, #0]
 c000f6e:	669a      	str	r2, [r3, #104]	@ 0x68
            sha->state[3] = (sha->state[3] + d) & 0xffffffffU;
 c000f70:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f74:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f78:	681b      	ldr	r3, [r3, #0]
 c000f7a:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 c000f7c:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 c000f80:	441a      	add	r2, r3
 c000f82:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f86:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f8a:	681b      	ldr	r3, [r3, #0]
 c000f8c:	66da      	str	r2, [r3, #108]	@ 0x6c
            sha->state[4] = (sha->state[4] + e) & 0xffffffffU;
 c000f8e:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000f92:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000f96:	681b      	ldr	r3, [r3, #0]
 c000f98:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 c000f9a:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 c000f9e:	441a      	add	r2, r3
 c000fa0:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fa4:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fa8:	681b      	ldr	r3, [r3, #0]
 c000faa:	671a      	str	r2, [r3, #112]	@ 0x70
            sha->state[5] = (sha->state[5] + f) & 0xffffffffU;
 c000fac:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fb0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fb4:	681b      	ldr	r3, [r3, #0]
 c000fb6:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
 c000fb8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 c000fbc:	441a      	add	r2, r3
 c000fbe:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fc2:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fc6:	681b      	ldr	r3, [r3, #0]
 c000fc8:	675a      	str	r2, [r3, #116]	@ 0x74
            sha->state[6] = (sha->state[6] + g) & 0xffffffffU;
 c000fca:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fce:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fd2:	681b      	ldr	r3, [r3, #0]
 c000fd4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 c000fd6:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 c000fda:	441a      	add	r2, r3
 c000fdc:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fe0:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000fe4:	681b      	ldr	r3, [r3, #0]
 c000fe6:	679a      	str	r2, [r3, #120]	@ 0x78
            sha->state[7] = (sha->state[7] + h) & 0xffffffffU;
 c000fe8:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000fec:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c000ff0:	681b      	ldr	r3, [r3, #0]
 c000ff2:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
 c000ff4:	f8d7 3230 	ldr.w	r3, [r7, #560]	@ 0x230
 c000ff8:	441a      	add	r2, r3
 c000ffa:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c000ffe:	f5a3 7315 	sub.w	r3, r3, #596	@ 0x254
 c001002:	681b      	ldr	r3, [r3, #0]
 c001004:	67da      	str	r2, [r3, #124]	@ 0x7c
    while (length > 0) {
 c001006:	f507 7318 	add.w	r3, r7, #608	@ 0x260
 c00100a:	f5a3 7317 	sub.w	r3, r3, #604	@ 0x25c
 c00100e:	681b      	ldr	r3, [r3, #0]
 c001010:	2b00      	cmp	r3, #0
 c001012:	f47f ad63 	bne.w	c000adc <sha256_update+0x148>
        }
    }
}
 c001016:	bf00      	nop
 c001018:	bf00      	nop
 c00101a:	f507 7719 	add.w	r7, r7, #612	@ 0x264
 c00101e:	46bd      	mov	sp, r7
 c001020:	bd90      	pop	{r4, r7, pc}
 c001022:	bf00      	nop

0c001024 <sha256_finalize>:

//  Changed by RKW, formal args are now const uint8_t, uint_32
//    from const unsigned char, unsigned long respectively
void sha256_finalize(sha256 *sha,
                     const uint8_t *message,
                     uint32_t length) {
 c001024:	b580      	push	{r7, lr}
 c001026:	b098      	sub	sp, #96	@ 0x60
 c001028:	af00      	add	r7, sp, #0
 c00102a:	60f8      	str	r0, [r7, #12]
 c00102c:	60b9      	str	r1, [r7, #8]
 c00102e:	607a      	str	r2, [r7, #4]
    int i;
	// Changed by RKW, unsigned char becomes uint8_t
    uint8_t terminator[64 + 8] = { 0x80 };
 c001030:	2380      	movs	r3, #128	@ 0x80
 c001032:	617b      	str	r3, [r7, #20]
 c001034:	f107 0318 	add.w	r3, r7, #24
 c001038:	2244      	movs	r2, #68	@ 0x44
 c00103a:	2100      	movs	r1, #0
 c00103c:	4618      	mov	r0, r3
 c00103e:	f004 fd23 	bl	c005a88 <memset>
    /* Hash the final message bytes if necessary. */
    if (length > 0) sha256_update(sha, message, length);
 c001042:	687b      	ldr	r3, [r7, #4]
 c001044:	2b00      	cmp	r3, #0
 c001046:	d004      	beq.n	c001052 <sha256_finalize+0x2e>
 c001048:	687a      	ldr	r2, [r7, #4]
 c00104a:	68b9      	ldr	r1, [r7, #8]
 c00104c:	68f8      	ldr	r0, [r7, #12]
 c00104e:	f7ff fca1 	bl	c000994 <sha256_update>
    /* Create a terminator that includes a stop bit, padding, and
     * the the total message length. See FIPS 180-2 for details. */
    length = 64 - sha->length[6] % 2 * 32 - sha->length[7] / 8;
 c001052:	68fb      	ldr	r3, [r7, #12]
 c001054:	f893 3086 	ldrb.w	r3, [r3, #134]	@ 0x86
 c001058:	f003 0301 	and.w	r3, r3, #1
 c00105c:	f1c3 0302 	rsb	r3, r3, #2
 c001060:	015b      	lsls	r3, r3, #5
 c001062:	68fa      	ldr	r2, [r7, #12]
 c001064:	f892 2087 	ldrb.w	r2, [r2, #135]	@ 0x87
 c001068:	08d2      	lsrs	r2, r2, #3
 c00106a:	b2d2      	uxtb	r2, r2
 c00106c:	1a9b      	subs	r3, r3, r2
 c00106e:	607b      	str	r3, [r7, #4]
    if (length < 9) length += 64;
 c001070:	687b      	ldr	r3, [r7, #4]
 c001072:	2b08      	cmp	r3, #8
 c001074:	d802      	bhi.n	c00107c <sha256_finalize+0x58>
 c001076:	687b      	ldr	r3, [r7, #4]
 c001078:	3340      	adds	r3, #64	@ 0x40
 c00107a:	607b      	str	r3, [r7, #4]
    for (i = 0; i < 8; ++i) terminator[length - 8 + i] = sha->length[i];
 c00107c:	2300      	movs	r3, #0
 c00107e:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c001080:	e00f      	b.n	c0010a2 <sha256_finalize+0x7e>
 c001082:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c001084:	687b      	ldr	r3, [r7, #4]
 c001086:	4413      	add	r3, r2
 c001088:	3b08      	subs	r3, #8
 c00108a:	68f9      	ldr	r1, [r7, #12]
 c00108c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c00108e:	440a      	add	r2, r1
 c001090:	3280      	adds	r2, #128	@ 0x80
 c001092:	7812      	ldrb	r2, [r2, #0]
 c001094:	3360      	adds	r3, #96	@ 0x60
 c001096:	443b      	add	r3, r7
 c001098:	f803 2c4c 	strb.w	r2, [r3, #-76]
 c00109c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c00109e:	3301      	adds	r3, #1
 c0010a0:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010a2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010a4:	2b07      	cmp	r3, #7
 c0010a6:	ddec      	ble.n	c001082 <sha256_finalize+0x5e>
    /* Hash the terminator to finalize the message digest. */
    sha256_update(sha, terminator, length);
 c0010a8:	f107 0314 	add.w	r3, r7, #20
 c0010ac:	687a      	ldr	r2, [r7, #4]
 c0010ae:	4619      	mov	r1, r3
 c0010b0:	68f8      	ldr	r0, [r7, #12]
 c0010b2:	f7ff fc6f 	bl	c000994 <sha256_update>
    /* Extract the message digest. */
    for (i = 0; i < 32; ++i) {
 c0010b6:	2300      	movs	r3, #0
 c0010b8:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010ba:	e01f      	b.n	c0010fc <sha256_finalize+0xd8>
        sha->hash[i] = (sha->state[i / 4] >> (24 - 8 * (i % 4))) & 0xff;
 c0010bc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010be:	2b00      	cmp	r3, #0
 c0010c0:	da00      	bge.n	c0010c4 <sha256_finalize+0xa0>
 c0010c2:	3303      	adds	r3, #3
 c0010c4:	109b      	asrs	r3, r3, #2
 c0010c6:	461a      	mov	r2, r3
 c0010c8:	68fb      	ldr	r3, [r7, #12]
 c0010ca:	3218      	adds	r2, #24
 c0010cc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c0010d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010d2:	4259      	negs	r1, r3
 c0010d4:	f003 0303 	and.w	r3, r3, #3
 c0010d8:	f001 0103 	and.w	r1, r1, #3
 c0010dc:	bf58      	it	pl
 c0010de:	424b      	negpl	r3, r1
 c0010e0:	f1c3 0303 	rsb	r3, r3, #3
 c0010e4:	00db      	lsls	r3, r3, #3
 c0010e6:	fa22 f303 	lsr.w	r3, r2, r3
 c0010ea:	b2d9      	uxtb	r1, r3
 c0010ec:	68fa      	ldr	r2, [r7, #12]
 c0010ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010f0:	4413      	add	r3, r2
 c0010f2:	460a      	mov	r2, r1
 c0010f4:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < 32; ++i) {
 c0010f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010f8:	3301      	adds	r3, #1
 c0010fa:	65fb      	str	r3, [r7, #92]	@ 0x5c
 c0010fc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c0010fe:	2b1f      	cmp	r3, #31
 c001100:	dddc      	ble.n	c0010bc <sha256_finalize+0x98>
    }
}
 c001102:	bf00      	nop
 c001104:	bf00      	nop
 c001106:	3760      	adds	r7, #96	@ 0x60
 c001108:	46bd      	mov	sp, r7
 c00110a:	bd80      	pop	{r7, pc}

0c00110c <hmac_sha256_initialize>:
} hmac_sha256;

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_initialize(hmac_sha256 *hmac,
                            const uint8_t *key, int length) {
 c00110c:	b580      	push	{r7, lr}
 c00110e:	b086      	sub	sp, #24
 c001110:	af00      	add	r7, sp, #0
 c001112:	60f8      	str	r0, [r7, #12]
 c001114:	60b9      	str	r1, [r7, #8]
 c001116:	607a      	str	r2, [r7, #4]
    int i;
    /* Prepare the inner hash key block, hashing the key if it's too long. */
    if (length <= 64) {
 c001118:	687b      	ldr	r3, [r7, #4]
 c00111a:	2b40      	cmp	r3, #64	@ 0x40
 c00111c:	dc24      	bgt.n	c001168 <hmac_sha256_initialize+0x5c>
        for (i = 0; i < length; ++i) hmac->key[i] = key[i] ^ 0x36;
 c00111e:	2300      	movs	r3, #0
 c001120:	617b      	str	r3, [r7, #20]
 c001122:	e00f      	b.n	c001144 <hmac_sha256_initialize+0x38>
 c001124:	697b      	ldr	r3, [r7, #20]
 c001126:	68ba      	ldr	r2, [r7, #8]
 c001128:	4413      	add	r3, r2
 c00112a:	781b      	ldrb	r3, [r3, #0]
 c00112c:	f083 0336 	eor.w	r3, r3, #54	@ 0x36
 c001130:	b2d9      	uxtb	r1, r3
 c001132:	68fa      	ldr	r2, [r7, #12]
 c001134:	697b      	ldr	r3, [r7, #20]
 c001136:	4413      	add	r3, r2
 c001138:	3320      	adds	r3, #32
 c00113a:	460a      	mov	r2, r1
 c00113c:	701a      	strb	r2, [r3, #0]
 c00113e:	697b      	ldr	r3, [r7, #20]
 c001140:	3301      	adds	r3, #1
 c001142:	617b      	str	r3, [r7, #20]
 c001144:	697a      	ldr	r2, [r7, #20]
 c001146:	687b      	ldr	r3, [r7, #4]
 c001148:	429a      	cmp	r2, r3
 c00114a:	dbeb      	blt.n	c001124 <hmac_sha256_initialize+0x18>
        for (; i < 64; ++i) hmac->key[i] = 0x36;
 c00114c:	e008      	b.n	c001160 <hmac_sha256_initialize+0x54>
 c00114e:	68fa      	ldr	r2, [r7, #12]
 c001150:	697b      	ldr	r3, [r7, #20]
 c001152:	4413      	add	r3, r2
 c001154:	3320      	adds	r3, #32
 c001156:	2236      	movs	r2, #54	@ 0x36
 c001158:	701a      	strb	r2, [r3, #0]
 c00115a:	697b      	ldr	r3, [r7, #20]
 c00115c:	3301      	adds	r3, #1
 c00115e:	617b      	str	r3, [r7, #20]
 c001160:	697b      	ldr	r3, [r7, #20]
 c001162:	2b3f      	cmp	r3, #63	@ 0x3f
 c001164:	ddf3      	ble.n	c00114e <hmac_sha256_initialize+0x42>
 c001166:	e02f      	b.n	c0011c8 <hmac_sha256_initialize+0xbc>
    } else {
        sha256_initialize(&(hmac->sha));
 c001168:	68fb      	ldr	r3, [r7, #12]
 c00116a:	3360      	adds	r3, #96	@ 0x60
 c00116c:	4618      	mov	r0, r3
 c00116e:	f7ff fbbf 	bl	c0008f0 <sha256_initialize>
        sha256_finalize(&(hmac->sha), key, length);
 c001172:	68fb      	ldr	r3, [r7, #12]
 c001174:	3360      	adds	r3, #96	@ 0x60
 c001176:	687a      	ldr	r2, [r7, #4]
 c001178:	68b9      	ldr	r1, [r7, #8]
 c00117a:	4618      	mov	r0, r3
 c00117c:	f7ff ff52 	bl	c001024 <sha256_finalize>
        for (i = 0; i < 32; ++i) hmac->key[i] = hmac->sha.hash[i] ^ 0x36;
 c001180:	2300      	movs	r3, #0
 c001182:	617b      	str	r3, [r7, #20]
 c001184:	e010      	b.n	c0011a8 <hmac_sha256_initialize+0x9c>
 c001186:	68fa      	ldr	r2, [r7, #12]
 c001188:	697b      	ldr	r3, [r7, #20]
 c00118a:	4413      	add	r3, r2
 c00118c:	3360      	adds	r3, #96	@ 0x60
 c00118e:	781b      	ldrb	r3, [r3, #0]
 c001190:	f083 0336 	eor.w	r3, r3, #54	@ 0x36
 c001194:	b2d9      	uxtb	r1, r3
 c001196:	68fa      	ldr	r2, [r7, #12]
 c001198:	697b      	ldr	r3, [r7, #20]
 c00119a:	4413      	add	r3, r2
 c00119c:	3320      	adds	r3, #32
 c00119e:	460a      	mov	r2, r1
 c0011a0:	701a      	strb	r2, [r3, #0]
 c0011a2:	697b      	ldr	r3, [r7, #20]
 c0011a4:	3301      	adds	r3, #1
 c0011a6:	617b      	str	r3, [r7, #20]
 c0011a8:	697b      	ldr	r3, [r7, #20]
 c0011aa:	2b1f      	cmp	r3, #31
 c0011ac:	ddeb      	ble.n	c001186 <hmac_sha256_initialize+0x7a>
        for (; i < 64; ++i) hmac->key[i] = 0x36;
 c0011ae:	e008      	b.n	c0011c2 <hmac_sha256_initialize+0xb6>
 c0011b0:	68fa      	ldr	r2, [r7, #12]
 c0011b2:	697b      	ldr	r3, [r7, #20]
 c0011b4:	4413      	add	r3, r2
 c0011b6:	3320      	adds	r3, #32
 c0011b8:	2236      	movs	r2, #54	@ 0x36
 c0011ba:	701a      	strb	r2, [r3, #0]
 c0011bc:	697b      	ldr	r3, [r7, #20]
 c0011be:	3301      	adds	r3, #1
 c0011c0:	617b      	str	r3, [r7, #20]
 c0011c2:	697b      	ldr	r3, [r7, #20]
 c0011c4:	2b3f      	cmp	r3, #63	@ 0x3f
 c0011c6:	ddf3      	ble.n	c0011b0 <hmac_sha256_initialize+0xa4>
    }
    /* Initialize the inner hash with the key block. */
    sha256_initialize(&(hmac->sha));
 c0011c8:	68fb      	ldr	r3, [r7, #12]
 c0011ca:	3360      	adds	r3, #96	@ 0x60
 c0011cc:	4618      	mov	r0, r3
 c0011ce:	f7ff fb8f 	bl	c0008f0 <sha256_initialize>
    sha256_update(&(hmac->sha), hmac->key, 64);
 c0011d2:	68fb      	ldr	r3, [r7, #12]
 c0011d4:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 c0011d8:	68fb      	ldr	r3, [r7, #12]
 c0011da:	3320      	adds	r3, #32
 c0011dc:	2240      	movs	r2, #64	@ 0x40
 c0011de:	4619      	mov	r1, r3
 c0011e0:	f7ff fbd8 	bl	c000994 <sha256_update>
}
 c0011e4:	bf00      	nop
 c0011e6:	3718      	adds	r7, #24
 c0011e8:	46bd      	mov	sp, r7
 c0011ea:	bd80      	pop	{r7, pc}

0c0011ec <hmac_sha256_update>:

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_update(hmac_sha256 *hmac,
                        const uint8_t *message, int length) {
 c0011ec:	b580      	push	{r7, lr}
 c0011ee:	b084      	sub	sp, #16
 c0011f0:	af00      	add	r7, sp, #0
 c0011f2:	60f8      	str	r0, [r7, #12]
 c0011f4:	60b9      	str	r1, [r7, #8]
 c0011f6:	607a      	str	r2, [r7, #4]
    /* Update the inner hash. */
    sha256_update(&(hmac->sha), message, length);
 c0011f8:	68fb      	ldr	r3, [r7, #12]
 c0011fa:	3360      	adds	r3, #96	@ 0x60
 c0011fc:	687a      	ldr	r2, [r7, #4]
 c0011fe:	68b9      	ldr	r1, [r7, #8]
 c001200:	4618      	mov	r0, r3
 c001202:	f7ff fbc7 	bl	c000994 <sha256_update>
}
 c001206:	bf00      	nop
 c001208:	3710      	adds	r7, #16
 c00120a:	46bd      	mov	sp, r7
 c00120c:	bd80      	pop	{r7, pc}

0c00120e <hmac_sha256_finalize>:

//  Changed by RKW, formal arg is now const uint8_t
//    from const unsigned char
void hmac_sha256_finalize(hmac_sha256 *hmac,
                          const uint8_t *message, int length) {
 c00120e:	b580      	push	{r7, lr}
 c001210:	b086      	sub	sp, #24
 c001212:	af00      	add	r7, sp, #0
 c001214:	60f8      	str	r0, [r7, #12]
 c001216:	60b9      	str	r1, [r7, #8]
 c001218:	607a      	str	r2, [r7, #4]
    int i;
    /* Finalize the inner hash and store its value in the digest array. */
    sha256_finalize(&(hmac->sha), message, length);
 c00121a:	68fb      	ldr	r3, [r7, #12]
 c00121c:	3360      	adds	r3, #96	@ 0x60
 c00121e:	687a      	ldr	r2, [r7, #4]
 c001220:	68b9      	ldr	r1, [r7, #8]
 c001222:	4618      	mov	r0, r3
 c001224:	f7ff fefe 	bl	c001024 <sha256_finalize>
    for (i = 0; i < 32; ++i) hmac->digest[i] = hmac->sha.hash[i];
 c001228:	2300      	movs	r3, #0
 c00122a:	617b      	str	r3, [r7, #20]
 c00122c:	e00c      	b.n	c001248 <hmac_sha256_finalize+0x3a>
 c00122e:	68fa      	ldr	r2, [r7, #12]
 c001230:	697b      	ldr	r3, [r7, #20]
 c001232:	4413      	add	r3, r2
 c001234:	3360      	adds	r3, #96	@ 0x60
 c001236:	7819      	ldrb	r1, [r3, #0]
 c001238:	68fa      	ldr	r2, [r7, #12]
 c00123a:	697b      	ldr	r3, [r7, #20]
 c00123c:	4413      	add	r3, r2
 c00123e:	460a      	mov	r2, r1
 c001240:	701a      	strb	r2, [r3, #0]
 c001242:	697b      	ldr	r3, [r7, #20]
 c001244:	3301      	adds	r3, #1
 c001246:	617b      	str	r3, [r7, #20]
 c001248:	697b      	ldr	r3, [r7, #20]
 c00124a:	2b1f      	cmp	r3, #31
 c00124c:	ddef      	ble.n	c00122e <hmac_sha256_finalize+0x20>
    /* Convert the inner hash key block to the outer hash key block. */
    for (i = 0; i < 64; ++i) hmac->key[i] ^= (0x36 ^ 0x5c);
 c00124e:	2300      	movs	r3, #0
 c001250:	617b      	str	r3, [r7, #20]
 c001252:	e010      	b.n	c001276 <hmac_sha256_finalize+0x68>
 c001254:	68fa      	ldr	r2, [r7, #12]
 c001256:	697b      	ldr	r3, [r7, #20]
 c001258:	4413      	add	r3, r2
 c00125a:	3320      	adds	r3, #32
 c00125c:	781b      	ldrb	r3, [r3, #0]
 c00125e:	f083 036a 	eor.w	r3, r3, #106	@ 0x6a
 c001262:	b2d9      	uxtb	r1, r3
 c001264:	68fa      	ldr	r2, [r7, #12]
 c001266:	697b      	ldr	r3, [r7, #20]
 c001268:	4413      	add	r3, r2
 c00126a:	3320      	adds	r3, #32
 c00126c:	460a      	mov	r2, r1
 c00126e:	701a      	strb	r2, [r3, #0]
 c001270:	697b      	ldr	r3, [r7, #20]
 c001272:	3301      	adds	r3, #1
 c001274:	617b      	str	r3, [r7, #20]
 c001276:	697b      	ldr	r3, [r7, #20]
 c001278:	2b3f      	cmp	r3, #63	@ 0x3f
 c00127a:	ddeb      	ble.n	c001254 <hmac_sha256_finalize+0x46>
    /* Calculate the outer hash. */
    sha256_initialize(&(hmac->sha));
 c00127c:	68fb      	ldr	r3, [r7, #12]
 c00127e:	3360      	adds	r3, #96	@ 0x60
 c001280:	4618      	mov	r0, r3
 c001282:	f7ff fb35 	bl	c0008f0 <sha256_initialize>
    sha256_update(&(hmac->sha), hmac->key, 64);
 c001286:	68fb      	ldr	r3, [r7, #12]
 c001288:	f103 0060 	add.w	r0, r3, #96	@ 0x60
 c00128c:	68fb      	ldr	r3, [r7, #12]
 c00128e:	3320      	adds	r3, #32
 c001290:	2240      	movs	r2, #64	@ 0x40
 c001292:	4619      	mov	r1, r3
 c001294:	f7ff fb7e 	bl	c000994 <sha256_update>
    sha256_finalize(&(hmac->sha), hmac->digest, 32);
 c001298:	68fb      	ldr	r3, [r7, #12]
 c00129a:	3360      	adds	r3, #96	@ 0x60
 c00129c:	68f9      	ldr	r1, [r7, #12]
 c00129e:	2220      	movs	r2, #32
 c0012a0:	4618      	mov	r0, r3
 c0012a2:	f7ff febf 	bl	c001024 <sha256_finalize>
    /* Use the outer hash value as the HMAC digest. */
    for (i = 0; i < 32; ++i) hmac->digest[i] = hmac->sha.hash[i];
 c0012a6:	2300      	movs	r3, #0
 c0012a8:	617b      	str	r3, [r7, #20]
 c0012aa:	e00c      	b.n	c0012c6 <hmac_sha256_finalize+0xb8>
 c0012ac:	68fa      	ldr	r2, [r7, #12]
 c0012ae:	697b      	ldr	r3, [r7, #20]
 c0012b0:	4413      	add	r3, r2
 c0012b2:	3360      	adds	r3, #96	@ 0x60
 c0012b4:	7819      	ldrb	r1, [r3, #0]
 c0012b6:	68fa      	ldr	r2, [r7, #12]
 c0012b8:	697b      	ldr	r3, [r7, #20]
 c0012ba:	4413      	add	r3, r2
 c0012bc:	460a      	mov	r2, r1
 c0012be:	701a      	strb	r2, [r3, #0]
 c0012c0:	697b      	ldr	r3, [r7, #20]
 c0012c2:	3301      	adds	r3, #1
 c0012c4:	617b      	str	r3, [r7, #20]
 c0012c6:	697b      	ldr	r3, [r7, #20]
 c0012c8:	2b1f      	cmp	r3, #31
 c0012ca:	ddef      	ble.n	c0012ac <hmac_sha256_finalize+0x9e>
}
 c0012cc:	bf00      	nop
 c0012ce:	bf00      	nop
 c0012d0:	3718      	adds	r7, #24
 c0012d2:	46bd      	mov	sp, r7
 c0012d4:	bd80      	pop	{r7, pc}
	...

0c0012d8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 c0012d8:	b580      	push	{r7, lr}
 c0012da:	b088      	sub	sp, #32
 c0012dc:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and interrupts secure/non-secure allocation setup done */
  /* in SystemInit() based on partition_stm32l552xx.h file's definitions. */

  /* USER CODE BEGIN 1 */
  /* Enable SecureFault handler (HardFault is default) */
  SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
 c0012de:	4b53      	ldr	r3, [pc, #332]	@ (c00142c <main+0x154>)
 c0012e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0012e2:	4a52      	ldr	r2, [pc, #328]	@ (c00142c <main+0x154>)
 c0012e4:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 c0012e8:	6253      	str	r3, [r2, #36]	@ 0x24
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 c0012ea:	f002 fc65 	bl	c003bb8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* GTZC initialisation */
  MX_GTZC_S_Init();
 c0012ee:	f000 f8f5 	bl	c0014dc <MX_GTZC_S_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 c0012f2:	f000 f97f 	bl	c0015f4 <MX_GPIO_Init>
  MX_ICACHE_Init();
 c0012f6:	f000 f969 	bl	c0015cc <MX_ICACHE_Init>
   /* Add your secure application code here prior to non-secure initialization
     */

  /* All IOs are by default allocated to secure */
  /* Release them all to non-secure except PC.07 (LED1) kept as secure */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c0012fa:	4b4d      	ldr	r3, [pc, #308]	@ (c001430 <main+0x158>)
 c0012fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0012fe:	4a4c      	ldr	r2, [pc, #304]	@ (c001430 <main+0x158>)
 c001300:	f043 0301 	orr.w	r3, r3, #1
 c001304:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001306:	4b4a      	ldr	r3, [pc, #296]	@ (c001430 <main+0x158>)
 c001308:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00130a:	f003 0301 	and.w	r3, r3, #1
 c00130e:	61fb      	str	r3, [r7, #28]
 c001310:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c001312:	4b47      	ldr	r3, [pc, #284]	@ (c001430 <main+0x158>)
 c001314:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001316:	4a46      	ldr	r2, [pc, #280]	@ (c001430 <main+0x158>)
 c001318:	f043 0302 	orr.w	r3, r3, #2
 c00131c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00131e:	4b44      	ldr	r3, [pc, #272]	@ (c001430 <main+0x158>)
 c001320:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001322:	f003 0302 	and.w	r3, r3, #2
 c001326:	61bb      	str	r3, [r7, #24]
 c001328:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 c00132a:	4b41      	ldr	r3, [pc, #260]	@ (c001430 <main+0x158>)
 c00132c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00132e:	4a40      	ldr	r2, [pc, #256]	@ (c001430 <main+0x158>)
 c001330:	f043 0304 	orr.w	r3, r3, #4
 c001334:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001336:	4b3e      	ldr	r3, [pc, #248]	@ (c001430 <main+0x158>)
 c001338:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00133a:	f003 0304 	and.w	r3, r3, #4
 c00133e:	617b      	str	r3, [r7, #20]
 c001340:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 c001342:	4b3b      	ldr	r3, [pc, #236]	@ (c001430 <main+0x158>)
 c001344:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001346:	4a3a      	ldr	r2, [pc, #232]	@ (c001430 <main+0x158>)
 c001348:	f043 0308 	orr.w	r3, r3, #8
 c00134c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00134e:	4b38      	ldr	r3, [pc, #224]	@ (c001430 <main+0x158>)
 c001350:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001352:	f003 0308 	and.w	r3, r3, #8
 c001356:	613b      	str	r3, [r7, #16]
 c001358:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 c00135a:	4b35      	ldr	r3, [pc, #212]	@ (c001430 <main+0x158>)
 c00135c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00135e:	4a34      	ldr	r2, [pc, #208]	@ (c001430 <main+0x158>)
 c001360:	f043 0310 	orr.w	r3, r3, #16
 c001364:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001366:	4b32      	ldr	r3, [pc, #200]	@ (c001430 <main+0x158>)
 c001368:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00136a:	f003 0310 	and.w	r3, r3, #16
 c00136e:	60fb      	str	r3, [r7, #12]
 c001370:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 c001372:	4b2f      	ldr	r3, [pc, #188]	@ (c001430 <main+0x158>)
 c001374:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001376:	4a2e      	ldr	r2, [pc, #184]	@ (c001430 <main+0x158>)
 c001378:	f043 0320 	orr.w	r3, r3, #32
 c00137c:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c00137e:	4b2c      	ldr	r3, [pc, #176]	@ (c001430 <main+0x158>)
 c001380:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c001382:	f003 0320 	and.w	r3, r3, #32
 c001386:	60bb      	str	r3, [r7, #8]
 c001388:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c00138a:	4b29      	ldr	r3, [pc, #164]	@ (c001430 <main+0x158>)
 c00138c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00138e:	4a28      	ldr	r2, [pc, #160]	@ (c001430 <main+0x158>)
 c001390:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c001394:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001396:	4b26      	ldr	r3, [pc, #152]	@ (c001430 <main+0x158>)
 c001398:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00139a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 c00139e:	607b      	str	r3, [r7, #4]
 c0013a0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c0013a2:	4b23      	ldr	r3, [pc, #140]	@ (c001430 <main+0x158>)
 c0013a4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0013a6:	4a22      	ldr	r2, [pc, #136]	@ (c001430 <main+0x158>)
 c0013a8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c0013ac:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c0013ae:	4b20      	ldr	r3, [pc, #128]	@ (c001430 <main+0x158>)
 c0013b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0013b2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 c0013b6:	603b      	str	r3, [r7, #0]
 c0013b8:	683b      	ldr	r3, [r7, #0]
  HAL_GPIO_ConfigPinAttributes(GPIOA, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013ba:	2200      	movs	r2, #0
 c0013bc:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013c0:	481c      	ldr	r0, [pc, #112]	@ (c001434 <main+0x15c>)
 c0013c2:	f003 fa31 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOB, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013c6:	2200      	movs	r2, #0
 c0013c8:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013cc:	481a      	ldr	r0, [pc, #104]	@ (c001438 <main+0x160>)
 c0013ce:	f003 fa2b 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOC, (GPIO_PIN_All & ~(GPIO_PIN_7)), GPIO_PIN_NSEC);
 c0013d2:	2200      	movs	r2, #0
 c0013d4:	f64f 717f 	movw	r1, #65407	@ 0xff7f
 c0013d8:	4818      	ldr	r0, [pc, #96]	@ (c00143c <main+0x164>)
 c0013da:	f003 fa25 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013de:	2200      	movs	r2, #0
 c0013e0:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013e4:	4816      	ldr	r0, [pc, #88]	@ (c001440 <main+0x168>)
 c0013e6:	f003 fa1f 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013ea:	2200      	movs	r2, #0
 c0013ec:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013f0:	4814      	ldr	r0, [pc, #80]	@ (c001444 <main+0x16c>)
 c0013f2:	f003 fa19 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOF, GPIO_PIN_All, GPIO_PIN_NSEC);
 c0013f6:	2200      	movs	r2, #0
 c0013f8:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c0013fc:	4812      	ldr	r0, [pc, #72]	@ (c001448 <main+0x170>)
 c0013fe:	f003 fa13 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG, GPIO_PIN_All, GPIO_PIN_NSEC);
 c001402:	2200      	movs	r2, #0
 c001404:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c001408:	4810      	ldr	r0, [pc, #64]	@ (c00144c <main+0x174>)
 c00140a:	f003 fa0d 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOH, GPIO_PIN_All, GPIO_PIN_NSEC);
 c00140e:	2200      	movs	r2, #0
 c001410:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c001414:	480e      	ldr	r0, [pc, #56]	@ (c001450 <main+0x178>)
 c001416:	f003 fa07 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>

  /* Leave the GPIO clocks enabled to let non-secure having I/Os control */

  /* Initialize PC.07 to drive external LED (LED1) */
  BSP_LED_Init(LED1);
 c00141a:	2000      	movs	r0, #0
 c00141c:	f002 f9ce 	bl	c0037bc <BSP_LED_Init>

  /* Secure SysTick should rather be suspended before calling non-secure  */
  /* in order to avoid wake-up from sleep mode entered by non-secure      */
  /* The Secure SysTick shall be resumed on non-secure callable functions */
  HAL_SuspendTick();
 c001420:	f002 fc40 	bl	c003ca4 <HAL_SuspendTick>
  /* USER CODE END 2 */

  /*************** Setup and jump to non-secure *******************************/

  NonSecure_Init();
 c001424:	f000 f816 	bl	c001454 <NonSecure_Init>

  /* Non-secure software does not return, this code is not executed */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 c001428:	bf00      	nop
 c00142a:	e7fd      	b.n	c001428 <main+0x150>
 c00142c:	e000ed00 	.word	0xe000ed00
 c001430:	50021000 	.word	0x50021000
 c001434:	52020000 	.word	0x52020000
 c001438:	52020400 	.word	0x52020400
 c00143c:	52020800 	.word	0x52020800
 c001440:	52020c00 	.word	0x52020c00
 c001444:	52021000 	.word	0x52021000
 c001448:	52021400 	.word	0x52021400
 c00144c:	52021800 	.word	0x52021800
 c001450:	52021c00 	.word	0x52021c00

0c001454 <NonSecure_Init>:
  *         This function is responsible for Non-secure initialization and switch
  *         to non-secure state
  * @retval None
  */
static void NonSecure_Init(void)
{
 c001454:	b590      	push	{r4, r7, lr}
 c001456:	b083      	sub	sp, #12
 c001458:	af00      	add	r7, sp, #0
  funcptr_NS NonSecure_ResetHandler;

  SCB_NS->VTOR = VTOR_TABLE_NS_START_ADDR;
 c00145a:	4b1d      	ldr	r3, [pc, #116]	@ (c0014d0 <NonSecure_Init+0x7c>)
 c00145c:	4a1d      	ldr	r2, [pc, #116]	@ (c0014d4 <NonSecure_Init+0x80>)
 c00145e:	609a      	str	r2, [r3, #8]

  /* Set non-secure main stack (MSP_NS) */
  __TZ_set_MSP_NS((*(uint32_t *)VTOR_TABLE_NS_START_ADDR));
 c001460:	4b1c      	ldr	r3, [pc, #112]	@ (c0014d4 <NonSecure_Init+0x80>)
 c001462:	681b      	ldr	r3, [r3, #0]
 c001464:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 c001466:	683b      	ldr	r3, [r7, #0]
 c001468:	f383 8888 	msr	MSP_NS, r3
}
 c00146c:	bf00      	nop

  /* Get non-secure reset handler */
  NonSecure_ResetHandler = (funcptr_NS)(*((uint32_t *)((VTOR_TABLE_NS_START_ADDR) + 4U)));
 c00146e:	4b1a      	ldr	r3, [pc, #104]	@ (c0014d8 <NonSecure_Init+0x84>)
 c001470:	681b      	ldr	r3, [r3, #0]
 c001472:	607b      	str	r3, [r7, #4]

  /* Start non-secure state software application */
  NonSecure_ResetHandler();
 c001474:	687b      	ldr	r3, [r7, #4]
 c001476:	461c      	mov	r4, r3
 c001478:	0864      	lsrs	r4, r4, #1
 c00147a:	0064      	lsls	r4, r4, #1
 c00147c:	4620      	mov	r0, r4
 c00147e:	4621      	mov	r1, r4
 c001480:	4622      	mov	r2, r4
 c001482:	4623      	mov	r3, r4
 c001484:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001488:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00148c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001490:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001494:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001498:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00149c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0014a0:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0014a4:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0014a8:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0014ac:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0014b0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0014b4:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0014b8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0014bc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0014c0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0014c4:	f7fe fec0 	bl	c000248 <__gnu_cmse_nonsecure_call>
}
 c0014c8:	bf00      	nop
 c0014ca:	370c      	adds	r7, #12
 c0014cc:	46bd      	mov	sp, r7
 c0014ce:	bd90      	pop	{r4, r7, pc}
 c0014d0:	e002ed00 	.word	0xe002ed00
 c0014d4:	08040000 	.word	0x08040000
 c0014d8:	08040004 	.word	0x08040004

0c0014dc <MX_GTZC_S_Init>:
  * @brief GTZC_S Initialization Function
  * @param None
  * @retval None
  */
static void MX_GTZC_S_Init(void)
{
 c0014dc:	b580      	push	{r7, lr}
 c0014de:	b09c      	sub	sp, #112	@ 0x70
 c0014e0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN GTZC_S_Init 0 */

  /* USER CODE END GTZC_S_Init 0 */

  MPCBB_ConfigTypeDef MPCBB_NonSecureArea_Desc = {0};
 c0014e2:	1d3b      	adds	r3, r7, #4
 c0014e4:	226c      	movs	r2, #108	@ 0x6c
 c0014e6:	2100      	movs	r1, #0
 c0014e8:	4618      	mov	r0, r3
 c0014ea:	f004 facd 	bl	c005a88 <memset>

  /* USER CODE BEGIN GTZC_S_Init 1 */

  /* USER CODE END GTZC_S_Init 1 */
  MPCBB_NonSecureArea_Desc.SecureRWIllegalMode = GTZC_MPCBB_SRWILADIS_ENABLE;
 c0014ee:	2300      	movs	r3, #0
 c0014f0:	607b      	str	r3, [r7, #4]
  MPCBB_NonSecureArea_Desc.InvertSecureState = GTZC_MPCBB_INVSECSTATE_NOT_INVERTED;
 c0014f2:	2300      	movs	r3, #0
 c0014f4:	60bb      	str	r3, [r7, #8]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0xFFFFFFFF;
 c0014f6:	f04f 33ff 	mov.w	r3, #4294967295
 c0014fa:	60fb      	str	r3, [r7, #12]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0xFFFFFFFF;
 c0014fc:	f04f 33ff 	mov.w	r3, #4294967295
 c001500:	613b      	str	r3, [r7, #16]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0xFFFFFFFF;
 c001502:	f04f 33ff 	mov.w	r3, #4294967295
 c001506:	617b      	str	r3, [r7, #20]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0xFFFFFFFF;
 c001508:	f04f 33ff 	mov.w	r3, #4294967295
 c00150c:	61bb      	str	r3, [r7, #24]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0xFFFFFFFF;
 c00150e:	f04f 33ff 	mov.w	r3, #4294967295
 c001512:	61fb      	str	r3, [r7, #28]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0xFFFFFFFF;
 c001514:	f04f 33ff 	mov.w	r3, #4294967295
 c001518:	623b      	str	r3, [r7, #32]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0xFFFFFFFF;
 c00151a:	f04f 33ff 	mov.w	r3, #4294967295
 c00151e:	627b      	str	r3, [r7, #36]	@ 0x24
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0xFFFFFFFF;
 c001520:	f04f 33ff 	mov.w	r3, #4294967295
 c001524:	62bb      	str	r3, [r7, #40]	@ 0x28
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[8] =   0xFFFFFFFF;
 c001526:	f04f 33ff 	mov.w	r3, #4294967295
 c00152a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[9] =   0xFFFFFFFF;
 c00152c:	f04f 33ff 	mov.w	r3, #4294967295
 c001530:	633b      	str	r3, [r7, #48]	@ 0x30
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[10] =   0xFFFFFFFF;
 c001532:	f04f 33ff 	mov.w	r3, #4294967295
 c001536:	637b      	str	r3, [r7, #52]	@ 0x34
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[11] =   0xFFFFFFFF;
 c001538:	f04f 33ff 	mov.w	r3, #4294967295
 c00153c:	63bb      	str	r3, [r7, #56]	@ 0x38
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[12] =   0x00000000;
 c00153e:	2300      	movs	r3, #0
 c001540:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[13] =   0x00000000;
 c001542:	2300      	movs	r3, #0
 c001544:	643b      	str	r3, [r7, #64]	@ 0x40
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[14] =   0x00000000;
 c001546:	2300      	movs	r3, #0
 c001548:	647b      	str	r3, [r7, #68]	@ 0x44
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[15] =   0x00000000;
 c00154a:	2300      	movs	r3, #0
 c00154c:	64bb      	str	r3, [r7, #72]	@ 0x48
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[16] =   0x00000000;
 c00154e:	2300      	movs	r3, #0
 c001550:	64fb      	str	r3, [r7, #76]	@ 0x4c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[17] =   0x00000000;
 c001552:	2300      	movs	r3, #0
 c001554:	653b      	str	r3, [r7, #80]	@ 0x50
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[18] =   0x00000000;
 c001556:	2300      	movs	r3, #0
 c001558:	657b      	str	r3, [r7, #84]	@ 0x54
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[19] =   0x00000000;
 c00155a:	2300      	movs	r3, #0
 c00155c:	65bb      	str	r3, [r7, #88]	@ 0x58
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[20] =   0x00000000;
 c00155e:	2300      	movs	r3, #0
 c001560:	65fb      	str	r3, [r7, #92]	@ 0x5c
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[21] =   0x00000000;
 c001562:	2300      	movs	r3, #0
 c001564:	663b      	str	r3, [r7, #96]	@ 0x60
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[22] =   0x00000000;
 c001566:	2300      	movs	r3, #0
 c001568:	667b      	str	r3, [r7, #100]	@ 0x64
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[23] =   0x00000000;
 c00156a:	2300      	movs	r3, #0
 c00156c:	66bb      	str	r3, [r7, #104]	@ 0x68
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
 c00156e:	2300      	movs	r3, #0
 c001570:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_GTZC_MPCBB_ConfigMem(SRAM1_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
 c001572:	1d3b      	adds	r3, r7, #4
 c001574:	4619      	mov	r1, r3
 c001576:	f04f 5040 	mov.w	r0, #805306368	@ 0x30000000
 c00157a:	f003 f975 	bl	c004868 <HAL_GTZC_MPCBB_ConfigMem>
 c00157e:	4603      	mov	r3, r0
 c001580:	2b00      	cmp	r3, #0
 c001582:	d001      	beq.n	c001588 <MX_GTZC_S_Init+0xac>
  {
    Error_Handler();
 c001584:	f000 f856 	bl	c001634 <Error_Handler>
  }
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0x00000000;
 c001588:	2300      	movs	r3, #0
 c00158a:	60fb      	str	r3, [r7, #12]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0x00000000;
 c00158c:	2300      	movs	r3, #0
 c00158e:	613b      	str	r3, [r7, #16]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0x00000000;
 c001590:	2300      	movs	r3, #0
 c001592:	617b      	str	r3, [r7, #20]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0x00000000;
 c001594:	2300      	movs	r3, #0
 c001596:	61bb      	str	r3, [r7, #24]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0x00000000;
 c001598:	2300      	movs	r3, #0
 c00159a:	61fb      	str	r3, [r7, #28]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0x00000000;
 c00159c:	2300      	movs	r3, #0
 c00159e:	623b      	str	r3, [r7, #32]
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0x00000000;
 c0015a0:	2300      	movs	r3, #0
 c0015a2:	627b      	str	r3, [r7, #36]	@ 0x24
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0x00000000;
 c0015a4:	2300      	movs	r3, #0
 c0015a6:	62bb      	str	r3, [r7, #40]	@ 0x28
  MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
 c0015a8:	2300      	movs	r3, #0
 c0015aa:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
 c0015ac:	1d3b      	adds	r3, r7, #4
 c0015ae:	4619      	mov	r1, r3
 c0015b0:	4805      	ldr	r0, [pc, #20]	@ (c0015c8 <MX_GTZC_S_Init+0xec>)
 c0015b2:	f003 f959 	bl	c004868 <HAL_GTZC_MPCBB_ConfigMem>
 c0015b6:	4603      	mov	r3, r0
 c0015b8:	2b00      	cmp	r3, #0
 c0015ba:	d001      	beq.n	c0015c0 <MX_GTZC_S_Init+0xe4>
  {
    Error_Handler();
 c0015bc:	f000 f83a 	bl	c001634 <Error_Handler>
  }
  /* USER CODE BEGIN GTZC_S_Init 2 */

  /* USER CODE END GTZC_S_Init 2 */

}
 c0015c0:	bf00      	nop
 c0015c2:	3770      	adds	r7, #112	@ 0x70
 c0015c4:	46bd      	mov	sp, r7
 c0015c6:	bd80      	pop	{r7, pc}
 c0015c8:	30030000 	.word	0x30030000

0c0015cc <MX_ICACHE_Init>:
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{
 c0015cc:	b580      	push	{r7, lr}
 c0015ce:	af00      	add	r7, sp, #0

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
 c0015d0:	2000      	movs	r0, #0
 c0015d2:	f003 fa5b 	bl	c004a8c <HAL_ICACHE_ConfigAssociativityMode>
 c0015d6:	4603      	mov	r3, r0
 c0015d8:	2b00      	cmp	r3, #0
 c0015da:	d001      	beq.n	c0015e0 <MX_ICACHE_Init+0x14>
  {
    Error_Handler();
 c0015dc:	f000 f82a 	bl	c001634 <Error_Handler>
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
 c0015e0:	f003 fa74 	bl	c004acc <HAL_ICACHE_Enable>
 c0015e4:	4603      	mov	r3, r0
 c0015e6:	2b00      	cmp	r3, #0
 c0015e8:	d001      	beq.n	c0015ee <MX_ICACHE_Init+0x22>
  {
    Error_Handler();
 c0015ea:	f000 f823 	bl	c001634 <Error_Handler>
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}
 c0015ee:	bf00      	nop
 c0015f0:	bd80      	pop	{r7, pc}
	...

0c0015f4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 c0015f4:	b580      	push	{r7, lr}
 c0015f6:	b082      	sub	sp, #8
 c0015f8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c0015fa:	4b0c      	ldr	r3, [pc, #48]	@ (c00162c <MX_GPIO_Init+0x38>)
 c0015fc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0015fe:	4a0b      	ldr	r2, [pc, #44]	@ (c00162c <MX_GPIO_Init+0x38>)
 c001600:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c001604:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c001606:	4b09      	ldr	r3, [pc, #36]	@ (c00162c <MX_GPIO_Init+0x38>)
 c001608:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00160a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 c00160e:	607b      	str	r3, [r7, #4]
 c001610:	687b      	ldr	r3, [r7, #4]
  HAL_PWREx_EnableVddIO2();
 c001612:	f003 fae5 	bl	c004be0 <HAL_PWREx_EnableVddIO2>

  /*IO attributes management functions */
  HAL_GPIO_ConfigPinAttributes(GPIOG, GPIO_PIN_7|GPIO_PIN_8, GPIO_PIN_NSEC);
 c001616:	2200      	movs	r2, #0
 c001618:	f44f 71c0 	mov.w	r1, #384	@ 0x180
 c00161c:	4804      	ldr	r0, [pc, #16]	@ (c001630 <MX_GPIO_Init+0x3c>)
 c00161e:	f003 f903 	bl	c004828 <HAL_GPIO_ConfigPinAttributes>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
 c001622:	bf00      	nop
 c001624:	3708      	adds	r7, #8
 c001626:	46bd      	mov	sp, r7
 c001628:	bd80      	pop	{r7, pc}
 c00162a:	bf00      	nop
 c00162c:	50021000 	.word	0x50021000
 c001630:	52021800 	.word	0x52021800

0c001634 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 c001634:	b480      	push	{r7}
 c001636:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
 c001638:	bf00      	nop
 c00163a:	e7fd      	b.n	c001638 <Error_Handler+0x4>

0c00163c <InvalidateICache>:
#define FLASH_TEST_DATA         0x1234567812345678ULL


//   helper function  top 
static inline void InvalidateICache(void)
{
 c00163c:	b480      	push	{r7}
 c00163e:	af00      	add	r7, sp, #0
    #if (__ICACHE_PRESENT == 1U)
    SCB->ICIALLU = 0UL;  // Invalidate entire I-Cache
    __DSB();
    __ISB();
    #endif
}
 c001640:	bf00      	nop
 c001642:	46bd      	mov	sp, r7
 c001644:	f85d 7b04 	ldr.w	r7, [sp], #4
 c001648:	4770      	bx	lr
	...

0c00164c <__acle_se_SECURE_RegisterPrintCallback>:
/* Private functions ---------------------------------------------------------*/



CMSE_NS_ENTRY void SECURE_RegisterPrintCallback(void *callback)
{
 c00164c:	b480      	push	{r7}
 c00164e:	b083      	sub	sp, #12
 c001650:	af00      	add	r7, sp, #0
 c001652:	6078      	str	r0, [r7, #4]
    ns_print_cb = (void (*)(const char *))cmse_nsfptr_create(callback);
 c001654:	687b      	ldr	r3, [r7, #4]
 c001656:	f023 0301 	bic.w	r3, r3, #1
 c00165a:	461a      	mov	r2, r3
 c00165c:	4b1d      	ldr	r3, [pc, #116]	@ (c0016d4 <__acle_se_SECURE_RegisterPrintCallback+0x88>)
 c00165e:	601a      	str	r2, [r3, #0]
}
 c001660:	bf00      	nop
 c001662:	370c      	adds	r7, #12
 c001664:	46bd      	mov	sp, r7
 c001666:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00166a:	4670      	mov	r0, lr
 c00166c:	4671      	mov	r1, lr
 c00166e:	4672      	mov	r2, lr
 c001670:	4673      	mov	r3, lr
 c001672:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001676:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00167a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00167e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001682:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001686:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00168a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00168e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001692:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001696:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00169a:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00169e:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0016a2:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0016a6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0016aa:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0016ae:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0016b2:	f38e 8c00 	msr	CPSR_fs, lr
 c0016b6:	b410      	push	{r4}
 c0016b8:	eef1 ca10 	vmrs	ip, fpscr
 c0016bc:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0016c0:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0016c4:	ea0c 0c04 	and.w	ip, ip, r4
 c0016c8:	eee1 ca10 	vmsr	fpscr, ip
 c0016cc:	bc10      	pop	{r4}
 c0016ce:	46f4      	mov	ip, lr
 c0016d0:	4774      	bxns	lr
 c0016d2:	bf00      	nop
 c0016d4:	300000c4 	.word	0x300000c4

0c0016d8 <__acle_se_SECURE_Print>:

CMSE_NS_ENTRY void SECURE_Print(const char *msg)
{
 c0016d8:	b580      	push	{r7, lr}
 c0016da:	b082      	sub	sp, #8
 c0016dc:	af00      	add	r7, sp, #0
 c0016de:	6078      	str	r0, [r7, #4]
    if (ns_print_cb)
 c0016e0:	4b20      	ldr	r3, [pc, #128]	@ (c001764 <__acle_se_SECURE_Print+0x8c>)
 c0016e2:	681b      	ldr	r3, [r3, #0]
 c0016e4:	2b00      	cmp	r3, #0
 c0016e6:	d003      	beq.n	c0016f0 <__acle_se_SECURE_Print+0x18>
    {
        ns_print_cb(msg);
 c0016e8:	4b1e      	ldr	r3, [pc, #120]	@ (c001764 <__acle_se_SECURE_Print+0x8c>)
 c0016ea:	681b      	ldr	r3, [r3, #0]
 c0016ec:	6878      	ldr	r0, [r7, #4]
 c0016ee:	4798      	blx	r3
    }
}
 c0016f0:	bf00      	nop
 c0016f2:	3708      	adds	r7, #8
 c0016f4:	46bd      	mov	sp, r7
 c0016f6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0016fa:	4670      	mov	r0, lr
 c0016fc:	4671      	mov	r1, lr
 c0016fe:	4672      	mov	r2, lr
 c001700:	4673      	mov	r3, lr
 c001702:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001706:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00170a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00170e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001712:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001716:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00171a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00171e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001722:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001726:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00172a:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00172e:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001732:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001736:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00173a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c00173e:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001742:	f38e 8c00 	msr	CPSR_fs, lr
 c001746:	b410      	push	{r4}
 c001748:	eef1 ca10 	vmrs	ip, fpscr
 c00174c:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001750:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001754:	ea0c 0c04 	and.w	ip, ip, r4
 c001758:	eee1 ca10 	vmsr	fpscr, ip
 c00175c:	bc10      	pop	{r4}
 c00175e:	46f4      	mov	ip, lr
 c001760:	4774      	bxns	lr
 c001762:	bf00      	nop
 c001764:	300000c4 	.word	0x300000c4

0c001768 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
 c001768:	b2c0      	uxtb	r0, r0
 c00176a:	b480      	push	{r7}
 c00176c:	b083      	sub	sp, #12
 c00176e:	af00      	add	r7, sp, #0
 c001770:	4603      	mov	r3, r0
 c001772:	6039      	str	r1, [r7, #0]
 c001774:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
 c001776:	683b      	ldr	r3, [r7, #0]
 c001778:	2b00      	cmp	r3, #0
 c00177a:	d00d      	beq.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
  {
    switch(CallbackId)
 c00177c:	79fb      	ldrb	r3, [r7, #7]
 c00177e:	2b00      	cmp	r3, #0
 c001780:	d002      	beq.n	c001788 <__acle_se_SECURE_RegisterCallback+0x20>
 c001782:	2b01      	cmp	r3, #1
 c001784:	d004      	beq.n	c001790 <__acle_se_SECURE_RegisterCallback+0x28>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
 c001786:	e007      	b.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
        pSecureFaultCallback = func;
 c001788:	4a20      	ldr	r2, [pc, #128]	@ (c00180c <__acle_se_SECURE_RegisterCallback+0xa4>)
 c00178a:	683b      	ldr	r3, [r7, #0]
 c00178c:	6013      	str	r3, [r2, #0]
        break;
 c00178e:	e003      	b.n	c001798 <__acle_se_SECURE_RegisterCallback+0x30>
        pSecureErrorCallback = func;
 c001790:	4a1f      	ldr	r2, [pc, #124]	@ (c001810 <__acle_se_SECURE_RegisterCallback+0xa8>)
 c001792:	683b      	ldr	r3, [r7, #0]
 c001794:	6013      	str	r3, [r2, #0]
        break;
 c001796:	bf00      	nop
    }
  }
}
 c001798:	bf00      	nop
 c00179a:	370c      	adds	r7, #12
 c00179c:	46bd      	mov	sp, r7
 c00179e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0017a2:	4670      	mov	r0, lr
 c0017a4:	4671      	mov	r1, lr
 c0017a6:	4672      	mov	r2, lr
 c0017a8:	4673      	mov	r3, lr
 c0017aa:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0017ae:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0017b2:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0017b6:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0017ba:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0017be:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0017c2:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0017c6:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0017ca:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0017ce:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0017d2:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0017d6:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0017da:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0017de:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0017e2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0017e6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0017ea:	f38e 8c00 	msr	CPSR_fs, lr
 c0017ee:	b410      	push	{r4}
 c0017f0:	eef1 ca10 	vmrs	ip, fpscr
 c0017f4:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0017f8:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0017fc:	ea0c 0c04 	and.w	ip, ip, r4
 c001800:	eee1 ca10 	vmsr	fpscr, ip
 c001804:	bc10      	pop	{r4}
 c001806:	46f4      	mov	ip, lr
 c001808:	4774      	bxns	lr
 c00180a:	bf00      	nop
 c00180c:	300000bc 	.word	0x300000bc
 c001810:	300000c0 	.word	0x300000c0

0c001814 <__acle_se_SECURE_LEDToggle>:
/**
  * @brief  Secure treatment of non-secure push button interrupt.
  * @retval None
  */
/*CMSE_NS_ENTRY*/secureportNON_SECURE_CALLABLE void SECURE_LEDToggle(void)
{
 c001814:	b580      	push	{r7, lr}
 c001816:	af00      	add	r7, sp, #0
  BSP_LED_Toggle(LED1);
 c001818:	2000      	movs	r0, #0
 c00181a:	f002 f82d 	bl	c003878 <BSP_LED_Toggle>
}
 c00181e:	bf00      	nop
 c001820:	46bd      	mov	sp, r7
 c001822:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c001826:	4670      	mov	r0, lr
 c001828:	4671      	mov	r1, lr
 c00182a:	4672      	mov	r2, lr
 c00182c:	4673      	mov	r3, lr
 c00182e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001832:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001836:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00183a:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00183e:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001842:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001846:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00184a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00184e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001852:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001856:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00185a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00185e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001862:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001866:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c00186a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00186e:	f38e 8c00 	msr	CPSR_fs, lr
 c001872:	b410      	push	{r4}
 c001874:	eef1 ca10 	vmrs	ip, fpscr
 c001878:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c00187c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001880:	ea0c 0c04 	and.w	ip, ip, r4
 c001884:	eee1 ca10 	vmsr	fpscr, ip
 c001888:	bc10      	pop	{r4}
 c00188a:	46f4      	mov	ip, lr
 c00188c:	4774      	bxns	lr
	...

0c001890 <__acle_se_SECURE_CopyMessage>:



__attribute__((cmse_nonsecure_entry))
void SECURE_CopyMessage(char* buffer, size_t maxlen)
{
 c001890:	b580      	push	{r7, lr}
 c001892:	b084      	sub	sp, #16
 c001894:	af00      	add	r7, sp, #0
 c001896:	6078      	str	r0, [r7, #4]
 c001898:	6039      	str	r1, [r7, #0]
    if (!buffer || maxlen == 0) return;
 c00189a:	687b      	ldr	r3, [r7, #4]
 c00189c:	2b00      	cmp	r3, #0
 c00189e:	d012      	beq.n	c0018c6 <__acle_se_SECURE_CopyMessage+0x36>
 c0018a0:	683b      	ldr	r3, [r7, #0]
 c0018a2:	2b00      	cmp	r3, #0
 c0018a4:	d00f      	beq.n	c0018c6 <__acle_se_SECURE_CopyMessage+0x36>
    const char* secure_msg = "AAA test in secure";
 c0018a6:	4b24      	ldr	r3, [pc, #144]	@ (c001938 <__acle_se_SECURE_CopyMessage+0xa8>)
 c0018a8:	60fb      	str	r3, [r7, #12]
    strncpy(buffer, secure_msg, maxlen - 1);
 c0018aa:	683b      	ldr	r3, [r7, #0]
 c0018ac:	3b01      	subs	r3, #1
 c0018ae:	461a      	mov	r2, r3
 c0018b0:	68f9      	ldr	r1, [r7, #12]
 c0018b2:	6878      	ldr	r0, [r7, #4]
 c0018b4:	f004 f8f0 	bl	c005a98 <strncpy>
    buffer[maxlen - 1] = '\0';
 c0018b8:	683b      	ldr	r3, [r7, #0]
 c0018ba:	3b01      	subs	r3, #1
 c0018bc:	687a      	ldr	r2, [r7, #4]
 c0018be:	4413      	add	r3, r2
 c0018c0:	2200      	movs	r2, #0
 c0018c2:	701a      	strb	r2, [r3, #0]
 c0018c4:	e000      	b.n	c0018c8 <__acle_se_SECURE_CopyMessage+0x38>
    if (!buffer || maxlen == 0) return;
 c0018c6:	bf00      	nop
}
 c0018c8:	3710      	adds	r7, #16
 c0018ca:	46bd      	mov	sp, r7
 c0018cc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0018d0:	4670      	mov	r0, lr
 c0018d2:	4671      	mov	r1, lr
 c0018d4:	4672      	mov	r2, lr
 c0018d6:	4673      	mov	r3, lr
 c0018d8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0018dc:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0018e0:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0018e4:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0018e8:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0018ec:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0018f0:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0018f4:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0018f8:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0018fc:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001900:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001904:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001908:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00190c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001910:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001914:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001918:	f38e 8c00 	msr	CPSR_fs, lr
 c00191c:	b410      	push	{r4}
 c00191e:	eef1 ca10 	vmrs	ip, fpscr
 c001922:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001926:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00192a:	ea0c 0c04 	and.w	ip, ip, r4
 c00192e:	eee1 ca10 	vmsr	fpscr, ip
 c001932:	bc10      	pop	{r4}
 c001934:	46f4      	mov	ip, lr
 c001936:	4774      	bxns	lr
 c001938:	0c0066a8 	.word	0x0c0066a8

0c00193c <__acle_se_SECURE_ComputeHMAC>:
static uint8_t secure_digest[SHA256_DIGEST_SIZE];


__attribute__((cmse_nonsecure_entry))
void SECURE_ComputeHMAC(uint8_t *output_digest, size_t maxlen)
{
 c00193c:	b5b0      	push	{r4, r5, r7, lr}
 c00193e:	b08c      	sub	sp, #48	@ 0x30
 c001940:	af00      	add	r7, sp, #0
 c001942:	6078      	str	r0, [r7, #4]
 c001944:	6039      	str	r1, [r7, #0]

    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001946:	687b      	ldr	r3, [r7, #4]
 c001948:	2b00      	cmp	r3, #0
 c00194a:	d047      	beq.n	c0019dc <__acle_se_SECURE_ComputeHMAC+0xa0>
 c00194c:	683b      	ldr	r3, [r7, #0]
 c00194e:	2b1f      	cmp	r3, #31
 c001950:	d944      	bls.n	c0019dc <__acle_se_SECURE_ComputeHMAC+0xa0>
  __ASM volatile ("cpsid i" : : : "memory");
 c001952:	b672      	cpsid	i
}
 c001954:	bf00      	nop

    __disable_irq();

    for (volatile uint32_t i = 0; i < 10000000; i++);
 c001956:	2300      	movs	r3, #0
 c001958:	60fb      	str	r3, [r7, #12]
 c00195a:	e002      	b.n	c001962 <__acle_se_SECURE_ComputeHMAC+0x26>
 c00195c:	68fb      	ldr	r3, [r7, #12]
 c00195e:	3301      	adds	r3, #1
 c001960:	60fb      	str	r3, [r7, #12]
 c001962:	68fb      	ldr	r3, [r7, #12]
 c001964:	4a3a      	ldr	r2, [pc, #232]	@ (c001a50 <__acle_se_SECURE_ComputeHMAC+0x114>)
 c001966:	4293      	cmp	r3, r2
 c001968:	d3f8      	bcc.n	c00195c <__acle_se_SECURE_ComputeHMAC+0x20>
  __ASM volatile ("cpsie i" : : : "memory");
 c00196a:	b662      	cpsie	i
}
 c00196c:	bf00      	nop
	__enable_irq();

    const uint8_t message[] = "Temp Temp from Secure World!";
 c00196e:	4b39      	ldr	r3, [pc, #228]	@ (c001a54 <__acle_se_SECURE_ComputeHMAC+0x118>)
 c001970:	f107 0410 	add.w	r4, r7, #16
 c001974:	461d      	mov	r5, r3
 c001976:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001978:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c00197a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c00197e:	c407      	stmia	r4!, {r0, r1, r2}
 c001980:	7023      	strb	r3, [r4, #0]

    hmac_sha256_initialize(&secure_hmac_ctx, secure_key, strlen((const char*)secure_key));
 c001982:	220b      	movs	r2, #11
 c001984:	4934      	ldr	r1, [pc, #208]	@ (c001a58 <__acle_se_SECURE_ComputeHMAC+0x11c>)
 c001986:	4835      	ldr	r0, [pc, #212]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c001988:	f7ff fbc0 	bl	c00110c <hmac_sha256_initialize>
//    hmac_sha256_update(&secure_hmac_ctx, message, strlen((const char*)message));
    hmac_sha256_finalize(&secure_hmac_ctx, NULL, 0);
 c00198c:	2200      	movs	r2, #0
 c00198e:	2100      	movs	r1, #0
 c001990:	4832      	ldr	r0, [pc, #200]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c001992:	f7ff fc3c 	bl	c00120e <hmac_sha256_finalize>

    for (volatile uint32_t i = 0; i < 10000000; i++);
 c001996:	2300      	movs	r3, #0
 c001998:	60bb      	str	r3, [r7, #8]
 c00199a:	e002      	b.n	c0019a2 <__acle_se_SECURE_ComputeHMAC+0x66>
 c00199c:	68bb      	ldr	r3, [r7, #8]
 c00199e:	3301      	adds	r3, #1
 c0019a0:	60bb      	str	r3, [r7, #8]
 c0019a2:	68bb      	ldr	r3, [r7, #8]
 c0019a4:	4a2a      	ldr	r2, [pc, #168]	@ (c001a50 <__acle_se_SECURE_ComputeHMAC+0x114>)
 c0019a6:	4293      	cmp	r3, r2
 c0019a8:	d3f8      	bcc.n	c00199c <__acle_se_SECURE_ComputeHMAC+0x60>

    memcpy(secure_digest, secure_hmac_ctx.digest, SHA256_DIGEST_SIZE);
 c0019aa:	4a2d      	ldr	r2, [pc, #180]	@ (c001a60 <__acle_se_SECURE_ComputeHMAC+0x124>)
 c0019ac:	4b2b      	ldr	r3, [pc, #172]	@ (c001a5c <__acle_se_SECURE_ComputeHMAC+0x120>)
 c0019ae:	4614      	mov	r4, r2
 c0019b0:	461d      	mov	r5, r3
 c0019b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0019b6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c0019ba:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}


	memcpy(output_digest, secure_digest, SHA256_DIGEST_SIZE);
 c0019be:	687b      	ldr	r3, [r7, #4]
 c0019c0:	4a27      	ldr	r2, [pc, #156]	@ (c001a60 <__acle_se_SECURE_ComputeHMAC+0x124>)
 c0019c2:	461c      	mov	r4, r3
 c0019c4:	4615      	mov	r5, r2
 c0019c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019c8:	6020      	str	r0, [r4, #0]
 c0019ca:	6061      	str	r1, [r4, #4]
 c0019cc:	60a2      	str	r2, [r4, #8]
 c0019ce:	60e3      	str	r3, [r4, #12]
 c0019d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0019d2:	6120      	str	r0, [r4, #16]
 c0019d4:	6161      	str	r1, [r4, #20]
 c0019d6:	61a2      	str	r2, [r4, #24]
 c0019d8:	61e3      	str	r3, [r4, #28]
 c0019da:	e000      	b.n	c0019de <__acle_se_SECURE_ComputeHMAC+0xa2>
    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c0019dc:	bf00      	nop


}
 c0019de:	3730      	adds	r7, #48	@ 0x30
 c0019e0:	46bd      	mov	sp, r7
 c0019e2:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c0019e6:	4670      	mov	r0, lr
 c0019e8:	4671      	mov	r1, lr
 c0019ea:	4672      	mov	r2, lr
 c0019ec:	4673      	mov	r3, lr
 c0019ee:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0019f2:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0019f6:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0019fa:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0019fe:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001a02:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001a06:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001a0a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001a0e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001a12:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001a16:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001a1a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001a1e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001a22:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001a26:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001a2a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001a2e:	f38e 8c00 	msr	CPSR_fs, lr
 c001a32:	b410      	push	{r4}
 c001a34:	eef1 ca10 	vmrs	ip, fpscr
 c001a38:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001a3c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001a40:	ea0c 0c04 	and.w	ip, ip, r4
 c001a44:	eee1 ca10 	vmsr	fpscr, ip
 c001a48:	bc10      	pop	{r4}
 c001a4a:	46f4      	mov	ip, lr
 c001a4c:	4774      	bxns	lr
 c001a4e:	bf00      	nop
 c001a50:	00989680 	.word	0x00989680
 c001a54:	0c0066bc 	.word	0x0c0066bc
 c001a58:	0c006c40 	.word	0x0c006c40
 c001a5c:	300000c8 	.word	0x300000c8
 c001a60:	300001b0 	.word	0x300001b0

0c001a64 <__acle_se_SECURE_LinearHMAC>:



__attribute__((cmse_nonsecure_entry))
void SECURE_LinearHMAC(uint8_t *output_digest, size_t maxlen)
{
 c001a64:	b5b0      	push	{r4, r5, r7, lr}
 c001a66:	b086      	sub	sp, #24
 c001a68:	af00      	add	r7, sp, #0
 c001a6a:	6078      	str	r0, [r7, #4]
 c001a6c:	6039      	str	r1, [r7, #0]


//    __disable_irq();
    if (!output_digest || maxlen < SHA256_DIGEST_SIZE) {
 c001a6e:	687b      	ldr	r3, [r7, #4]
 c001a70:	2b00      	cmp	r3, #0
 c001a72:	d002      	beq.n	c001a7a <__acle_se_SECURE_LinearHMAC+0x16>
 c001a74:	683b      	ldr	r3, [r7, #0]
 c001a76:	2b1f      	cmp	r3, #31
 c001a78:	d802      	bhi.n	c001a80 <__acle_se_SECURE_LinearHMAC+0x1c>
  __ASM volatile ("cpsie i" : : : "memory");
 c001a7a:	b662      	cpsie	i
}
 c001a7c:	bf00      	nop
        __enable_irq();
        return;
 c001a7e:	e03f      	b.n	c001b00 <__acle_se_SECURE_LinearHMAC+0x9c>
    }

    // Optional: Fill real_memory with known data for consistent testing
    for (int i = 0; i < TOTAL_SIZE; i++) {
 c001a80:	2300      	movs	r3, #0
 c001a82:	617b      	str	r3, [r7, #20]
 c001a84:	e009      	b.n	c001a9a <__acle_se_SECURE_LinearHMAC+0x36>
        real_memory[i] = i & 0xFF;  // test pattern
 c001a86:	4b3a      	ldr	r3, [pc, #232]	@ (c001b70 <__acle_se_SECURE_LinearHMAC+0x10c>)
 c001a88:	681a      	ldr	r2, [r3, #0]
 c001a8a:	697b      	ldr	r3, [r7, #20]
 c001a8c:	4413      	add	r3, r2
 c001a8e:	697a      	ldr	r2, [r7, #20]
 c001a90:	b2d2      	uxtb	r2, r2
 c001a92:	701a      	strb	r2, [r3, #0]
    for (int i = 0; i < TOTAL_SIZE; i++) {
 c001a94:	697b      	ldr	r3, [r7, #20]
 c001a96:	3301      	adds	r3, #1
 c001a98:	617b      	str	r3, [r7, #20]
 c001a9a:	697b      	ldr	r3, [r7, #20]
 c001a9c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 c001aa0:	dbf1      	blt.n	c001a86 <__acle_se_SECURE_LinearHMAC+0x22>
    }

//    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
    hmac_sha256_initialize(&hmac, key, sizeof(key));
 c001aa2:	220f      	movs	r2, #15
 c001aa4:	4933      	ldr	r1, [pc, #204]	@ (c001b74 <__acle_se_SECURE_LinearHMAC+0x110>)
 c001aa6:	4834      	ldr	r0, [pc, #208]	@ (c001b78 <__acle_se_SECURE_LinearHMAC+0x114>)
 c001aa8:	f7ff fb30 	bl	c00110c <hmac_sha256_initialize>


    // Process blocks sequentially (not shuffled)
    for (int i = 0; i < BLOCKS; i++) {
 c001aac:	2300      	movs	r3, #0
 c001aae:	613b      	str	r3, [r7, #16]
 c001ab0:	e00e      	b.n	c001ad0 <__acle_se_SECURE_LinearHMAC+0x6c>
        const uint8_t *block = &real_memory[i * BLOCK_SIZE];
 c001ab2:	4b2f      	ldr	r3, [pc, #188]	@ (c001b70 <__acle_se_SECURE_LinearHMAC+0x10c>)
 c001ab4:	681b      	ldr	r3, [r3, #0]
 c001ab6:	693a      	ldr	r2, [r7, #16]
 c001ab8:	0292      	lsls	r2, r2, #10
 c001aba:	4413      	add	r3, r2
 c001abc:	60fb      	str	r3, [r7, #12]
        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c001abe:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c001ac2:	68f9      	ldr	r1, [r7, #12]
 c001ac4:	482c      	ldr	r0, [pc, #176]	@ (c001b78 <__acle_se_SECURE_LinearHMAC+0x114>)
 c001ac6:	f7ff fb91 	bl	c0011ec <hmac_sha256_update>
    for (int i = 0; i < BLOCKS; i++) {
 c001aca:	693b      	ldr	r3, [r7, #16]
 c001acc:	3301      	adds	r3, #1
 c001ace:	613b      	str	r3, [r7, #16]
 c001ad0:	693b      	ldr	r3, [r7, #16]
 c001ad2:	2bff      	cmp	r3, #255	@ 0xff
 c001ad4:	dded      	ble.n	c001ab2 <__acle_se_SECURE_LinearHMAC+0x4e>
    }

    hmac_sha256_finalize(&hmac, NULL, 0);
 c001ad6:	2200      	movs	r2, #0
 c001ad8:	2100      	movs	r1, #0
 c001ada:	4827      	ldr	r0, [pc, #156]	@ (c001b78 <__acle_se_SECURE_LinearHMAC+0x114>)
 c001adc:	f7ff fb97 	bl	c00120e <hmac_sha256_finalize>
    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c001ae0:	687b      	ldr	r3, [r7, #4]
 c001ae2:	4a25      	ldr	r2, [pc, #148]	@ (c001b78 <__acle_se_SECURE_LinearHMAC+0x114>)
 c001ae4:	461c      	mov	r4, r3
 c001ae6:	4615      	mov	r5, r2
 c001ae8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001aea:	6020      	str	r0, [r4, #0]
 c001aec:	6061      	str	r1, [r4, #4]
 c001aee:	60a2      	str	r2, [r4, #8]
 c001af0:	60e3      	str	r3, [r4, #12]
 c001af2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001af4:	6120      	str	r0, [r4, #16]
 c001af6:	6161      	str	r1, [r4, #20]
 c001af8:	61a2      	str	r2, [r4, #24]
 c001afa:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("cpsie i" : : : "memory");
 c001afc:	b662      	cpsie	i
}
 c001afe:	bf00      	nop


    __enable_irq();
}
 c001b00:	3718      	adds	r7, #24
 c001b02:	46bd      	mov	sp, r7
 c001b04:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c001b08:	4670      	mov	r0, lr
 c001b0a:	4671      	mov	r1, lr
 c001b0c:	4672      	mov	r2, lr
 c001b0e:	4673      	mov	r3, lr
 c001b10:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001b14:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001b18:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001b1c:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001b20:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001b24:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001b28:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001b2c:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001b30:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001b34:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001b38:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001b3c:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001b40:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001b44:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001b48:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001b4c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001b50:	f38e 8c00 	msr	CPSR_fs, lr
 c001b54:	b410      	push	{r4}
 c001b56:	eef1 ca10 	vmrs	ip, fpscr
 c001b5a:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001b5e:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001b62:	ea0c 0c04 	and.w	ip, ip, r4
 c001b66:	eee1 ca10 	vmsr	fpscr, ip
 c001b6a:	bc10      	pop	{r4}
 c001b6c:	46f4      	mov	ip, lr
 c001b6e:	4774      	bxns	lr
 c001b70:	30000000 	.word	0x30000000
 c001b74:	0c006c4c 	.word	0x0c006c4c
 c001b78:	300001d0 	.word	0x300001d0

0c001b7c <__acle_se_SECURE_ShuffledHMAC>:



__attribute__((cmse_nonsecure_entry))
void SECURE_ShuffledHMAC(uint8_t *output_digest, size_t maxlen)
{
 c001b7c:	b5b0      	push	{r4, r5, r7, lr}
 c001b7e:	b088      	sub	sp, #32
 c001b80:	af00      	add	r7, sp, #0
 c001b82:	6078      	str	r0, [r7, #4]
 c001b84:	6039      	str	r1, [r7, #0]

	  if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001b86:	687b      	ldr	r3, [r7, #4]
 c001b88:	2b00      	cmp	r3, #0
 c001b8a:	d06a      	beq.n	c001c62 <__acle_se_SECURE_ShuffledHMAC+0xe6>
 c001b8c:	683b      	ldr	r3, [r7, #0]
 c001b8e:	2b1f      	cmp	r3, #31
 c001b90:	d967      	bls.n	c001c62 <__acle_se_SECURE_ShuffledHMAC+0xe6>

	    static int indices[BLOCKS];
	    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c001b92:	2300      	movs	r3, #0
 c001b94:	61fb      	str	r3, [r7, #28]
 c001b96:	e007      	b.n	c001ba8 <__acle_se_SECURE_ShuffledHMAC+0x2c>
 c001b98:	494e      	ldr	r1, [pc, #312]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001b9a:	69fb      	ldr	r3, [r7, #28]
 c001b9c:	69fa      	ldr	r2, [r7, #28]
 c001b9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 c001ba2:	69fb      	ldr	r3, [r7, #28]
 c001ba4:	3301      	adds	r3, #1
 c001ba6:	61fb      	str	r3, [r7, #28]
 c001ba8:	69fb      	ldr	r3, [r7, #28]
 c001baa:	2bff      	cmp	r3, #255	@ 0xff
 c001bac:	ddf4      	ble.n	c001b98 <__acle_se_SECURE_ShuffledHMAC+0x1c>
	    // Simple shuffle without srand for now


	      srand(42);
 c001bae:	202a      	movs	r0, #42	@ 0x2a
 c001bb0:	f003 fcf4 	bl	c00559c <srand>

	      for (int i = BLOCKS - 1; i > 0; i--) {
 c001bb4:	23ff      	movs	r3, #255	@ 0xff
 c001bb6:	61bb      	str	r3, [r7, #24]
 c001bb8:	e01f      	b.n	c001bfa <__acle_se_SECURE_ShuffledHMAC+0x7e>
	          int j = rand() % (i + 1);
 c001bba:	f003 fd1d 	bl	c0055f8 <rand>
 c001bbe:	4602      	mov	r2, r0
 c001bc0:	69bb      	ldr	r3, [r7, #24]
 c001bc2:	3301      	adds	r3, #1
 c001bc4:	fb92 f1f3 	sdiv	r1, r2, r3
 c001bc8:	fb01 f303 	mul.w	r3, r1, r3
 c001bcc:	1ad3      	subs	r3, r2, r3
 c001bce:	60fb      	str	r3, [r7, #12]
	          int tmp = indices[i];
 c001bd0:	4a40      	ldr	r2, [pc, #256]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bd2:	69bb      	ldr	r3, [r7, #24]
 c001bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c001bd8:	60bb      	str	r3, [r7, #8]
	          indices[i] = indices[j];
 c001bda:	4a3e      	ldr	r2, [pc, #248]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bdc:	68fb      	ldr	r3, [r7, #12]
 c001bde:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 c001be2:	493c      	ldr	r1, [pc, #240]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001be4:	69bb      	ldr	r3, [r7, #24]
 c001be6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	          indices[j] = tmp;
 c001bea:	493a      	ldr	r1, [pc, #232]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001bec:	68fb      	ldr	r3, [r7, #12]
 c001bee:	68ba      	ldr	r2, [r7, #8]
 c001bf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	      for (int i = BLOCKS - 1; i > 0; i--) {
 c001bf4:	69bb      	ldr	r3, [r7, #24]
 c001bf6:	3b01      	subs	r3, #1
 c001bf8:	61bb      	str	r3, [r7, #24]
 c001bfa:	69bb      	ldr	r3, [r7, #24]
 c001bfc:	2b00      	cmp	r3, #0
 c001bfe:	dcdc      	bgt.n	c001bba <__acle_se_SECURE_ShuffledHMAC+0x3e>
	      }

	    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
 c001c00:	220e      	movs	r2, #14
 c001c02:	4935      	ldr	r1, [pc, #212]	@ (c001cd8 <__acle_se_SECURE_ShuffledHMAC+0x15c>)
 c001c04:	4835      	ldr	r0, [pc, #212]	@ (c001cdc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c06:	f7ff fa81 	bl	c00110c <hmac_sha256_initialize>
	    for (int i = 0; i < BLOCKS; i++) {
 c001c0a:	2300      	movs	r3, #0
 c001c0c:	617b      	str	r3, [r7, #20]
 c001c0e:	e011      	b.n	c001c34 <__acle_se_SECURE_ShuffledHMAC+0xb8>
	        const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c001c10:	4b33      	ldr	r3, [pc, #204]	@ (c001ce0 <__acle_se_SECURE_ShuffledHMAC+0x164>)
 c001c12:	681b      	ldr	r3, [r3, #0]
 c001c14:	492f      	ldr	r1, [pc, #188]	@ (c001cd4 <__acle_se_SECURE_ShuffledHMAC+0x158>)
 c001c16:	697a      	ldr	r2, [r7, #20]
 c001c18:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c001c1c:	0292      	lsls	r2, r2, #10
 c001c1e:	4413      	add	r3, r2
 c001c20:	613b      	str	r3, [r7, #16]
//	        __disable_irq();
	        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c001c22:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c001c26:	6939      	ldr	r1, [r7, #16]
 c001c28:	482c      	ldr	r0, [pc, #176]	@ (c001cdc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c2a:	f7ff fadf 	bl	c0011ec <hmac_sha256_update>
	    for (int i = 0; i < BLOCKS; i++) {
 c001c2e:	697b      	ldr	r3, [r7, #20]
 c001c30:	3301      	adds	r3, #1
 c001c32:	617b      	str	r3, [r7, #20]
 c001c34:	697b      	ldr	r3, [r7, #20]
 c001c36:	2bff      	cmp	r3, #255	@ 0xff
 c001c38:	ddea      	ble.n	c001c10 <__acle_se_SECURE_ShuffledHMAC+0x94>
//	        __enable_irq();
	    }
	    hmac_sha256_finalize(&hmac, NULL, 0);
 c001c3a:	2200      	movs	r2, #0
 c001c3c:	2100      	movs	r1, #0
 c001c3e:	4827      	ldr	r0, [pc, #156]	@ (c001cdc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c40:	f7ff fae5 	bl	c00120e <hmac_sha256_finalize>
	    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c001c44:	687b      	ldr	r3, [r7, #4]
 c001c46:	4a25      	ldr	r2, [pc, #148]	@ (c001cdc <__acle_se_SECURE_ShuffledHMAC+0x160>)
 c001c48:	461c      	mov	r4, r3
 c001c4a:	4615      	mov	r5, r2
 c001c4c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001c4e:	6020      	str	r0, [r4, #0]
 c001c50:	6061      	str	r1, [r4, #4]
 c001c52:	60a2      	str	r2, [r4, #8]
 c001c54:	60e3      	str	r3, [r4, #12]
 c001c56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c001c58:	6120      	str	r0, [r4, #16]
 c001c5a:	6161      	str	r1, [r4, #20]
 c001c5c:	61a2      	str	r2, [r4, #24]
 c001c5e:	61e3      	str	r3, [r4, #28]
 c001c60:	e000      	b.n	c001c64 <__acle_se_SECURE_ShuffledHMAC+0xe8>
	  if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c001c62:	bf00      	nop



}
 c001c64:	3720      	adds	r7, #32
 c001c66:	46bd      	mov	sp, r7
 c001c68:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c001c6c:	4670      	mov	r0, lr
 c001c6e:	4671      	mov	r1, lr
 c001c70:	4672      	mov	r2, lr
 c001c72:	4673      	mov	r3, lr
 c001c74:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c001c78:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c001c7c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c001c80:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c001c84:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c001c88:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c001c8c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c001c90:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c001c94:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c001c98:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c001c9c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c001ca0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c001ca4:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c001ca8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c001cac:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c001cb0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c001cb4:	f38e 8c00 	msr	CPSR_fs, lr
 c001cb8:	b410      	push	{r4}
 c001cba:	eef1 ca10 	vmrs	ip, fpscr
 c001cbe:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c001cc2:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c001cc6:	ea0c 0c04 	and.w	ip, ip, r4
 c001cca:	eee1 ca10 	vmsr	fpscr, ip
 c001cce:	bc10      	pop	{r4}
 c001cd0:	46f4      	mov	ip, lr
 c001cd2:	4774      	bxns	lr
 c001cd4:	300002b8 	.word	0x300002b8
 c001cd8:	0c006c4c 	.word	0x0c006c4c
 c001cdc:	300001d0 	.word	0x300001d0
 c001ce0:	30000000 	.word	0x30000000

0c001ce4 <derive_aes_key_iv_from_challenge>:
// ---- Key/IV derivation: HMAC(secret, challenge) -> 32B -> 16B key + 16B iv
static void derive_aes_key_iv_from_challenge(uint8_t key16[16],
                                             uint8_t iv16[16],
                                             const uint8_t *challenge,
                                             size_t clen)
{
 c001ce4:	b580      	push	{r7, lr}
 c001ce6:	b086      	sub	sp, #24
 c001ce8:	af00      	add	r7, sp, #0
 c001cea:	60f8      	str	r0, [r7, #12]
 c001cec:	60b9      	str	r1, [r7, #8]
 c001cee:	607a      	str	r2, [r7, #4]
 c001cf0:	603b      	str	r3, [r7, #0]
    hmac_sha256_initialize(&hmac, (const uint8_t*)key, strlen(key));
 c001cf2:	220e      	movs	r2, #14
 c001cf4:	4917      	ldr	r1, [pc, #92]	@ (c001d54 <derive_aes_key_iv_from_challenge+0x70>)
 c001cf6:	4818      	ldr	r0, [pc, #96]	@ (c001d58 <derive_aes_key_iv_from_challenge+0x74>)
 c001cf8:	f7ff fa08 	bl	c00110c <hmac_sha256_initialize>
    if (challenge && clen) {
 c001cfc:	687b      	ldr	r3, [r7, #4]
 c001cfe:	2b00      	cmp	r3, #0
 c001d00:	d009      	beq.n	c001d16 <derive_aes_key_iv_from_challenge+0x32>
 c001d02:	683b      	ldr	r3, [r7, #0]
 c001d04:	2b00      	cmp	r3, #0
 c001d06:	d006      	beq.n	c001d16 <derive_aes_key_iv_from_challenge+0x32>
        hmac_sha256_update(&hmac, challenge, clen);
 c001d08:	683b      	ldr	r3, [r7, #0]
 c001d0a:	461a      	mov	r2, r3
 c001d0c:	6879      	ldr	r1, [r7, #4]
 c001d0e:	4812      	ldr	r0, [pc, #72]	@ (c001d58 <derive_aes_key_iv_from_challenge+0x74>)
 c001d10:	f7ff fa6c 	bl	c0011ec <hmac_sha256_update>
 c001d14:	e009      	b.n	c001d2a <derive_aes_key_iv_from_challenge+0x46>
    } else {
        // fallback entropy so its never constant
        uint32_t tick = (uint32_t)SysTick->VAL;
 c001d16:	4b11      	ldr	r3, [pc, #68]	@ (c001d5c <derive_aes_key_iv_from_challenge+0x78>)
 c001d18:	689b      	ldr	r3, [r3, #8]
 c001d1a:	617b      	str	r3, [r7, #20]
        hmac_sha256_update(&hmac, (uint8_t*)&tick, sizeof(tick));
 c001d1c:	f107 0314 	add.w	r3, r7, #20
 c001d20:	2204      	movs	r2, #4
 c001d22:	4619      	mov	r1, r3
 c001d24:	480c      	ldr	r0, [pc, #48]	@ (c001d58 <derive_aes_key_iv_from_challenge+0x74>)
 c001d26:	f7ff fa61 	bl	c0011ec <hmac_sha256_update>
    }
    hmac_sha256_finalize(&hmac, NULL, 0);
 c001d2a:	2200      	movs	r2, #0
 c001d2c:	2100      	movs	r1, #0
 c001d2e:	480a      	ldr	r0, [pc, #40]	@ (c001d58 <derive_aes_key_iv_from_challenge+0x74>)
 c001d30:	f7ff fa6d 	bl	c00120e <hmac_sha256_finalize>
    memcpy(key16, hmac.digest, 16);
 c001d34:	2210      	movs	r2, #16
 c001d36:	4908      	ldr	r1, [pc, #32]	@ (c001d58 <derive_aes_key_iv_from_challenge+0x74>)
 c001d38:	68f8      	ldr	r0, [r7, #12]
 c001d3a:	f003 ff44 	bl	c005bc6 <memcpy>
    memcpy(iv16,  hmac.digest + 16, 16);
 c001d3e:	4b08      	ldr	r3, [pc, #32]	@ (c001d60 <derive_aes_key_iv_from_challenge+0x7c>)
 c001d40:	2210      	movs	r2, #16
 c001d42:	4619      	mov	r1, r3
 c001d44:	68b8      	ldr	r0, [r7, #8]
 c001d46:	f003 ff3e 	bl	c005bc6 <memcpy>
}
 c001d4a:	bf00      	nop
 c001d4c:	3718      	adds	r7, #24
 c001d4e:	46bd      	mov	sp, r7
 c001d50:	bd80      	pop	{r7, pc}
 c001d52:	bf00      	nop
 c001d54:	0c006c4c 	.word	0x0c006c4c
 c001d58:	300001d0 	.word	0x300001d0
 c001d5c:	e000e010 	.word	0xe000e010
 c001d60:	300001e0 	.word	0x300001e0

0c001d64 <prng_init>:
    uint8_t  buf[16];
    int      idx;   // next unread byte in buf (0..16)
} ctr_prng_t;

static void prng_init(ctr_prng_t *p, const uint8_t key16[16], const uint8_t iv16[16])
{
 c001d64:	b580      	push	{r7, lr}
 c001d66:	b084      	sub	sp, #16
 c001d68:	af00      	add	r7, sp, #0
 c001d6a:	60f8      	str	r0, [r7, #12]
 c001d6c:	60b9      	str	r1, [r7, #8]
 c001d6e:	607a      	str	r2, [r7, #4]
    AES_init_ctx_iv(&p->ctx, key16, iv16);
 c001d70:	68fb      	ldr	r3, [r7, #12]
 c001d72:	687a      	ldr	r2, [r7, #4]
 c001d74:	68b9      	ldr	r1, [r7, #8]
 c001d76:	4618      	mov	r0, r3
 c001d78:	f7fe fb8e 	bl	c000498 <AES_init_ctx_iv>
    memset(p->buf, 0, sizeof(p->buf));
 c001d7c:	68fb      	ldr	r3, [r7, #12]
 c001d7e:	33c0      	adds	r3, #192	@ 0xc0
 c001d80:	2210      	movs	r2, #16
 c001d82:	2100      	movs	r1, #0
 c001d84:	4618      	mov	r0, r3
 c001d86:	f003 fe7f 	bl	c005a88 <memset>
    p->idx = 16; // force refill on first use
 c001d8a:	68fb      	ldr	r3, [r7, #12]
 c001d8c:	2210      	movs	r2, #16
 c001d8e:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
 c001d92:	bf00      	nop
 c001d94:	3710      	adds	r7, #16
 c001d96:	46bd      	mov	sp, r7
 c001d98:	bd80      	pop	{r7, pc}

0c001d9a <prng_refill_block>:

static void prng_refill_block(ctr_prng_t *p)
{
 c001d9a:	b5b0      	push	{r4, r5, r7, lr}
 c001d9c:	b086      	sub	sp, #24
 c001d9e:	af00      	add	r7, sp, #0
 c001da0:	6078      	str	r0, [r7, #4]
    // encrypt zero block  keystream, tiny-AES increments IV internally
    uint8_t zero[16] = {0};
 c001da2:	f107 0308 	add.w	r3, r7, #8
 c001da6:	2200      	movs	r2, #0
 c001da8:	601a      	str	r2, [r3, #0]
 c001daa:	605a      	str	r2, [r3, #4]
 c001dac:	609a      	str	r2, [r3, #8]
 c001dae:	60da      	str	r2, [r3, #12]
    memcpy(p->buf, zero, 16);
 c001db0:	687b      	ldr	r3, [r7, #4]
 c001db2:	33c0      	adds	r3, #192	@ 0xc0
 c001db4:	461d      	mov	r5, r3
 c001db6:	f107 0408 	add.w	r4, r7, #8
 c001dba:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 c001dbc:	6028      	str	r0, [r5, #0]
 c001dbe:	6069      	str	r1, [r5, #4]
 c001dc0:	60aa      	str	r2, [r5, #8]
 c001dc2:	60eb      	str	r3, [r5, #12]
    AES_CTR_xcrypt_buffer(&p->ctx, p->buf, 16); // p->ctx.Iv auto-increments
 c001dc4:	6878      	ldr	r0, [r7, #4]
 c001dc6:	687b      	ldr	r3, [r7, #4]
 c001dc8:	33c0      	adds	r3, #192	@ 0xc0
 c001dca:	2210      	movs	r2, #16
 c001dcc:	4619      	mov	r1, r3
 c001dce:	f7fe fd2b 	bl	c000828 <AES_CTR_xcrypt_buffer>
    p->idx = 0;
 c001dd2:	687b      	ldr	r3, [r7, #4]
 c001dd4:	2200      	movs	r2, #0
 c001dd6:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
 c001dda:	bf00      	nop
 c001ddc:	3718      	adds	r7, #24
 c001dde:	46bd      	mov	sp, r7
 c001de0:	bdb0      	pop	{r4, r5, r7, pc}

0c001de2 <prng_next_u32>:

static uint32_t prng_next_u32(ctr_prng_t *p)
{
 c001de2:	b580      	push	{r7, lr}
 c001de4:	b084      	sub	sp, #16
 c001de6:	af00      	add	r7, sp, #0
 c001de8:	6078      	str	r0, [r7, #4]
    if (p->idx > 12) {           // not enough bytes left  refill
 c001dea:	687b      	ldr	r3, [r7, #4]
 c001dec:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001df0:	2b0c      	cmp	r3, #12
 c001df2:	dd02      	ble.n	c001dfa <prng_next_u32+0x18>
        prng_refill_block(p);
 c001df4:	6878      	ldr	r0, [r7, #4]
 c001df6:	f7ff ffd0 	bl	c001d9a <prng_refill_block>
    }
    uint32_t v;
    memcpy(&v, &p->buf[p->idx], 4);
 c001dfa:	687b      	ldr	r3, [r7, #4]
 c001dfc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001e00:	33c0      	adds	r3, #192	@ 0xc0
 c001e02:	687a      	ldr	r2, [r7, #4]
 c001e04:	4413      	add	r3, r2
 c001e06:	681b      	ldr	r3, [r3, #0]
 c001e08:	60fb      	str	r3, [r7, #12]
    p->idx += 4;
 c001e0a:	687b      	ldr	r3, [r7, #4]
 c001e0c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
 c001e10:	1d1a      	adds	r2, r3, #4
 c001e12:	687b      	ldr	r3, [r7, #4]
 c001e14:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
    return v;
 c001e18:	68fb      	ldr	r3, [r7, #12]
}
 c001e1a:	4618      	mov	r0, r3
 c001e1c:	3710      	adds	r7, #16
 c001e1e:	46bd      	mov	sp, r7
 c001e20:	bd80      	pop	{r7, pc}

0c001e22 <prng_uniform_u32>:

// unbiased integer in [0, n)
static int prng_uniform_u32(ctr_prng_t *p, int n)
{
 c001e22:	b580      	push	{r7, lr}
 c001e24:	b084      	sub	sp, #16
 c001e26:	af00      	add	r7, sp, #0
 c001e28:	6078      	str	r0, [r7, #4]
 c001e2a:	6039      	str	r1, [r7, #0]
    // rejection sampling to avoid modulo bias
    const uint32_t lim = 0xFFFFFFFFu - (0xFFFFFFFFu % (uint32_t)n);
 c001e2c:	683b      	ldr	r3, [r7, #0]
 c001e2e:	f04f 32ff 	mov.w	r2, #4294967295
 c001e32:	fbb2 f1f3 	udiv	r1, r2, r3
 c001e36:	fb01 f303 	mul.w	r3, r1, r3
 c001e3a:	1ad3      	subs	r3, r2, r3
 c001e3c:	43db      	mvns	r3, r3
 c001e3e:	60fb      	str	r3, [r7, #12]
    for (;;) {
        uint32_t r = prng_next_u32(p);
 c001e40:	6878      	ldr	r0, [r7, #4]
 c001e42:	f7ff ffce 	bl	c001de2 <prng_next_u32>
 c001e46:	60b8      	str	r0, [r7, #8]
        if (r < lim) return (int)(r % (uint32_t)n);
 c001e48:	68ba      	ldr	r2, [r7, #8]
 c001e4a:	68fb      	ldr	r3, [r7, #12]
 c001e4c:	429a      	cmp	r2, r3
 c001e4e:	d2f7      	bcs.n	c001e40 <prng_uniform_u32+0x1e>
 c001e50:	683a      	ldr	r2, [r7, #0]
 c001e52:	68bb      	ldr	r3, [r7, #8]
 c001e54:	fbb3 f1f2 	udiv	r1, r3, r2
 c001e58:	fb01 f202 	mul.w	r2, r1, r2
 c001e5c:	1a9b      	subs	r3, r3, r2
 c001e5e:	bf00      	nop
    }
}
 c001e60:	4618      	mov	r0, r3
 c001e62:	3710      	adds	r7, #16
 c001e64:	46bd      	mov	sp, r7
 c001e66:	bd80      	pop	{r7, pc}

0c001e68 <shuffle_secure_aes_ctr>:

// ---- FisherYates using the PRNG above
static void shuffle_secure_aes_ctr(int *arr, int n,
                                   const uint8_t key16[16],
                                   const uint8_t iv16[16])
{
 c001e68:	b580      	push	{r7, lr}
 c001e6a:	b0bc      	sub	sp, #240	@ 0xf0
 c001e6c:	af00      	add	r7, sp, #0
 c001e6e:	60f8      	str	r0, [r7, #12]
 c001e70:	60b9      	str	r1, [r7, #8]
 c001e72:	607a      	str	r2, [r7, #4]
 c001e74:	603b      	str	r3, [r7, #0]
    ctr_prng_t prng;
    prng_init(&prng, key16, iv16);
 c001e76:	f107 0310 	add.w	r3, r7, #16
 c001e7a:	683a      	ldr	r2, [r7, #0]
 c001e7c:	6879      	ldr	r1, [r7, #4]
 c001e7e:	4618      	mov	r0, r3
 c001e80:	f7ff ff70 	bl	c001d64 <prng_init>

    for (int i = n - 1; i > 0; i--) {
 c001e84:	68bb      	ldr	r3, [r7, #8]
 c001e86:	3b01      	subs	r3, #1
 c001e88:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 c001e8c:	e02b      	b.n	c001ee6 <shuffle_secure_aes_ctr+0x7e>
        int j = prng_uniform_u32(&prng, i + 1);
 c001e8e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001e92:	1c5a      	adds	r2, r3, #1
 c001e94:	f107 0310 	add.w	r3, r7, #16
 c001e98:	4611      	mov	r1, r2
 c001e9a:	4618      	mov	r0, r3
 c001e9c:	f7ff ffc1 	bl	c001e22 <prng_uniform_u32>
 c001ea0:	f8c7 00e8 	str.w	r0, [r7, #232]	@ 0xe8
        int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
 c001ea4:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001ea8:	009b      	lsls	r3, r3, #2
 c001eaa:	68fa      	ldr	r2, [r7, #12]
 c001eac:	4413      	add	r3, r2
 c001eae:	681b      	ldr	r3, [r3, #0]
 c001eb0:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 c001eb4:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 c001eb8:	009b      	lsls	r3, r3, #2
 c001eba:	68fa      	ldr	r2, [r7, #12]
 c001ebc:	441a      	add	r2, r3
 c001ebe:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001ec2:	009b      	lsls	r3, r3, #2
 c001ec4:	68f9      	ldr	r1, [r7, #12]
 c001ec6:	440b      	add	r3, r1
 c001ec8:	6812      	ldr	r2, [r2, #0]
 c001eca:	601a      	str	r2, [r3, #0]
 c001ecc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 c001ed0:	009b      	lsls	r3, r3, #2
 c001ed2:	68fa      	ldr	r2, [r7, #12]
 c001ed4:	4413      	add	r3, r2
 c001ed6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 c001eda:	601a      	str	r2, [r3, #0]
    for (int i = n - 1; i > 0; i--) {
 c001edc:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001ee0:	3b01      	subs	r3, #1
 c001ee2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 c001ee6:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 c001eea:	2b00      	cmp	r3, #0
 c001eec:	dccf      	bgt.n	c001e8e <shuffle_secure_aes_ctr+0x26>
    }
}
 c001eee:	bf00      	nop
 c001ef0:	bf00      	nop
 c001ef2:	37f0      	adds	r7, #240	@ 0xf0
 c001ef4:	46bd      	mov	sp, r7
 c001ef6:	bd80      	pop	{r7, pc}

0c001ef8 <__acle_se_SECURE_ShuffledHMAC_secure>:

// ---- Non-secure callable: secure shuffle + HMAC over blocks
__attribute__((cmse_nonsecure_entry))
void SECURE_ShuffledHMAC_secure(uint8_t *out_digest, size_t out_len,
                                const uint8_t *challenge, size_t challenge_len)
{
 c001ef8:	b5b0      	push	{r4, r5, r7, lr}
 c001efa:	f5ad 6d88 	sub.w	sp, sp, #1088	@ 0x440
 c001efe:	af00      	add	r7, sp, #0
 c001f00:	f507 6488 	add.w	r4, r7, #1088	@ 0x440
 c001f04:	f2a4 4434 	subw	r4, r4, #1076	@ 0x434
 c001f08:	6020      	str	r0, [r4, #0]
 c001f0a:	f507 6088 	add.w	r0, r7, #1088	@ 0x440
 c001f0e:	f5a0 6087 	sub.w	r0, r0, #1080	@ 0x438
 c001f12:	6001      	str	r1, [r0, #0]
 c001f14:	f507 6188 	add.w	r1, r7, #1088	@ 0x440
 c001f18:	f2a1 413c 	subw	r1, r1, #1084	@ 0x43c
 c001f1c:	600a      	str	r2, [r1, #0]
 c001f1e:	f507 6288 	add.w	r2, r7, #1088	@ 0x440
 c001f22:	f5a2 6288 	sub.w	r2, r2, #1088	@ 0x440
 c001f26:	6013      	str	r3, [r2, #0]
    if (!out_digest || out_len < SHA256_DIGEST_SIZE) return;
 c001f28:	f507 6388 	add.w	r3, r7, #1088	@ 0x440
 c001f2c:	f2a3 4334 	subw	r3, r3, #1076	@ 0x434
 c001f30:	681b      	ldr	r3, [r3, #0]
 c001f32:	2b00      	cmp	r3, #0
 c001f34:	f000 8082 	beq.w	c00203c <__acle_se_SECURE_ShuffledHMAC_secure+0x144>
 c001f38:	f507 6388 	add.w	r3, r7, #1088	@ 0x440
 c001f3c:	f5a3 6387 	sub.w	r3, r3, #1080	@ 0x438
 c001f40:	681b      	ldr	r3, [r3, #0]
 c001f42:	2b1f      	cmp	r3, #31
 c001f44:	d97a      	bls.n	c00203c <__acle_se_SECURE_ShuffledHMAC_secure+0x144>

    // 1) indices = 0..BLOCKS-1
    static int indices[BLOCKS];
    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c001f46:	2300      	movs	r3, #0
 c001f48:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c
 c001f4c:	e00b      	b.n	c001f66 <__acle_se_SECURE_ShuffledHMAC_secure+0x6e>
 c001f4e:	4958      	ldr	r1, [pc, #352]	@ (c0020b0 <__acle_se_SECURE_ShuffledHMAC_secure+0x1b8>)
 c001f50:	f8d7 343c 	ldr.w	r3, [r7, #1084]	@ 0x43c
 c001f54:	f8d7 243c 	ldr.w	r2, [r7, #1084]	@ 0x43c
 c001f58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 c001f5c:	f8d7 343c 	ldr.w	r3, [r7, #1084]	@ 0x43c
 c001f60:	3301      	adds	r3, #1
 c001f62:	f8c7 343c 	str.w	r3, [r7, #1084]	@ 0x43c
 c001f66:	f8d7 343c 	ldr.w	r3, [r7, #1084]	@ 0x43c
 c001f6a:	2bff      	cmp	r3, #255	@ 0xff
 c001f6c:	ddef      	ble.n	c001f4e <__acle_se_SECURE_ShuffledHMAC_secure+0x56>

    // 2) derive AES key/IV from challenge
    uint8_t key16[16], iv16[16];
    derive_aes_key_iv_from_challenge(key16, iv16, challenge, challenge_len);
 c001f6e:	f507 6388 	add.w	r3, r7, #1088	@ 0x440
 c001f72:	f5a3 6388 	sub.w	r3, r3, #1088	@ 0x440
 c001f76:	f507 6288 	add.w	r2, r7, #1088	@ 0x440
 c001f7a:	f2a2 423c 	subw	r2, r2, #1084	@ 0x43c
 c001f7e:	f207 4114 	addw	r1, r7, #1044	@ 0x414
 c001f82:	f207 4024 	addw	r0, r7, #1060	@ 0x424
 c001f86:	681b      	ldr	r3, [r3, #0]
 c001f88:	6812      	ldr	r2, [r2, #0]
 c001f8a:	f7ff feab 	bl	c001ce4 <derive_aes_key_iv_from_challenge>

    // 3) secure shuffle
    shuffle_secure_aes_ctr(indices, BLOCKS, key16, iv16);
 c001f8e:	f207 4314 	addw	r3, r7, #1044	@ 0x414
 c001f92:	f207 4224 	addw	r2, r7, #1060	@ 0x424
 c001f96:	f44f 7180 	mov.w	r1, #256	@ 0x100
 c001f9a:	4845      	ldr	r0, [pc, #276]	@ (c0020b0 <__acle_se_SECURE_ShuffledHMAC_secure+0x1b8>)
 c001f9c:	f7ff ff64 	bl	c001e68 <shuffle_secure_aes_ctr>

    // 4) HMAC over shuffled blocks
    hmac_sha256_initialize(&hmac, (const uint8_t*)key, strlen(key));
 c001fa0:	220e      	movs	r2, #14
 c001fa2:	4944      	ldr	r1, [pc, #272]	@ (c0020b4 <__acle_se_SECURE_ShuffledHMAC_secure+0x1bc>)
 c001fa4:	4844      	ldr	r0, [pc, #272]	@ (c0020b8 <__acle_se_SECURE_ShuffledHMAC_secure+0x1c0>)
 c001fa6:	f7ff f8b1 	bl	c00110c <hmac_sha256_initialize>
    uint8_t copy[BLOCK_SIZE];
    for (int i = 0; i < BLOCKS; i++) {
 c001faa:	2300      	movs	r3, #0
 c001fac:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
 c001fb0:	e028      	b.n	c002004 <__acle_se_SECURE_ShuffledHMAC_secure+0x10c>
        const uint8_t *blk = &real_memory[(size_t)indices[i] * BLOCK_SIZE];
 c001fb2:	4b42      	ldr	r3, [pc, #264]	@ (c0020bc <__acle_se_SECURE_ShuffledHMAC_secure+0x1c4>)
 c001fb4:	681a      	ldr	r2, [r3, #0]
 c001fb6:	493e      	ldr	r1, [pc, #248]	@ (c0020b0 <__acle_se_SECURE_ShuffledHMAC_secure+0x1b8>)
 c001fb8:	f8d7 3438 	ldr.w	r3, [r7, #1080]	@ 0x438
 c001fbc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c001fc0:	029b      	lsls	r3, r3, #10
 c001fc2:	4413      	add	r3, r2
 c001fc4:	f8c7 3434 	str.w	r3, [r7, #1076]	@ 0x434
  __ASM volatile ("cpsid i" : : : "memory");
 c001fc8:	b672      	cpsid	i
}
 c001fca:	bf00      	nop
        __disable_irq();
        memcpy(copy, blk, BLOCK_SIZE);
 c001fcc:	f507 6388 	add.w	r3, r7, #1088	@ 0x440
 c001fd0:	f2a3 422c 	subw	r2, r3, #1068	@ 0x42c
 c001fd4:	f8d7 3434 	ldr.w	r3, [r7, #1076]	@ 0x434
 c001fd8:	4610      	mov	r0, r2
 c001fda:	4619      	mov	r1, r3
 c001fdc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 c001fe0:	461a      	mov	r2, r3
 c001fe2:	f003 fdf0 	bl	c005bc6 <memcpy>
  __ASM volatile ("cpsie i" : : : "memory");
 c001fe6:	b662      	cpsie	i
}
 c001fe8:	bf00      	nop
//        hmac_sha256_update(&hmac, blk, BLOCK_SIZE);
        __enable_irq();
        hmac_sha256_update(&hmac, copy, BLOCK_SIZE);
 c001fea:	f107 0314 	add.w	r3, r7, #20
 c001fee:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c001ff2:	4619      	mov	r1, r3
 c001ff4:	4830      	ldr	r0, [pc, #192]	@ (c0020b8 <__acle_se_SECURE_ShuffledHMAC_secure+0x1c0>)
 c001ff6:	f7ff f8f9 	bl	c0011ec <hmac_sha256_update>
    for (int i = 0; i < BLOCKS; i++) {
 c001ffa:	f8d7 3438 	ldr.w	r3, [r7, #1080]	@ 0x438
 c001ffe:	3301      	adds	r3, #1
 c002000:	f8c7 3438 	str.w	r3, [r7, #1080]	@ 0x438
 c002004:	f8d7 3438 	ldr.w	r3, [r7, #1080]	@ 0x438
 c002008:	2bff      	cmp	r3, #255	@ 0xff
 c00200a:	ddd2      	ble.n	c001fb2 <__acle_se_SECURE_ShuffledHMAC_secure+0xba>
    }
    hmac_sha256_finalize(&hmac, NULL, 0);
 c00200c:	2200      	movs	r2, #0
 c00200e:	2100      	movs	r1, #0
 c002010:	4829      	ldr	r0, [pc, #164]	@ (c0020b8 <__acle_se_SECURE_ShuffledHMAC_secure+0x1c0>)
 c002012:	f7ff f8fc 	bl	c00120e <hmac_sha256_finalize>
    memcpy(out_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c002016:	f507 6388 	add.w	r3, r7, #1088	@ 0x440
 c00201a:	f2a3 4334 	subw	r3, r3, #1076	@ 0x434
 c00201e:	681b      	ldr	r3, [r3, #0]
 c002020:	4a25      	ldr	r2, [pc, #148]	@ (c0020b8 <__acle_se_SECURE_ShuffledHMAC_secure+0x1c0>)
 c002022:	461c      	mov	r4, r3
 c002024:	4615      	mov	r5, r2
 c002026:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002028:	6020      	str	r0, [r4, #0]
 c00202a:	6061      	str	r1, [r4, #4]
 c00202c:	60a2      	str	r2, [r4, #8]
 c00202e:	60e3      	str	r3, [r4, #12]
 c002030:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002032:	6120      	str	r0, [r4, #16]
 c002034:	6161      	str	r1, [r4, #20]
 c002036:	61a2      	str	r2, [r4, #24]
 c002038:	61e3      	str	r3, [r4, #28]
 c00203a:	e000      	b.n	c00203e <__acle_se_SECURE_ShuffledHMAC_secure+0x146>
    if (!out_digest || out_len < SHA256_DIGEST_SIZE) return;
 c00203c:	bf00      	nop
}
 c00203e:	f507 6788 	add.w	r7, r7, #1088	@ 0x440
 c002042:	46bd      	mov	sp, r7
 c002044:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c002048:	4670      	mov	r0, lr
 c00204a:	4671      	mov	r1, lr
 c00204c:	4672      	mov	r2, lr
 c00204e:	4673      	mov	r3, lr
 c002050:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002054:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002058:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00205c:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002060:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002064:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002068:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c00206c:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002070:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002074:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002078:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c00207c:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002080:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002084:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002088:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c00208c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002090:	f38e 8c00 	msr	CPSR_fs, lr
 c002094:	b410      	push	{r4}
 c002096:	eef1 ca10 	vmrs	ip, fpscr
 c00209a:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c00209e:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0020a2:	ea0c 0c04 	and.w	ip, ip, r4
 c0020a6:	eee1 ca10 	vmsr	fpscr, ip
 c0020aa:	bc10      	pop	{r4}
 c0020ac:	46f4      	mov	ip, lr
 c0020ae:	4774      	bxns	lr
 c0020b0:	300006b8 	.word	0x300006b8
 c0020b4:	0c006c4c 	.word	0x0c006c4c
 c0020b8:	300001d0 	.word	0x300001d0
 c0020bc:	30000000 	.word	0x30000000

0c0020c0 <__acle_se_SECURE_SMARM>:


__attribute__((cmse_nonsecure_entry))
void SECURE_SMARM(uint8_t *output_digest, size_t maxlen)
{
 c0020c0:	b5b0      	push	{r4, r5, r7, lr}
 c0020c2:	f5ad 1d80 	sub.w	sp, sp, #1048576	@ 0x100000
 c0020c6:	b088      	sub	sp, #32
 c0020c8:	af00      	add	r7, sp, #0
 c0020ca:	f107 0320 	add.w	r3, r7, #32
 c0020ce:	f843 0c1c 	str.w	r0, [r3, #-28]
 c0020d2:	f107 0320 	add.w	r3, r7, #32
 c0020d6:	f843 1c20 	str.w	r1, [r3, #-32]
	if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c0020da:	f107 0320 	add.w	r3, r7, #32
 c0020de:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 c0020e2:	2b00      	cmp	r3, #0
 c0020e4:	f000 80c8 	beq.w	c002278 <__acle_se_SECURE_SMARM+0x1b8>
 c0020e8:	f107 0320 	add.w	r3, r7, #32
 c0020ec:	f853 3c20 	ldr.w	r3, [r3, #-32]
 c0020f0:	2b1f      	cmp	r3, #31
 c0020f2:	f240 80c1 	bls.w	c002278 <__acle_se_SECURE_SMARM+0x1b8>

    srand(42);  // Use fixed seed or hardware-derived one like SysTick->VAL
 c0020f6:	202a      	movs	r0, #42	@ 0x2a
 c0020f8:	f003 fa50 	bl	c00559c <srand>

	// note #include <aes/aes_cbc.h>  lib

	// ben shuffle_aes_ctr  main.c -> shuffle.c

	for (int i = TOTAL_SIZE - 1; i > 0; i--) {
 c0020fc:	4b7c      	ldr	r3, [pc, #496]	@ (c0022f0 <__acle_se_SECURE_SMARM+0x230>)
 c0020fe:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002102:	f102 021c 	add.w	r2, r2, #28
 c002106:	6013      	str	r3, [r2, #0]
 c002108:	e051      	b.n	c0021ae <__acle_se_SECURE_SMARM+0xee>

	int j = rand() % (i + 1);
 c00210a:	f003 fa75 	bl	c0055f8 <rand>
 c00210e:	4602      	mov	r2, r0
 c002110:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002114:	f103 031c 	add.w	r3, r3, #28
 c002118:	681b      	ldr	r3, [r3, #0]
 c00211a:	3301      	adds	r3, #1
 c00211c:	fb92 f1f3 	sdiv	r1, r2, r3
 c002120:	fb01 f303 	mul.w	r3, r1, r3
 c002124:	1ad3      	subs	r3, r2, r3
 c002126:	f107 1210 	add.w	r2, r7, #1048592	@ 0x100010
 c00212a:	6013      	str	r3, [r2, #0]

	int tmp = indices[i];
 c00212c:	f107 0320 	add.w	r3, r7, #32
 c002130:	461a      	mov	r2, r3
 c002132:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002136:	f103 031c 	add.w	r3, r3, #28
 c00213a:	681b      	ldr	r3, [r3, #0]
 c00213c:	009b      	lsls	r3, r3, #2
 c00213e:	4413      	add	r3, r2
 c002140:	f853 3c14 	ldr.w	r3, [r3, #-20]
 c002144:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002148:	f102 020c 	add.w	r2, r2, #12
 c00214c:	6013      	str	r3, [r2, #0]

	indices[i] = indices[j];
 c00214e:	f107 0320 	add.w	r3, r7, #32
 c002152:	461a      	mov	r2, r3
 c002154:	f107 1310 	add.w	r3, r7, #1048592	@ 0x100010
 c002158:	681b      	ldr	r3, [r3, #0]
 c00215a:	009b      	lsls	r3, r3, #2
 c00215c:	4413      	add	r3, r2
 c00215e:	f853 2c14 	ldr.w	r2, [r3, #-20]
 c002162:	f107 0320 	add.w	r3, r7, #32
 c002166:	4619      	mov	r1, r3
 c002168:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c00216c:	f103 031c 	add.w	r3, r3, #28
 c002170:	681b      	ldr	r3, [r3, #0]
 c002172:	009b      	lsls	r3, r3, #2
 c002174:	440b      	add	r3, r1
 c002176:	f843 2c14 	str.w	r2, [r3, #-20]

	indices[j] = tmp;
 c00217a:	f107 0320 	add.w	r3, r7, #32
 c00217e:	461a      	mov	r2, r3
 c002180:	f107 1310 	add.w	r3, r7, #1048592	@ 0x100010
 c002184:	681b      	ldr	r3, [r3, #0]
 c002186:	009b      	lsls	r3, r3, #2
 c002188:	4413      	add	r3, r2
 c00218a:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c00218e:	f102 020c 	add.w	r2, r2, #12
 c002192:	6812      	ldr	r2, [r2, #0]
 c002194:	f843 2c14 	str.w	r2, [r3, #-20]
	for (int i = TOTAL_SIZE - 1; i > 0; i--) {
 c002198:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c00219c:	f103 031c 	add.w	r3, r3, #28
 c0021a0:	681b      	ldr	r3, [r3, #0]
 c0021a2:	3b01      	subs	r3, #1
 c0021a4:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c0021a8:	f102 021c 	add.w	r2, r2, #28
 c0021ac:	6013      	str	r3, [r2, #0]
 c0021ae:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c0021b2:	f103 031c 	add.w	r3, r3, #28
 c0021b6:	681b      	ldr	r3, [r3, #0]
 c0021b8:	2b00      	cmp	r3, #0
 c0021ba:	dca6      	bgt.n	c00210a <__acle_se_SECURE_SMARM+0x4a>

	}

	hmac_sha256_initialize(&hmac, key, strlen((const char )key));
 c0021bc:	4b4d      	ldr	r3, [pc, #308]	@ (c0022f4 <__acle_se_SECURE_SMARM+0x234>)
 c0021be:	b2db      	uxtb	r3, r3
 c0021c0:	4618      	mov	r0, r3
 c0021c2:	f7fe f839 	bl	c000238 <strlen>
 c0021c6:	4603      	mov	r3, r0
 c0021c8:	461a      	mov	r2, r3
 c0021ca:	494a      	ldr	r1, [pc, #296]	@ (c0022f4 <__acle_se_SECURE_SMARM+0x234>)
 c0021cc:	484a      	ldr	r0, [pc, #296]	@ (c0022f8 <__acle_se_SECURE_SMARM+0x238>)
 c0021ce:	f7fe ff9d 	bl	c00110c <hmac_sha256_initialize>

	for (int i = 0; i < BLOCKS; i++) {
 c0021d2:	2300      	movs	r3, #0
 c0021d4:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c0021d8:	f102 0218 	add.w	r2, r2, #24
 c0021dc:	6013      	str	r3, [r2, #0]
 c0021de:	e02d      	b.n	c00223c <__acle_se_SECURE_SMARM+0x17c>

	const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c0021e0:	4b46      	ldr	r3, [pc, #280]	@ (c0022fc <__acle_se_SECURE_SMARM+0x23c>)
 c0021e2:	681a      	ldr	r2, [r3, #0]
 c0021e4:	f107 0320 	add.w	r3, r7, #32
 c0021e8:	4619      	mov	r1, r3
 c0021ea:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c0021ee:	f103 0318 	add.w	r3, r3, #24
 c0021f2:	681b      	ldr	r3, [r3, #0]
 c0021f4:	009b      	lsls	r3, r3, #2
 c0021f6:	440b      	add	r3, r1
 c0021f8:	f853 3c14 	ldr.w	r3, [r3, #-20]
 c0021fc:	029b      	lsls	r3, r3, #10
 c0021fe:	4413      	add	r3, r2
 c002200:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002204:	f102 0214 	add.w	r2, r2, #20
 c002208:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 c00220a:	b672      	cpsid	i
}
 c00220c:	bf00      	nop

		__disable_irq();
		hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c00220e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c002212:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002216:	f103 0314 	add.w	r3, r3, #20
 c00221a:	6819      	ldr	r1, [r3, #0]
 c00221c:	4836      	ldr	r0, [pc, #216]	@ (c0022f8 <__acle_se_SECURE_SMARM+0x238>)
 c00221e:	f7fe ffe5 	bl	c0011ec <hmac_sha256_update>
  __ASM volatile ("cpsie i" : : : "memory");
 c002222:	b662      	cpsie	i
}
 c002224:	bf00      	nop
	for (int i = 0; i < BLOCKS; i++) {
 c002226:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c00222a:	f103 0318 	add.w	r3, r3, #24
 c00222e:	681b      	ldr	r3, [r3, #0]
 c002230:	3301      	adds	r3, #1
 c002232:	f507 1280 	add.w	r2, r7, #1048576	@ 0x100000
 c002236:	f102 0218 	add.w	r2, r2, #24
 c00223a:	6013      	str	r3, [r2, #0]
 c00223c:	f507 1380 	add.w	r3, r7, #1048576	@ 0x100000
 c002240:	f103 0318 	add.w	r3, r3, #24
 c002244:	681b      	ldr	r3, [r3, #0]
 c002246:	2bff      	cmp	r3, #255	@ 0xff
 c002248:	ddca      	ble.n	c0021e0 <__acle_se_SECURE_SMARM+0x120>
		__enable_irq();

	}

	hmac_sha256_finalize(&hmac, NULL, 0);
 c00224a:	2200      	movs	r2, #0
 c00224c:	2100      	movs	r1, #0
 c00224e:	482a      	ldr	r0, [pc, #168]	@ (c0022f8 <__acle_se_SECURE_SMARM+0x238>)
 c002250:	f7fe ffdd 	bl	c00120e <hmac_sha256_finalize>

	memcpy(output_digest,hmac.digest, SHA256_DIGEST_SIZE);
 c002254:	f107 0320 	add.w	r3, r7, #32
 c002258:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 c00225c:	4a26      	ldr	r2, [pc, #152]	@ (c0022f8 <__acle_se_SECURE_SMARM+0x238>)
 c00225e:	461c      	mov	r4, r3
 c002260:	4615      	mov	r5, r2
 c002262:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002264:	6020      	str	r0, [r4, #0]
 c002266:	6061      	str	r1, [r4, #4]
 c002268:	60a2      	str	r2, [r4, #8]
 c00226a:	60e3      	str	r3, [r4, #12]
 c00226c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c00226e:	6120      	str	r0, [r4, #16]
 c002270:	6161      	str	r1, [r4, #20]
 c002272:	61a2      	str	r2, [r4, #24]
 c002274:	61e3      	str	r3, [r4, #28]
 c002276:	e000      	b.n	c00227a <__acle_se_SECURE_SMARM+0x1ba>
	if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c002278:	bf00      	nop
}
 c00227a:	f507 1780 	add.w	r7, r7, #1048576	@ 0x100000
 c00227e:	3720      	adds	r7, #32
 c002280:	46bd      	mov	sp, r7
 c002282:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c002286:	4670      	mov	r0, lr
 c002288:	4671      	mov	r1, lr
 c00228a:	4672      	mov	r2, lr
 c00228c:	4673      	mov	r3, lr
 c00228e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002292:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002296:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c00229a:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00229e:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0022a2:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0022a6:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0022aa:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0022ae:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0022b2:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0022b6:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0022ba:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0022be:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0022c2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0022c6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0022ca:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0022ce:	f38e 8c00 	msr	CPSR_fs, lr
 c0022d2:	b410      	push	{r4}
 c0022d4:	eef1 ca10 	vmrs	ip, fpscr
 c0022d8:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0022dc:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0022e0:	ea0c 0c04 	and.w	ip, ip, r4
 c0022e4:	eee1 ca10 	vmsr	fpscr, ip
 c0022e8:	bc10      	pop	{r4}
 c0022ea:	46f4      	mov	ip, lr
 c0022ec:	4774      	bxns	lr
 c0022ee:	bf00      	nop
 c0022f0:	0003ffff 	.word	0x0003ffff
 c0022f4:	0c006c4c 	.word	0x0c006c4c
 c0022f8:	300001d0 	.word	0x300001d0
 c0022fc:	30000000 	.word	0x30000000

0c002300 <__acle_se_SECURE_TEST>:



__attribute__((cmse_nonsecure_entry))
void SECURE_TEST(uint8_t *output_digest, size_t maxlen)
{
 c002300:	b5b0      	push	{r4, r5, r7, lr}
 c002302:	f5ad 6d85 	sub.w	sp, sp, #1064	@ 0x428
 c002306:	af00      	add	r7, sp, #0
 c002308:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c00230c:	f2a3 4324 	subw	r3, r3, #1060	@ 0x424
 c002310:	6018      	str	r0, [r3, #0]
 c002312:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c002316:	f5a3 6385 	sub.w	r3, r3, #1064	@ 0x428
 c00231a:	6019      	str	r1, [r3, #0]
	 if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c00231c:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c002320:	f2a3 4324 	subw	r3, r3, #1060	@ 0x424
 c002324:	681b      	ldr	r3, [r3, #0]
 c002326:	2b00      	cmp	r3, #0
 c002328:	f000 80b6 	beq.w	c002498 <__acle_se_SECURE_TEST+0x198>
 c00232c:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c002330:	f5a3 6385 	sub.w	r3, r3, #1064	@ 0x428
 c002334:	681b      	ldr	r3, [r3, #0]
 c002336:	2b1f      	cmp	r3, #31
 c002338:	f240 80ae 	bls.w	c002498 <__acle_se_SECURE_TEST+0x198>

	    // Fill real_memory if ( linear)
	    for (int i = 0; i < TOTAL_SIZE * BLOCK_SIZE; i++) {
 c00233c:	2300      	movs	r3, #0
 c00233e:	f8c7 3424 	str.w	r3, [r7, #1060]	@ 0x424
 c002342:	e00d      	b.n	c002360 <__acle_se_SECURE_TEST+0x60>
	        real_memory[i] = i & 0xFF;
 c002344:	4b71      	ldr	r3, [pc, #452]	@ (c00250c <__acle_se_SECURE_TEST+0x20c>)
 c002346:	681a      	ldr	r2, [r3, #0]
 c002348:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 c00234c:	4413      	add	r3, r2
 c00234e:	f8d7 2424 	ldr.w	r2, [r7, #1060]	@ 0x424
 c002352:	b2d2      	uxtb	r2, r2
 c002354:	701a      	strb	r2, [r3, #0]
	    for (int i = 0; i < TOTAL_SIZE * BLOCK_SIZE; i++) {
 c002356:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 c00235a:	3301      	adds	r3, #1
 c00235c:	f8c7 3424 	str.w	r3, [r7, #1060]	@ 0x424
 c002360:	f8d7 3424 	ldr.w	r3, [r7, #1060]	@ 0x424
 c002364:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 c002368:	dbec      	blt.n	c002344 <__acle_se_SECURE_TEST+0x44>
	    }

	    // 1. Initialize indices
	    int indices[BLOCKS];
	    for (int i = 0; i < BLOCKS; i++) indices[i] = i;
 c00236a:	2300      	movs	r3, #0
 c00236c:	f8c7 3420 	str.w	r3, [r7, #1056]	@ 0x420
 c002370:	e00e      	b.n	c002390 <__acle_se_SECURE_TEST+0x90>
 c002372:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c002376:	f2a3 431c 	subw	r3, r3, #1052	@ 0x41c
 c00237a:	f8d7 2420 	ldr.w	r2, [r7, #1056]	@ 0x420
 c00237e:	f8d7 1420 	ldr.w	r1, [r7, #1056]	@ 0x420
 c002382:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 c002386:	f8d7 3420 	ldr.w	r3, [r7, #1056]	@ 0x420
 c00238a:	3301      	adds	r3, #1
 c00238c:	f8c7 3420 	str.w	r3, [r7, #1056]	@ 0x420
 c002390:	f8d7 3420 	ldr.w	r3, [r7, #1056]	@ 0x420
 c002394:	2bff      	cmp	r3, #255	@ 0xff
 c002396:	ddec      	ble.n	c002372 <__acle_se_SECURE_TEST+0x72>

	    srand(42);
 c002398:	202a      	movs	r0, #42	@ 0x2a
 c00239a:	f003 f8ff 	bl	c00559c <srand>

	    // 2. Shuffle indices
	    for (int i = BLOCKS - 1; i > 0; i--) {
 c00239e:	23ff      	movs	r3, #255	@ 0xff
 c0023a0:	f8c7 341c 	str.w	r3, [r7, #1052]	@ 0x41c
 c0023a4:	e035      	b.n	c002412 <__acle_se_SECURE_TEST+0x112>
	        int j = rand() % (i + 1);
 c0023a6:	f003 f927 	bl	c0055f8 <rand>
 c0023aa:	4602      	mov	r2, r0
 c0023ac:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 c0023b0:	3301      	adds	r3, #1
 c0023b2:	fb92 f1f3 	sdiv	r1, r2, r3
 c0023b6:	fb01 f303 	mul.w	r3, r1, r3
 c0023ba:	1ad3      	subs	r3, r2, r3
 c0023bc:	f8c7 3410 	str.w	r3, [r7, #1040]	@ 0x410
	        int tmp = indices[i];
 c0023c0:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c0023c4:	f2a3 431c 	subw	r3, r3, #1052	@ 0x41c
 c0023c8:	f8d7 241c 	ldr.w	r2, [r7, #1052]	@ 0x41c
 c0023cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0023d0:	f8c7 340c 	str.w	r3, [r7, #1036]	@ 0x40c
	        indices[i] = indices[j];
 c0023d4:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c0023d8:	f2a3 431c 	subw	r3, r3, #1052	@ 0x41c
 c0023dc:	f8d7 2410 	ldr.w	r2, [r7, #1040]	@ 0x410
 c0023e0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c0023e4:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c0023e8:	f2a3 431c 	subw	r3, r3, #1052	@ 0x41c
 c0023ec:	f8d7 241c 	ldr.w	r2, [r7, #1052]	@ 0x41c
 c0023f0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	        indices[j] = tmp;
 c0023f4:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c0023f8:	f2a3 431c 	subw	r3, r3, #1052	@ 0x41c
 c0023fc:	f8d7 2410 	ldr.w	r2, [r7, #1040]	@ 0x410
 c002400:	f8d7 140c 	ldr.w	r1, [r7, #1036]	@ 0x40c
 c002404:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	    for (int i = BLOCKS - 1; i > 0; i--) {
 c002408:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 c00240c:	3b01      	subs	r3, #1
 c00240e:	f8c7 341c 	str.w	r3, [r7, #1052]	@ 0x41c
 c002412:	f8d7 341c 	ldr.w	r3, [r7, #1052]	@ 0x41c
 c002416:	2b00      	cmp	r3, #0
 c002418:	dcc5      	bgt.n	c0023a6 <__acle_se_SECURE_TEST+0xa6>
	    }

	    hmac_sha256_initialize(&hmac, key, strlen((const char *)key));
 c00241a:	220e      	movs	r2, #14
 c00241c:	493c      	ldr	r1, [pc, #240]	@ (c002510 <__acle_se_SECURE_TEST+0x210>)
 c00241e:	483d      	ldr	r0, [pc, #244]	@ (c002514 <__acle_se_SECURE_TEST+0x214>)
 c002420:	f7fe fe74 	bl	c00110c <hmac_sha256_initialize>

	    for (int i = 0; i < BLOCKS; i++) {
 c002424:	2300      	movs	r3, #0
 c002426:	f8c7 3418 	str.w	r3, [r7, #1048]	@ 0x418
 c00242a:	e019      	b.n	c002460 <__acle_se_SECURE_TEST+0x160>
	        const uint8_t *block = &real_memory[indices[i] * BLOCK_SIZE];
 c00242c:	4b37      	ldr	r3, [pc, #220]	@ (c00250c <__acle_se_SECURE_TEST+0x20c>)
 c00242e:	681b      	ldr	r3, [r3, #0]
 c002430:	f507 6285 	add.w	r2, r7, #1064	@ 0x428
 c002434:	f2a2 421c 	subw	r2, r2, #1052	@ 0x41c
 c002438:	f8d7 1418 	ldr.w	r1, [r7, #1048]	@ 0x418
 c00243c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 c002440:	0292      	lsls	r2, r2, #10
 c002442:	4413      	add	r3, r2
 c002444:	f8c7 3414 	str.w	r3, [r7, #1044]	@ 0x414
	        hmac_sha256_update(&hmac, block, BLOCK_SIZE);
 c002448:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c00244c:	f8d7 1414 	ldr.w	r1, [r7, #1044]	@ 0x414
 c002450:	4830      	ldr	r0, [pc, #192]	@ (c002514 <__acle_se_SECURE_TEST+0x214>)
 c002452:	f7fe fecb 	bl	c0011ec <hmac_sha256_update>
	    for (int i = 0; i < BLOCKS; i++) {
 c002456:	f8d7 3418 	ldr.w	r3, [r7, #1048]	@ 0x418
 c00245a:	3301      	adds	r3, #1
 c00245c:	f8c7 3418 	str.w	r3, [r7, #1048]	@ 0x418
 c002460:	f8d7 3418 	ldr.w	r3, [r7, #1048]	@ 0x418
 c002464:	2bff      	cmp	r3, #255	@ 0xff
 c002466:	dde1      	ble.n	c00242c <__acle_se_SECURE_TEST+0x12c>
	    }

	    hmac_sha256_finalize(&hmac, NULL, 0);
 c002468:	2200      	movs	r2, #0
 c00246a:	2100      	movs	r1, #0
 c00246c:	4829      	ldr	r0, [pc, #164]	@ (c002514 <__acle_se_SECURE_TEST+0x214>)
 c00246e:	f7fe fece 	bl	c00120e <hmac_sha256_finalize>
	    memcpy(output_digest, hmac.digest, SHA256_DIGEST_SIZE);
 c002472:	f507 6385 	add.w	r3, r7, #1064	@ 0x428
 c002476:	f2a3 4324 	subw	r3, r3, #1060	@ 0x424
 c00247a:	681b      	ldr	r3, [r3, #0]
 c00247c:	4a25      	ldr	r2, [pc, #148]	@ (c002514 <__acle_se_SECURE_TEST+0x214>)
 c00247e:	461c      	mov	r4, r3
 c002480:	4615      	mov	r5, r2
 c002482:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c002484:	6020      	str	r0, [r4, #0]
 c002486:	6061      	str	r1, [r4, #4]
 c002488:	60a2      	str	r2, [r4, #8]
 c00248a:	60e3      	str	r3, [r4, #12]
 c00248c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c00248e:	6120      	str	r0, [r4, #16]
 c002490:	6161      	str	r1, [r4, #20]
 c002492:	61a2      	str	r2, [r4, #24]
 c002494:	61e3      	str	r3, [r4, #28]
 c002496:	e000      	b.n	c00249a <__acle_se_SECURE_TEST+0x19a>
	 if (!output_digest || maxlen < SHA256_DIGEST_SIZE) return;
 c002498:	bf00      	nop
}
 c00249a:	f507 6785 	add.w	r7, r7, #1064	@ 0x428
 c00249e:	46bd      	mov	sp, r7
 c0024a0:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 c0024a4:	4670      	mov	r0, lr
 c0024a6:	4671      	mov	r1, lr
 c0024a8:	4672      	mov	r2, lr
 c0024aa:	4673      	mov	r3, lr
 c0024ac:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0024b0:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0024b4:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0024b8:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0024bc:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0024c0:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0024c4:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0024c8:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0024cc:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0024d0:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0024d4:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0024d8:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0024dc:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0024e0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0024e4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0024e8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0024ec:	f38e 8c00 	msr	CPSR_fs, lr
 c0024f0:	b410      	push	{r4}
 c0024f2:	eef1 ca10 	vmrs	ip, fpscr
 c0024f6:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c0024fa:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c0024fe:	ea0c 0c04 	and.w	ip, ip, r4
 c002502:	eee1 ca10 	vmsr	fpscr, ip
 c002506:	bc10      	pop	{r4}
 c002508:	46f4      	mov	ip, lr
 c00250a:	4774      	bxns	lr
 c00250c:	30000000 	.word	0x30000000
 c002510:	0c006c4c 	.word	0x0c006c4c
 c002514:	300001d0 	.word	0x300001d0

0c002518 <__acle_se_Secure_FlashTest>:
//
//}

__attribute__((cmse_nonsecure_entry))
void Secure_FlashTest(void)
{
 c002518:	b580      	push	{r7, lr}
 c00251a:	b098      	sub	sp, #96	@ 0x60
 c00251c:	af00      	add	r7, sp, #0
	 	HAL_StatusTypeDef status;
	    FLASH_EraseInitTypeDef EraseInitStruct = {0};
 c00251e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 c002522:	2200      	movs	r2, #0
 c002524:	601a      	str	r2, [r3, #0]
 c002526:	605a      	str	r2, [r3, #4]
 c002528:	609a      	str	r2, [r3, #8]
 c00252a:	60da      	str	r2, [r3, #12]
	    FLASH_BBAttributesTypeDef flash_bb_attr = {0};
 c00252c:	f107 0314 	add.w	r3, r7, #20
 c002530:	2200      	movs	r2, #0
 c002532:	601a      	str	r2, [r3, #0]
 c002534:	605a      	str	r2, [r3, #4]
 c002536:	609a      	str	r2, [r3, #8]
 c002538:	60da      	str	r2, [r3, #12]
 c00253a:	611a      	str	r2, [r3, #16]
 c00253c:	615a      	str	r2, [r3, #20]
	    uint32_t PageError = 0;
 c00253e:	2300      	movs	r3, #0
 c002540:	613b      	str	r3, [r7, #16]
	    uint64_t test_data = FLASH_TEST_DATA;
 c002542:	a3d4      	add	r3, pc, #848	@ (adr r3, c002894 <__acle_se_Secure_FlashTest+0x37c>)
 c002544:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002548:	e9c7 2302 	strd	r2, r3, [r7, #8]
	    uint32_t saved_attr = 0;
 c00254c:	2300      	movs	r3, #0
 c00254e:	65fb      	str	r3, [r7, #92]	@ 0x5c

	    printf("[Secure] === Flash Test (with BB Attributes) ===\r\n");
 c002550:	48b1      	ldr	r0, [pc, #708]	@ (c002818 <__acle_se_Secure_FlashTest+0x300>)
 c002552:	f003 f9b9 	bl	c0058c8 <puts>

	    // ========== Step 1: Get Current BB Attributes ==========
	    flash_bb_attr.Bank = FLASH_TEST_BANK;
 c002556:	2302      	movs	r3, #2
 c002558:	617b      	str	r3, [r7, #20]
	    flash_bb_attr.BBAttributesType = FLASH_BB_SEC;
 c00255a:	2301      	movs	r3, #1
 c00255c:	61bb      	str	r3, [r7, #24]

	    HAL_FLASHEx_GetConfigBBAttributes(&flash_bb_attr);
 c00255e:	f107 0314 	add.w	r3, r7, #20
 c002562:	4618      	mov	r0, r3
 c002564:	f001 fed4 	bl	c004310 <HAL_FLASHEx_GetConfigBBAttributes>

	    uint32_t attr_index = FLASH_TEST_PAGE / 32;  // 120/32 = 3
 c002568:	2303      	movs	r3, #3
 c00256a:	65bb      	str	r3, [r7, #88]	@ 0x58
	    uint32_t attr_bit = FLASH_TEST_PAGE % 32;    // 120%32 = 24
 c00256c:	2318      	movs	r3, #24
 c00256e:	657b      	str	r3, [r7, #84]	@ 0x54

	    saved_attr = flash_bb_attr.BBAttributes_array[attr_index];
 c002570:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c002572:	3302      	adds	r3, #2
 c002574:	009b      	lsls	r3, r3, #2
 c002576:	3360      	adds	r3, #96	@ 0x60
 c002578:	443b      	add	r3, r7
 c00257a:	f853 3c4c 	ldr.w	r3, [r3, #-76]
 c00257e:	65fb      	str	r3, [r7, #92]	@ 0x5c
	    uint32_t page_is_secure = (saved_attr >> attr_bit) & 0x1;
 c002580:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c002582:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c002584:	fa22 f303 	lsr.w	r3, r2, r3
 c002588:	f003 0301 	and.w	r3, r3, #1
 c00258c:	653b      	str	r3, [r7, #80]	@ 0x50

	    printf("[Secure] Page %d current: %s\r\n",
 c00258e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c002590:	2b00      	cmp	r3, #0
 c002592:	d001      	beq.n	c002598 <__acle_se_Secure_FlashTest+0x80>
 c002594:	4ba1      	ldr	r3, [pc, #644]	@ (c00281c <__acle_se_Secure_FlashTest+0x304>)
 c002596:	e000      	b.n	c00259a <__acle_se_Secure_FlashTest+0x82>
 c002598:	4ba1      	ldr	r3, [pc, #644]	@ (c002820 <__acle_se_Secure_FlashTest+0x308>)
 c00259a:	461a      	mov	r2, r3
 c00259c:	2178      	movs	r1, #120	@ 0x78
 c00259e:	48a1      	ldr	r0, [pc, #644]	@ (c002824 <__acle_se_Secure_FlashTest+0x30c>)
 c0025a0:	f003 f92a 	bl	c0057f8 <iprintf>
	           FLASH_TEST_PAGE,
	           page_is_secure ? "SECURE" : "NON-SECURE");

	    // ========== Step 2: Promote Page to SECURE ==========
	    printf("[Secure] Promoting to SECURE...\r\n");
 c0025a4:	48a0      	ldr	r0, [pc, #640]	@ (c002828 <__acle_se_Secure_FlashTest+0x310>)
 c0025a6:	f003 f98f 	bl	c0058c8 <puts>

	    // Set bit to make page Secure
	    flash_bb_attr.BBAttributes_array[attr_index] |= (1U << attr_bit);
 c0025aa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c0025ac:	3302      	adds	r3, #2
 c0025ae:	009b      	lsls	r3, r3, #2
 c0025b0:	3360      	adds	r3, #96	@ 0x60
 c0025b2:	443b      	add	r3, r7
 c0025b4:	f853 2c4c 	ldr.w	r2, [r3, #-76]
 c0025b8:	2101      	movs	r1, #1
 c0025ba:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c0025bc:	fa01 f303 	lsl.w	r3, r1, r3
 c0025c0:	431a      	orrs	r2, r3
 c0025c2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c0025c4:	3302      	adds	r3, #2
 c0025c6:	009b      	lsls	r3, r3, #2
 c0025c8:	3360      	adds	r3, #96	@ 0x60
 c0025ca:	443b      	add	r3, r7
 c0025cc:	f843 2c4c 	str.w	r2, [r3, #-76]

	    status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c0025d0:	f107 0314 	add.w	r3, r7, #20
 c0025d4:	4618      	mov	r0, r3
 c0025d6:	f001 fe51 	bl	c00427c <HAL_FLASHEx_ConfigBBAttributes>
 c0025da:	4603      	mov	r3, r0
 c0025dc:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c0025e0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0025e4:	2b00      	cmp	r3, #0
 c0025e6:	d006      	beq.n	c0025f6 <__acle_se_Secure_FlashTest+0xde>
	    {
	        printf("[Secure]  Promote FAILED: %d\r\n", status);
 c0025e8:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0025ec:	4619      	mov	r1, r3
 c0025ee:	488f      	ldr	r0, [pc, #572]	@ (c00282c <__acle_se_Secure_FlashTest+0x314>)
 c0025f0:	f003 f902 	bl	c0057f8 <iprintf>
 c0025f4:	e0d6      	b.n	c0027a4 <__acle_se_Secure_FlashTest+0x28c>
	        return;
	    }

	    printf("[Secure]  Promoted to SECURE\r\n");
 c0025f6:	488e      	ldr	r0, [pc, #568]	@ (c002830 <__acle_se_Secure_FlashTest+0x318>)
 c0025f8:	f003 f966 	bl	c0058c8 <puts>

	    // Small delay for attribute change to take effect
//	    for (volatile int i = 0; i < 1000; i++);

	    // ========== Step 3: Unlock Flash ==========
	    status = HAL_FLASH_Unlock();
 c0025fc:	f001 fcbc 	bl	c003f78 <HAL_FLASH_Unlock>
 c002600:	4603      	mov	r3, r0
 c002602:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c002606:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00260a:	2b00      	cmp	r3, #0
 c00260c:	d006      	beq.n	c00261c <__acle_se_Secure_FlashTest+0x104>
	    {
	        printf("[Secure]  Unlock FAILED: %d\r\n", status);
 c00260e:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c002612:	4619      	mov	r1, r3
 c002614:	4887      	ldr	r0, [pc, #540]	@ (c002834 <__acle_se_Secure_FlashTest+0x31c>)
 c002616:	f003 f8ef 	bl	c0057f8 <iprintf>
	        goto restore_attributes;
 c00261a:	e096      	b.n	c00274a <__acle_se_Secure_FlashTest+0x232>
	    }
	    printf("[Secure]  Unlocked\r\n");
 c00261c:	4886      	ldr	r0, [pc, #536]	@ (c002838 <__acle_se_Secure_FlashTest+0x320>)
 c00261e:	f003 f953 	bl	c0058c8 <puts>

	    // ========== Step 4: Erase Page ==========
	    EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES;
 c002622:	2302      	movs	r3, #2
 c002624:	62fb      	str	r3, [r7, #44]	@ 0x2c
	    EraseInitStruct.Page = FLASH_TEST_PAGE;
 c002626:	2378      	movs	r3, #120	@ 0x78
 c002628:	637b      	str	r3, [r7, #52]	@ 0x34
	    EraseInitStruct.NbPages = 1;
 c00262a:	2301      	movs	r3, #1
 c00262c:	63bb      	str	r3, [r7, #56]	@ 0x38
	    EraseInitStruct.Banks = FLASH_TEST_BANK;
 c00262e:	2302      	movs	r3, #2
 c002630:	633b      	str	r3, [r7, #48]	@ 0x30

	    status = HAL_FLASHEx_Erase(&EraseInitStruct, &PageError);
 c002632:	f107 0210 	add.w	r2, r7, #16
 c002636:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 c00263a:	4611      	mov	r1, r2
 c00263c:	4618      	mov	r0, r3
 c00263e:	f001 fda5 	bl	c00418c <HAL_FLASHEx_Erase>
 c002642:	4603      	mov	r3, r0
 c002644:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

	    if (status != HAL_OK || PageError != 0xFFFFFFFF)
 c002648:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00264c:	2b00      	cmp	r3, #0
 c00264e:	d103      	bne.n	c002658 <__acle_se_Secure_FlashTest+0x140>
 c002650:	693b      	ldr	r3, [r7, #16]
 c002652:	f1b3 3fff 	cmp.w	r3, #4294967295
 c002656:	d009      	beq.n	c00266c <__acle_se_Secure_FlashTest+0x154>
	    {
	        printf("[Secure]  Erase FAILED: status=%d, PageError=0x%08lX\r\n",
 c002658:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00265c:	693a      	ldr	r2, [r7, #16]
 c00265e:	4619      	mov	r1, r3
 c002660:	4876      	ldr	r0, [pc, #472]	@ (c00283c <__acle_se_Secure_FlashTest+0x324>)
 c002662:	f003 f8c9 	bl	c0057f8 <iprintf>
	               status, PageError);
	        HAL_FLASH_Lock();
 c002666:	f001 fcbd 	bl	c003fe4 <HAL_FLASH_Lock>
	        goto restore_attributes;
 c00266a:	e06e      	b.n	c00274a <__acle_se_Secure_FlashTest+0x232>
	    }
	    printf("[Secure]  Erase OK\r\n");
 c00266c:	4874      	ldr	r0, [pc, #464]	@ (c002840 <__acle_se_Secure_FlashTest+0x328>)
 c00266e:	f003 f92b 	bl	c0058c8 <puts>

	    // ========== Step 5: Prepare Data in Work Buffer ==========
	    // Copy data to NS work buffer (required by some HAL implementations)
	    memcpy(ns_work_buffer, &test_data, sizeof(test_data));
 c002672:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c002676:	4973      	ldr	r1, [pc, #460]	@ (c002844 <__acle_se_Secure_FlashTest+0x32c>)
 c002678:	e9c1 2300 	strd	r2, r3, [r1]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 c00267c:	f3bf 8f4f 	dsb	sy
}
 c002680:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002682:	f3bf 8f6f 	isb	sy
}
 c002686:	bf00      	nop
	    // Memory barrier
	    __DSB();
	    __ISB();

	    // ========== Step 6: Program via Secure Address ==========
	    printf("[Secure] Programming...\r\n");
 c002688:	486f      	ldr	r0, [pc, #444]	@ (c002848 <__acle_se_Secure_FlashTest+0x330>)
 c00268a:	f003 f91d 	bl	c0058c8 <puts>

	    // Use Secure alias address (0x0C...)
	    uint64_t data_to_write;
	    memcpy(&data_to_write, ns_work_buffer, sizeof(data_to_write));
 c00268e:	4b6d      	ldr	r3, [pc, #436]	@ (c002844 <__acle_se_Secure_FlashTest+0x32c>)
 c002690:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002694:	e9c7 2300 	strd	r2, r3, [r7]

	    status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 c002698:	e9d7 2300 	ldrd	r2, r3, [r7]
 c00269c:	496b      	ldr	r1, [pc, #428]	@ (c00284c <__acle_se_Secure_FlashTest+0x334>)
 c00269e:	2001      	movs	r0, #1
 c0026a0:	f001 fc20 	bl	c003ee4 <HAL_FLASH_Program>
 c0026a4:	4603      	mov	r3, r0
 c0026a6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	                                FLASH_TEST_ADDR_SECURE,  // Secure alias
	                                data_to_write);

	    if (status != HAL_OK)
 c0026aa:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0026ae:	2b00      	cmp	r3, #0
 c0026b0:	d018      	beq.n	c0026e4 <__acle_se_Secure_FlashTest+0x1cc>
	    {
	        uint32_t flash_error = HAL_FLASH_GetError();
 c0026b2:	f001 fcc1 	bl	c004038 <HAL_FLASH_GetError>
 c0026b6:	63f8      	str	r0, [r7, #60]	@ 0x3c
	        printf("[Secure]  Program FAILED\r\n");
 c0026b8:	4865      	ldr	r0, [pc, #404]	@ (c002850 <__acle_se_Secure_FlashTest+0x338>)
 c0026ba:	f003 f905 	bl	c0058c8 <puts>
	        printf("[Secure]    Status: %d\r\n", status);
 c0026be:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c0026c2:	4619      	mov	r1, r3
 c0026c4:	4863      	ldr	r0, [pc, #396]	@ (c002854 <__acle_se_Secure_FlashTest+0x33c>)
 c0026c6:	f003 f897 	bl	c0057f8 <iprintf>
	        printf("[Secure]    Error: 0x%08lX\r\n", flash_error);
 c0026ca:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 c0026cc:	4862      	ldr	r0, [pc, #392]	@ (c002858 <__acle_se_Secure_FlashTest+0x340>)
 c0026ce:	f003 f893 	bl	c0057f8 <iprintf>
	        printf("[Secure]    SECSR: 0x%08lX\r\n", FLASH->SECSR);
 c0026d2:	4b62      	ldr	r3, [pc, #392]	@ (c00285c <__acle_se_Secure_FlashTest+0x344>)
 c0026d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0026d6:	4619      	mov	r1, r3
 c0026d8:	4861      	ldr	r0, [pc, #388]	@ (c002860 <__acle_se_Secure_FlashTest+0x348>)
 c0026da:	f003 f88d 	bl	c0057f8 <iprintf>
	        HAL_FLASH_Lock();
 c0026de:	f001 fc81 	bl	c003fe4 <HAL_FLASH_Lock>
	        goto restore_attributes;
 c0026e2:	e032      	b.n	c00274a <__acle_se_Secure_FlashTest+0x232>
	    }

	    printf("[Secure]  Program OK\r\n");
 c0026e4:	485f      	ldr	r0, [pc, #380]	@ (c002864 <__acle_se_Secure_FlashTest+0x34c>)
 c0026e6:	f003 f8ef 	bl	c0058c8 <puts>

	    // ========== Step 7: Lock Flash ==========
	    HAL_FLASH_Lock();
 c0026ea:	f001 fc7b 	bl	c003fe4 <HAL_FLASH_Lock>
  __ASM volatile ("dsb 0xF":::"memory");
 c0026ee:	f3bf 8f4f 	dsb	sy
}
 c0026f2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0026f4:	f3bf 8f6f 	isb	sy
}
 c0026f8:	bf00      	nop
	    // ========== Step 8: Verify (while still Secure) ==========
	    // Clean and invalidate cache
	    __DSB();
	    __ISB();

	    uint64_t verify_value = *(volatile uint64_t*)FLASH_TEST_ADDR_SECURE;
 c0026fa:	4b54      	ldr	r3, [pc, #336]	@ (c00284c <__acle_se_Secure_FlashTest+0x334>)
 c0026fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002700:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40

	    if (verify_value == test_data)
 c002704:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c002708:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 c00270c:	4299      	cmp	r1, r3
 c00270e:	bf08      	it	eq
 c002710:	4290      	cmpeq	r0, r2
 c002712:	d10d      	bne.n	c002730 <__acle_se_Secure_FlashTest+0x218>
	    {
	        printf("[Secure]  Verify OK!\r\n");
 c002714:	4854      	ldr	r0, [pc, #336]	@ (c002868 <__acle_se_Secure_FlashTest+0x350>)
 c002716:	f003 f8d7 	bl	c0058c8 <puts>
	        printf("[Secure]    Written:  0x%016llX\r\n", test_data);
 c00271a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c00271e:	4853      	ldr	r0, [pc, #332]	@ (c00286c <__acle_se_Secure_FlashTest+0x354>)
 c002720:	f003 f86a 	bl	c0057f8 <iprintf>
	        printf("[Secure]    Read:     0x%016llX\r\n", verify_value);
 c002724:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002728:	4851      	ldr	r0, [pc, #324]	@ (c002870 <__acle_se_Secure_FlashTest+0x358>)
 c00272a:	f003 f865 	bl	c0057f8 <iprintf>
 c00272e:	e00c      	b.n	c00274a <__acle_se_Secure_FlashTest+0x232>
	    }
	    else
	    {
	        printf("[Secure]  Verify FAILED!\r\n");
 c002730:	4850      	ldr	r0, [pc, #320]	@ (c002874 <__acle_se_Secure_FlashTest+0x35c>)
 c002732:	f003 f8c9 	bl	c0058c8 <puts>
	        printf("[Secure]    Expected: 0x%016llX\r\n", test_data);
 c002736:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 c00273a:	484f      	ldr	r0, [pc, #316]	@ (c002878 <__acle_se_Secure_FlashTest+0x360>)
 c00273c:	f003 f85c 	bl	c0057f8 <iprintf>
	        printf("[Secure]    Got:      0x%016llX\r\n", verify_value);
 c002740:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002744:	484d      	ldr	r0, [pc, #308]	@ (c00287c <__acle_se_Secure_FlashTest+0x364>)
 c002746:	f003 f857 	bl	c0057f8 <iprintf>
	    }

	restore_attributes:
	    // ========== Step 9: Demote back to Original Attributes ==========
	    printf("[Secure] Restoring attributes...\r\n");
 c00274a:	484d      	ldr	r0, [pc, #308]	@ (c002880 <__acle_se_Secure_FlashTest+0x368>)
 c00274c:	f003 f8bc 	bl	c0058c8 <puts>

	    // Restore original attribute
	    flash_bb_attr.BBAttributes_array[attr_index] = saved_attr;
 c002750:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 c002752:	3302      	adds	r3, #2
 c002754:	009b      	lsls	r3, r3, #2
 c002756:	3360      	adds	r3, #96	@ 0x60
 c002758:	443b      	add	r3, r7
 c00275a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 c00275c:	f843 2c4c 	str.w	r2, [r3, #-76]

	    status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c002760:	f107 0314 	add.w	r3, r7, #20
 c002764:	4618      	mov	r0, r3
 c002766:	f001 fd89 	bl	c00427c <HAL_FLASHEx_ConfigBBAttributes>
 c00276a:	4603      	mov	r3, r0
 c00276c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	    if (status != HAL_OK)
 c002770:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c002774:	2b00      	cmp	r3, #0
 c002776:	d009      	beq.n	c00278c <__acle_se_Secure_FlashTest+0x274>
	    {
	        printf("[Secure]   WARNING: Failed to restore: %d\r\n", status);
 c002778:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 c00277c:	4619      	mov	r1, r3
 c00277e:	4841      	ldr	r0, [pc, #260]	@ (c002884 <__acle_se_Secure_FlashTest+0x36c>)
 c002780:	f003 f83a 	bl	c0057f8 <iprintf>
	        printf("[Secure]   Page may remain SECURE!\r\n");
 c002784:	4840      	ldr	r0, [pc, #256]	@ (c002888 <__acle_se_Secure_FlashTest+0x370>)
 c002786:	f003 f89f 	bl	c0058c8 <puts>
 c00278a:	e002      	b.n	c002792 <__acle_se_Secure_FlashTest+0x27a>
	    }
	    else
	    {
	        printf("[Secure]  Attributes restored\r\n");
 c00278c:	483f      	ldr	r0, [pc, #252]	@ (c00288c <__acle_se_Secure_FlashTest+0x374>)
 c00278e:	f003 f89b 	bl	c0058c8 <puts>
  __ASM volatile ("dsb 0xF":::"memory");
 c002792:	f3bf 8f4f 	dsb	sy
}
 c002796:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002798:	f3bf 8f6f 	isb	sy
}
 c00279c:	bf00      	nop

	    // ========== Step 10: Invalidate Caches ==========
	    __DSB();
	    __ISB();

	    printf("[Secure]  Flash Test Complete!\r\n");
 c00279e:	483c      	ldr	r0, [pc, #240]	@ (c002890 <__acle_se_Secure_FlashTest+0x378>)
 c0027a0:	f003 f892 	bl	c0058c8 <puts>
}
 c0027a4:	3760      	adds	r7, #96	@ 0x60
 c0027a6:	46bd      	mov	sp, r7
 c0027a8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c0027ac:	4670      	mov	r0, lr
 c0027ae:	4671      	mov	r1, lr
 c0027b0:	4672      	mov	r2, lr
 c0027b2:	4673      	mov	r3, lr
 c0027b4:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0027b8:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0027bc:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0027c0:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0027c4:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0027c8:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0027cc:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0027d0:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0027d4:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0027d8:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0027dc:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0027e0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0027e4:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0027e8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c0027ec:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c0027f0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c0027f4:	f38e 8c00 	msr	CPSR_fs, lr
 c0027f8:	b410      	push	{r4}
 c0027fa:	eef1 ca10 	vmrs	ip, fpscr
 c0027fe:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002802:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002806:	ea0c 0c04 	and.w	ip, ip, r4
 c00280a:	eee1 ca10 	vmsr	fpscr, ip
 c00280e:	bc10      	pop	{r4}
 c002810:	46f4      	mov	ip, lr
 c002812:	4774      	bxns	lr
 c002814:	f3af 8000 	nop.w
 c002818:	0c006728 	.word	0x0c006728
 c00281c:	0c00675c 	.word	0x0c00675c
 c002820:	0c006764 	.word	0x0c006764
 c002824:	0c006770 	.word	0x0c006770
 c002828:	0c006790 	.word	0x0c006790
 c00282c:	0c0067b4 	.word	0x0c0067b4
 c002830:	0c0067d8 	.word	0x0c0067d8
 c002834:	0c0067fc 	.word	0x0c0067fc
 c002838:	0c006820 	.word	0x0c006820
 c00283c:	0c006838 	.word	0x0c006838
 c002840:	0c006874 	.word	0x0c006874
 c002844:	30003428 	.word	0x30003428
 c002848:	0c00688c 	.word	0x0c00688c
 c00284c:	0c0be000 	.word	0x0c0be000
 c002850:	0c0068a8 	.word	0x0c0068a8
 c002854:	0c0068c8 	.word	0x0c0068c8
 c002858:	0c0068e4 	.word	0x0c0068e4
 c00285c:	50022000 	.word	0x50022000
 c002860:	0c006904 	.word	0x0c006904
 c002864:	0c006924 	.word	0x0c006924
 c002868:	0c006940 	.word	0x0c006940
 c00286c:	0c00695c 	.word	0x0c00695c
 c002870:	0c006980 	.word	0x0c006980
 c002874:	0c0069a4 	.word	0x0c0069a4
 c002878:	0c0069c4 	.word	0x0c0069c4
 c00287c:	0c0069e8 	.word	0x0c0069e8
 c002880:	0c006a0c 	.word	0x0c006a0c
 c002884:	0c006a30 	.word	0x0c006a30
 c002888:	0c006a64 	.word	0x0c006a64
 c00288c:	0c006a90 	.word	0x0c006a90
 c002890:	0c006ab4 	.word	0x0c006ab4
 c002894:	12345678 	.word	0x12345678
 c002898:	12345678 	.word	0x12345678
 c00289c:	00000000 	.word	0x00000000

0c0028a0 <__acle_se_Secure_EraseWriteVerify>:


//Ben try to delete direcly
__attribute__((cmse_nonsecure_entry))
void Secure_EraseWriteVerify(void)
{
 c0028a0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c0028a4:	b09c      	sub	sp, #112	@ 0x70
 c0028a6:	af00      	add	r7, sp, #0
    HAL_StatusTypeDef status;
    FLASH_EraseInitTypeDef EraseInitStruct = {0};
 c0028a8:	f107 0318 	add.w	r3, r7, #24
 c0028ac:	2200      	movs	r2, #0
 c0028ae:	601a      	str	r2, [r3, #0]
 c0028b0:	605a      	str	r2, [r3, #4]
 c0028b2:	609a      	str	r2, [r3, #8]
 c0028b4:	60da      	str	r2, [r3, #12]
    uint32_t PageError = 0;
 c0028b6:	2300      	movs	r3, #0
 c0028b8:	667b      	str	r3, [r7, #100]	@ 0x64
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c0028ba:	a38e      	add	r3, pc, #568	@ (adr r3, c002af4 <__acle_se_Secure_EraseWriteVerify+0x254>)
 c0028bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0028c0:	e9c7 2316 	strd	r2, r3, [r7, #88]	@ 0x58

    uint32_t target_page = 127;
 c0028c4:	237f      	movs	r3, #127	@ 0x7f
 c0028c6:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t target_addr = 0x0807F800;
 c0028c8:	4b85      	ldr	r3, [pc, #532]	@ (c002ae0 <__acle_se_Secure_EraseWriteVerify+0x240>)
 c0028ca:	653b      	str	r3, [r7, #80]	@ 0x50

    volatile uint32_t debug_step = 0;
 c0028cc:	2300      	movs	r3, #0
 c0028ce:	617b      	str	r3, [r7, #20]
    volatile uint32_t debug_match = 0;
 c0028d0:	2300      	movs	r3, #0
 c0028d2:	613b      	str	r3, [r7, #16]
    volatile uint32_t debug_notmatch = 0;
 c0028d4:	2300      	movs	r3, #0
 c0028d6:	60fb      	str	r3, [r7, #12]

    HAL_ICACHE_Disable();
 c0028d8:	f002 f908 	bl	c004aec <HAL_ICACHE_Disable>
    debug_step = 1;
 c0028dc:	2301      	movs	r3, #1
 c0028de:	617b      	str	r3, [r7, #20]

    // ========== Unlock NS ==========
    FLASH->NSKEYR = FLASH_KEY1;
 c0028e0:	4b80      	ldr	r3, [pc, #512]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0028e2:	4a81      	ldr	r2, [pc, #516]	@ (c002ae8 <__acle_se_Secure_EraseWriteVerify+0x248>)
 c0028e4:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c0028e6:	4b7f      	ldr	r3, [pc, #508]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0028e8:	4a80      	ldr	r2, [pc, #512]	@ (c002aec <__acle_se_Secure_EraseWriteVerify+0x24c>)
 c0028ea:	609a      	str	r2, [r3, #8]

    if (HAL_FLASH_Unlock() != HAL_OK) {
 c0028ec:	f001 fb44 	bl	c003f78 <HAL_FLASH_Unlock>
 c0028f0:	4603      	mov	r3, r0
 c0028f2:	2b00      	cmp	r3, #0
 c0028f4:	d004      	beq.n	c002900 <__acle_se_Secure_EraseWriteVerify+0x60>
        debug_step = 10; // Unlock failed
 c0028f6:	230a      	movs	r3, #10
 c0028f8:	617b      	str	r3, [r7, #20]
        HAL_ICACHE_Enable();
 c0028fa:	f002 f8e7 	bl	c004acc <HAL_ICACHE_Enable>
 c0028fe:	e0b5      	b.n	c002a6c <__acle_se_Secure_EraseWriteVerify+0x1cc>
        return;
    }

    // ==========   HAL  Non-Secure operation ==========
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;  // Non-Secure operation
 c002900:	4b7b      	ldr	r3, [pc, #492]	@ (c002af0 <__acle_se_Secure_EraseWriteVerify+0x250>)
 c002902:	2202      	movs	r2, #2
 c002904:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;  // Clear all flags
 c002906:	4b77      	ldr	r3, [pc, #476]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002908:	f04f 32ff 	mov.w	r2, #4294967295
 c00290c:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c00290e:	f3bf 8f4f 	dsb	sy
}
 c002912:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002914:	f3bf 8f6f 	isb	sy
}
 c002918:	bf00      	nop
//        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
//        HAL_ICACHE_Enable();
//        return;
//    }

    debug_step = 3;  // Erase OK
 c00291a:	2303      	movs	r3, #3
 c00291c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 c00291e:	f3bf 8f4f 	dsb	sy
}
 c002922:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002924:	f3bf 8f6f 	isb	sy
}
 c002928:	bf00      	nop

    __DSB();
    __ISB();

    // ========== Program 256 words ==========
    debug_step = 4;
 c00292a:	2304      	movs	r3, #4
 c00292c:	617b      	str	r3, [r7, #20]

    for (uint32_t i = 0; i < 256; i++) {
 c00292e:	2300      	movs	r3, #0
 c002930:	66fb      	str	r3, [r7, #108]	@ 0x6c
 c002932:	e047      	b.n	c0029c4 <__acle_se_Secure_EraseWriteVerify+0x124>
        uint32_t addr = target_addr + (i * 8);
 c002934:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c002936:	00db      	lsls	r3, r3, #3
 c002938:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c00293a:	4413      	add	r3, r2
 c00293c:	637b      	str	r3, [r7, #52]	@ 0x34
        uint64_t value = test_value + i;
 c00293e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c002940:	2200      	movs	r2, #0
 c002942:	4698      	mov	r8, r3
 c002944:	4691      	mov	r9, r2
 c002946:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 c00294a:	eb12 0108 	adds.w	r1, r2, r8
 c00294e:	6039      	str	r1, [r7, #0]
 c002950:	eb43 0309 	adc.w	r3, r3, r9
 c002954:	607b      	str	r3, [r7, #4]
 c002956:	e9d7 2300 	ldrd	r2, r3, [r7]
 c00295a:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c00295e:	bf00      	nop
 c002960:	4b60      	ldr	r3, [pc, #384]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002962:	6a1b      	ldr	r3, [r3, #32]
 c002964:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002968:	2b00      	cmp	r3, #0
 c00296a:	d1f9      	bne.n	c002960 <__acle_se_Secure_EraseWriteVerify+0xc0>

        // Clear any errors
        FLASH->NSSR = 0xFFFFFFFF;
 c00296c:	4b5d      	ldr	r3, [pc, #372]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c00296e:	f04f 32ff 	mov.w	r2, #4294967295
 c002972:	621a      	str	r2, [r3, #32]

        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002974:	4b5b      	ldr	r3, [pc, #364]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002976:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002978:	4a5a      	ldr	r2, [pc, #360]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c00297a:	f043 0301 	orr.w	r3, r3, #1
 c00297e:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(value);
 c002980:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002982:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 c002984:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002986:	f3bf 8f6f 	isb	sy
}
 c00298a:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(value >> 32);
 c00298c:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 c002990:	f04f 0200 	mov.w	r2, #0
 c002994:	f04f 0300 	mov.w	r3, #0
 c002998:	000a      	movs	r2, r1
 c00299a:	2300      	movs	r3, #0
 c00299c:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 c00299e:	3104      	adds	r1, #4
 c0029a0:	4613      	mov	r3, r2
 c0029a2:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c0029a4:	bf00      	nop
 c0029a6:	4b4f      	ldr	r3, [pc, #316]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029a8:	6a1b      	ldr	r3, [r3, #32]
 c0029aa:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c0029ae:	2b00      	cmp	r3, #0
 c0029b0:	d1f9      	bne.n	c0029a6 <__acle_se_Secure_EraseWriteVerify+0x106>

        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c0029b2:	4b4c      	ldr	r3, [pc, #304]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029b4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c0029b6:	4a4b      	ldr	r2, [pc, #300]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c0029b8:	f023 0301 	bic.w	r3, r3, #1
 c0029bc:	6293      	str	r3, [r2, #40]	@ 0x28
    for (uint32_t i = 0; i < 256; i++) {
 c0029be:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c0029c0:	3301      	adds	r3, #1
 c0029c2:	66fb      	str	r3, [r7, #108]	@ 0x6c
 c0029c4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c0029c6:	2bff      	cmp	r3, #255	@ 0xff
 c0029c8:	d9b4      	bls.n	c002934 <__acle_se_Secure_EraseWriteVerify+0x94>
  __ASM volatile ("dsb 0xF":::"memory");
 c0029ca:	f3bf 8f4f 	dsb	sy
}
 c0029ce:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0029d0:	f3bf 8f6f 	isb	sy
}
 c0029d4:	bf00      	nop

    __DSB();
    __ISB();

    // ========== Invalidate Cache ==========
    debug_step = 5;
 c0029d6:	2305      	movs	r3, #5
 c0029d8:	617b      	str	r3, [r7, #20]
    HAL_ICACHE_Invalidate();
 c0029da:	f002 f8b7 	bl	c004b4c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c0029de:	f3bf 8f4f 	dsb	sy
}
 c0029e2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c0029e4:	f3bf 8f6f 	isb	sy
}
 c0029e8:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    debug_step = 6;
 c0029ea:	2306      	movs	r3, #6
 c0029ec:	617b      	str	r3, [r7, #20]

    for (uint32_t j = 0; j < 256; j++) {
 c0029ee:	2300      	movs	r3, #0
 c0029f0:	66bb      	str	r3, [r7, #104]	@ 0x68
 c0029f2:	e027      	b.n	c002a44 <__acle_se_Secure_EraseWriteVerify+0x1a4>
        uint32_t addr = target_addr + (j * 8);
 c0029f4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c0029f6:	00db      	lsls	r3, r3, #3
 c0029f8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c0029fa:	4413      	add	r3, r2
 c0029fc:	64fb      	str	r3, [r7, #76]	@ 0x4c
        uint64_t expected = test_value + j;
 c0029fe:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a00:	2200      	movs	r2, #0
 c002a02:	461c      	mov	r4, r3
 c002a04:	4615      	mov	r5, r2
 c002a06:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 c002a0a:	eb12 0a04 	adds.w	sl, r2, r4
 c002a0e:	eb43 0b05 	adc.w	fp, r3, r5
 c002a12:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
        uint64_t actual = *(volatile uint64_t*)addr;
 c002a16:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002a18:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002a1c:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

        if (actual == expected) {
 c002a20:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 c002a24:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 c002a28:	4299      	cmp	r1, r3
 c002a2a:	bf08      	it	eq
 c002a2c:	4290      	cmpeq	r0, r2
 c002a2e:	d103      	bne.n	c002a38 <__acle_se_Secure_EraseWriteVerify+0x198>
            debug_match++;
 c002a30:	693b      	ldr	r3, [r7, #16]
 c002a32:	3301      	adds	r3, #1
 c002a34:	613b      	str	r3, [r7, #16]
 c002a36:	e002      	b.n	c002a3e <__acle_se_Secure_EraseWriteVerify+0x19e>
        } else {
            debug_notmatch++;
 c002a38:	68fb      	ldr	r3, [r7, #12]
 c002a3a:	3301      	adds	r3, #1
 c002a3c:	60fb      	str	r3, [r7, #12]
    for (uint32_t j = 0; j < 256; j++) {
 c002a3e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a40:	3301      	adds	r3, #1
 c002a42:	66bb      	str	r3, [r7, #104]	@ 0x68
 c002a44:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c002a46:	2bff      	cmp	r3, #255	@ 0xff
 c002a48:	d9d4      	bls.n	c0029f4 <__acle_se_Secure_EraseWriteVerify+0x154>
        }
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002a4a:	4b26      	ldr	r3, [pc, #152]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002a4c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002a4e:	4a25      	ldr	r2, [pc, #148]	@ (c002ae4 <__acle_se_Secure_EraseWriteVerify+0x244>)
 c002a50:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002a54:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002a56:	f002 f839 	bl	c004acc <HAL_ICACHE_Enable>

    if (debug_match == 256) {
 c002a5a:	693b      	ldr	r3, [r7, #16]
 c002a5c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c002a60:	d102      	bne.n	c002a68 <__acle_se_Secure_EraseWriteVerify+0x1c8>
        debug_step = 100;  //  Success
 c002a62:	2364      	movs	r3, #100	@ 0x64
 c002a64:	617b      	str	r3, [r7, #20]
 c002a66:	e001      	b.n	c002a6c <__acle_se_Secure_EraseWriteVerify+0x1cc>
    } else {
        debug_step = 101;  //  Failed
 c002a68:	2365      	movs	r3, #101	@ 0x65
 c002a6a:	617b      	str	r3, [r7, #20]
    }
}
 c002a6c:	3770      	adds	r7, #112	@ 0x70
 c002a6e:	46bd      	mov	sp, r7
 c002a70:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002a74:	4670      	mov	r0, lr
 c002a76:	4671      	mov	r1, lr
 c002a78:	4672      	mov	r2, lr
 c002a7a:	4673      	mov	r3, lr
 c002a7c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002a80:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002a84:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002a88:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002a8c:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002a90:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002a94:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002a98:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002a9c:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002aa0:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002aa4:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002aa8:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002aac:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002ab0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002ab4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002ab8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002abc:	f38e 8c00 	msr	CPSR_fs, lr
 c002ac0:	b410      	push	{r4}
 c002ac2:	eef1 ca10 	vmrs	ip, fpscr
 c002ac6:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002aca:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002ace:	ea0c 0c04 	and.w	ip, ip, r4
 c002ad2:	eee1 ca10 	vmsr	fpscr, ip
 c002ad6:	bc10      	pop	{r4}
 c002ad8:	46f4      	mov	ip, lr
 c002ada:	4774      	bxns	lr
 c002adc:	f3af 8000 	nop.w
 c002ae0:	0807f800 	.word	0x0807f800
 c002ae4:	50022000 	.word	0x50022000
 c002ae8:	45670123 	.word	0x45670123
 c002aec:	cdef89ab 	.word	0xcdef89ab
 c002af0:	30000024 	.word	0x30000024
 c002af4:	9abcdef0 	.word	0x9abcdef0
 c002af8:	12345678 	.word	0x12345678
 c002afc:	00000000 	.word	0x00000000

0c002b00 <__acle_se_Secure_WriteFlash_128KB>:

__attribute__((cmse_nonsecure_entry))
void Secure_WriteFlash_128KB(uint32_t *success_words, uint32_t *failed_words)
{
 c002b00:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002b04:	b096      	sub	sp, #88	@ 0x58
 c002b06:	af00      	add	r7, sp, #0
 c002b08:	60f8      	str	r0, [r7, #12]
 c002b0a:	60b9      	str	r1, [r7, #8]
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c002b0c:	a38a      	add	r3, pc, #552	@ (adr r3, c002d38 <__acle_se_Secure_WriteFlash_128KB+0x238>)
 c002b0e:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002b12:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

    //  Pages 64-127 (128KB)
    uint32_t start_addr = 0x08060000;  // Page 64
 c002b16:	4b82      	ldr	r3, [pc, #520]	@ (c002d20 <__acle_se_Secure_WriteFlash_128KB+0x220>)
 c002b18:	637b      	str	r3, [r7, #52]	@ 0x34
    uint32_t end_addr   = 0x0807FFFF;  // Page 127
 c002b1a:	4b82      	ldr	r3, [pc, #520]	@ (c002d24 <__acle_se_Secure_WriteFlash_128KB+0x224>)
 c002b1c:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t total_words = (end_addr - start_addr + 1) / 8;  // 16,384 words
 c002b1e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 c002b20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002b22:	1ad3      	subs	r3, r2, r3
 c002b24:	3301      	adds	r3, #1
 c002b26:	08db      	lsrs	r3, r3, #3
 c002b28:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t success = 0;
 c002b2a:	2300      	movs	r3, #0
 c002b2c:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t failed = 0;
 c002b2e:	2300      	movs	r3, #0
 c002b30:	653b      	str	r3, [r7, #80]	@ 0x50

    HAL_ICACHE_Disable();
 c002b32:	f001 ffdb 	bl	c004aec <HAL_ICACHE_Disable>

    // Unlock NS Flash
    FLASH->NSKEYR = FLASH_KEY1;
 c002b36:	4b7c      	ldr	r3, [pc, #496]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b38:	4a7c      	ldr	r2, [pc, #496]	@ (c002d2c <__acle_se_Secure_WriteFlash_128KB+0x22c>)
 c002b3a:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c002b3c:	4b7a      	ldr	r3, [pc, #488]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b3e:	4a7c      	ldr	r2, [pc, #496]	@ (c002d30 <__acle_se_Secure_WriteFlash_128KB+0x230>)
 c002b40:	609a      	str	r2, [r3, #8]

    if (FLASH->NSCR & FLASH_NSCR_NSLOCK) {
 c002b42:	4b79      	ldr	r3, [pc, #484]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002b46:	2b00      	cmp	r3, #0
 c002b48:	da08      	bge.n	c002b5c <__acle_se_Secure_WriteFlash_128KB+0x5c>
        HAL_ICACHE_Enable();
 c002b4a:	f001 ffbf 	bl	c004acc <HAL_ICACHE_Enable>
        *success_words = 0;
 c002b4e:	68fb      	ldr	r3, [r7, #12]
 c002b50:	2200      	movs	r2, #0
 c002b52:	601a      	str	r2, [r3, #0]
        *failed_words = total_words;
 c002b54:	68bb      	ldr	r3, [r7, #8]
 c002b56:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 c002b58:	601a      	str	r2, [r3, #0]
        return;
 c002b5a:	e0a6      	b.n	c002caa <__acle_se_Secure_WriteFlash_128KB+0x1aa>
    }

    // Force Non-Secure operation
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;
 c002b5c:	4b75      	ldr	r3, [pc, #468]	@ (c002d34 <__acle_se_Secure_WriteFlash_128KB+0x234>)
 c002b5e:	2202      	movs	r2, #2
 c002b60:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;
 c002b62:	4b71      	ldr	r3, [pc, #452]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002b64:	f04f 32ff 	mov.w	r2, #4294967295
 c002b68:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c002b6a:	f3bf 8f4f 	dsb	sy
}
 c002b6e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002b70:	f3bf 8f6f 	isb	sy
}
 c002b74:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Write 128KB ==========
    uint32_t word_index = 0;
 c002b76:	2300      	movs	r3, #0
 c002b78:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002b7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002b7c:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002b7e:	e045      	b.n	c002c0c <__acle_se_Secure_WriteFlash_128KB+0x10c>
        uint64_t value = test_value + word_index;
 c002b80:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002b82:	2200      	movs	r2, #0
 c002b84:	4698      	mov	r8, r3
 c002b86:	4691      	mov	r9, r2
 c002b88:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002b8c:	eb12 0108 	adds.w	r1, r2, r8
 c002b90:	6039      	str	r1, [r7, #0]
 c002b92:	eb43 0309 	adc.w	r3, r3, r9
 c002b96:	607b      	str	r3, [r7, #4]
 c002b98:	e9d7 2300 	ldrd	r2, r3, [r7]
 c002b9c:	e9c7 2304 	strd	r2, r3, [r7, #16]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002ba0:	bf00      	nop
 c002ba2:	4b61      	ldr	r3, [pc, #388]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002ba4:	6a1b      	ldr	r3, [r3, #32]
 c002ba6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002baa:	2b00      	cmp	r3, #0
 c002bac:	d1f9      	bne.n	c002ba2 <__acle_se_Secure_WriteFlash_128KB+0xa2>
        FLASH->NSSR = 0xFFFFFFFF;
 c002bae:	4b5e      	ldr	r3, [pc, #376]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bb0:	f04f 32ff 	mov.w	r2, #4294967295
 c002bb4:	621a      	str	r2, [r3, #32]
        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002bb6:	4b5c      	ldr	r3, [pc, #368]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002bba:	4a5b      	ldr	r2, [pc, #364]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bbc:	f043 0301 	orr.w	r3, r3, #1
 c002bc0:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(value);
 c002bc2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002bc4:	693a      	ldr	r2, [r7, #16]
 c002bc6:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002bc8:	f3bf 8f6f 	isb	sy
}
 c002bcc:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(value >> 32);
 c002bce:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 c002bd2:	f04f 0200 	mov.w	r2, #0
 c002bd6:	f04f 0300 	mov.w	r3, #0
 c002bda:	000a      	movs	r2, r1
 c002bdc:	2300      	movs	r3, #0
 c002bde:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 c002be0:	3104      	adds	r1, #4
 c002be2:	4613      	mov	r3, r2
 c002be4:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002be6:	bf00      	nop
 c002be8:	4b4f      	ldr	r3, [pc, #316]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bea:	6a1b      	ldr	r3, [r3, #32]
 c002bec:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002bf0:	2b00      	cmp	r3, #0
 c002bf2:	d1f9      	bne.n	c002be8 <__acle_se_Secure_WriteFlash_128KB+0xe8>
        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002bf4:	4b4c      	ldr	r3, [pc, #304]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bf6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002bf8:	4a4b      	ldr	r2, [pc, #300]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002bfa:	f023 0301 	bic.w	r3, r3, #1
 c002bfe:	6293      	str	r3, [r2, #40]	@ 0x28

        word_index++;
 c002c00:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002c02:	3301      	adds	r3, #1
 c002c04:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002c06:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002c08:	3308      	adds	r3, #8
 c002c0a:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002c0c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 c002c0e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002c10:	429a      	cmp	r2, r3
 c002c12:	d9b5      	bls.n	c002b80 <__acle_se_Secure_WriteFlash_128KB+0x80>
  __ASM volatile ("dsb 0xF":::"memory");
 c002c14:	f3bf 8f4f 	dsb	sy
}
 c002c18:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002c1a:	f3bf 8f6f 	isb	sy
}
 c002c1e:	bf00      	nop

    __DSB();
    __ISB();

    // Invalidate Cache
    HAL_ICACHE_Invalidate();
 c002c20:	f001 ff94 	bl	c004b4c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c002c24:	f3bf 8f4f 	dsb	sy
}
 c002c28:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002c2a:	f3bf 8f6f 	isb	sy
}
 c002c2e:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    word_index = 0;
 c002c30:	2300      	movs	r3, #0
 c002c32:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002c34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002c36:	647b      	str	r3, [r7, #68]	@ 0x44
 c002c38:	e025      	b.n	c002c86 <__acle_se_Secure_WriteFlash_128KB+0x186>
        uint64_t expected = test_value + word_index;
 c002c3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002c3c:	2200      	movs	r2, #0
 c002c3e:	461c      	mov	r4, r3
 c002c40:	4615      	mov	r5, r2
 c002c42:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002c46:	eb12 0a04 	adds.w	sl, r2, r4
 c002c4a:	eb43 0b05 	adc.w	fp, r3, r5
 c002c4e:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        uint64_t actual = *(volatile uint64_t*)addr;
 c002c52:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002c54:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002c58:	e9c7 2306 	strd	r2, r3, [r7, #24]

        if (actual == expected) {
 c002c5c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 c002c60:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 c002c64:	4299      	cmp	r1, r3
 c002c66:	bf08      	it	eq
 c002c68:	4290      	cmpeq	r0, r2
 c002c6a:	d103      	bne.n	c002c74 <__acle_se_Secure_WriteFlash_128KB+0x174>
            success++;
 c002c6c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c002c6e:	3301      	adds	r3, #1
 c002c70:	657b      	str	r3, [r7, #84]	@ 0x54
 c002c72:	e002      	b.n	c002c7a <__acle_se_Secure_WriteFlash_128KB+0x17a>
        } else {
            failed++;
 c002c74:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c002c76:	3301      	adds	r3, #1
 c002c78:	653b      	str	r3, [r7, #80]	@ 0x50
        }

        word_index++;
 c002c7a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002c7c:	3301      	adds	r3, #1
 c002c7e:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002c80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002c82:	3308      	adds	r3, #8
 c002c84:	647b      	str	r3, [r7, #68]	@ 0x44
 c002c86:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 c002c88:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002c8a:	429a      	cmp	r2, r3
 c002c8c:	d9d5      	bls.n	c002c3a <__acle_se_Secure_WriteFlash_128KB+0x13a>
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002c8e:	4b26      	ldr	r3, [pc, #152]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002c90:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002c92:	4a25      	ldr	r2, [pc, #148]	@ (c002d28 <__acle_se_Secure_WriteFlash_128KB+0x228>)
 c002c94:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002c98:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002c9a:	f001 ff17 	bl	c004acc <HAL_ICACHE_Enable>

    *success_words = success;
 c002c9e:	68fb      	ldr	r3, [r7, #12]
 c002ca0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 c002ca2:	601a      	str	r2, [r3, #0]
    *failed_words = failed;
 c002ca4:	68bb      	ldr	r3, [r7, #8]
 c002ca6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c002ca8:	601a      	str	r2, [r3, #0]
}
 c002caa:	3758      	adds	r7, #88	@ 0x58
 c002cac:	46bd      	mov	sp, r7
 c002cae:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002cb2:	4670      	mov	r0, lr
 c002cb4:	4671      	mov	r1, lr
 c002cb6:	4672      	mov	r2, lr
 c002cb8:	4673      	mov	r3, lr
 c002cba:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002cbe:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002cc2:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002cc6:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002cca:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002cce:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002cd2:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002cd6:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002cda:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002cde:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002ce2:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002ce6:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002cea:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002cee:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002cf2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002cf6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002cfa:	f38e 8c00 	msr	CPSR_fs, lr
 c002cfe:	b410      	push	{r4}
 c002d00:	eef1 ca10 	vmrs	ip, fpscr
 c002d04:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002d08:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002d0c:	ea0c 0c04 	and.w	ip, ip, r4
 c002d10:	eee1 ca10 	vmsr	fpscr, ip
 c002d14:	bc10      	pop	{r4}
 c002d16:	46f4      	mov	ip, lr
 c002d18:	4774      	bxns	lr
 c002d1a:	bf00      	nop
 c002d1c:	f3af 8000 	nop.w
 c002d20:	08060000 	.word	0x08060000
 c002d24:	0807ffff 	.word	0x0807ffff
 c002d28:	50022000 	.word	0x50022000
 c002d2c:	45670123 	.word	0x45670123
 c002d30:	cdef89ab 	.word	0xcdef89ab
 c002d34:	30000024 	.word	0x30000024
 c002d38:	9abcdef0 	.word	0x9abcdef0
 c002d3c:	12345678 	.word	0x12345678

0c002d40 <__acle_se_Secure_WriteFlash_128KB_2>:


__attribute__((cmse_nonsecure_entry))
void Secure_WriteFlash_128KB_2(uint32_t *success_words, uint32_t *failed_words)
{
 c002d40:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002d44:	b096      	sub	sp, #88	@ 0x58
 c002d46:	af00      	add	r7, sp, #0
 c002d48:	60f8      	str	r0, [r7, #12]
 c002d4a:	60b9      	str	r1, [r7, #8]
    uint64_t test_value = 0x123456789ABCDEF0ULL;
 c002d4c:	a38a      	add	r3, pc, #552	@ (adr r3, c002f78 <__acle_se_Secure_WriteFlash_128KB_2+0x238>)
 c002d4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002d52:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38

    //  Pages 64-127 (128KB)
    uint32_t start_addr = 0x08060000;  // Page 64
 c002d56:	4b82      	ldr	r3, [pc, #520]	@ (c002f60 <__acle_se_Secure_WriteFlash_128KB_2+0x220>)
 c002d58:	637b      	str	r3, [r7, #52]	@ 0x34
    uint32_t end_addr   = 0x0807FFFF;  // Page 127
 c002d5a:	4b82      	ldr	r3, [pc, #520]	@ (c002f64 <__acle_se_Secure_WriteFlash_128KB_2+0x224>)
 c002d5c:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t total_words = (end_addr - start_addr + 1) / 8;  // 16,384 words
 c002d5e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 c002d60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002d62:	1ad3      	subs	r3, r2, r3
 c002d64:	3301      	adds	r3, #1
 c002d66:	08db      	lsrs	r3, r3, #3
 c002d68:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t success = 0;
 c002d6a:	2300      	movs	r3, #0
 c002d6c:	657b      	str	r3, [r7, #84]	@ 0x54
    uint32_t failed = 0;
 c002d6e:	2300      	movs	r3, #0
 c002d70:	653b      	str	r3, [r7, #80]	@ 0x50

    HAL_ICACHE_Disable();
 c002d72:	f001 febb 	bl	c004aec <HAL_ICACHE_Disable>

    // Unlock NS Flash
    FLASH->NSKEYR = FLASH_KEY1;
 c002d76:	4b7c      	ldr	r3, [pc, #496]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002d78:	4a7c      	ldr	r2, [pc, #496]	@ (c002f6c <__acle_se_Secure_WriteFlash_128KB_2+0x22c>)
 c002d7a:	609a      	str	r2, [r3, #8]
    FLASH->NSKEYR = FLASH_KEY2;
 c002d7c:	4b7a      	ldr	r3, [pc, #488]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002d7e:	4a7c      	ldr	r2, [pc, #496]	@ (c002f70 <__acle_se_Secure_WriteFlash_128KB_2+0x230>)
 c002d80:	609a      	str	r2, [r3, #8]

    if (FLASH->NSCR & FLASH_NSCR_NSLOCK) {
 c002d82:	4b79      	ldr	r3, [pc, #484]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002d84:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002d86:	2b00      	cmp	r3, #0
 c002d88:	da08      	bge.n	c002d9c <__acle_se_Secure_WriteFlash_128KB_2+0x5c>
        HAL_ICACHE_Enable();
 c002d8a:	f001 fe9f 	bl	c004acc <HAL_ICACHE_Enable>
        *success_words = 0;
 c002d8e:	68fb      	ldr	r3, [r7, #12]
 c002d90:	2200      	movs	r2, #0
 c002d92:	601a      	str	r2, [r3, #0]
        *failed_words = total_words;
 c002d94:	68bb      	ldr	r3, [r7, #8]
 c002d96:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 c002d98:	601a      	str	r2, [r3, #0]
        return;
 c002d9a:	e0a6      	b.n	c002eea <__acle_se_Secure_WriteFlash_128KB_2+0x1aa>
    }

    // Force Non-Secure operation
    extern FLASH_ProcessTypeDef pFlash;
    pFlash.ProcedureOnGoing = FLASH_TYPEERASE_PAGES;
 c002d9c:	4b75      	ldr	r3, [pc, #468]	@ (c002f74 <__acle_se_Secure_WriteFlash_128KB_2+0x234>)
 c002d9e:	2202      	movs	r2, #2
 c002da0:	609a      	str	r2, [r3, #8]

    FLASH->NSSR = 0xFFFFFFFF;
 c002da2:	4b71      	ldr	r3, [pc, #452]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002da4:	f04f 32ff 	mov.w	r2, #4294967295
 c002da8:	621a      	str	r2, [r3, #32]
  __ASM volatile ("dsb 0xF":::"memory");
 c002daa:	f3bf 8f4f 	dsb	sy
}
 c002dae:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002db0:	f3bf 8f6f 	isb	sy
}
 c002db4:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Write 128KB ==========
    uint32_t word_index = 0;
 c002db6:	2300      	movs	r3, #0
 c002db8:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002dba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002dbc:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002dbe:	e045      	b.n	c002e4c <__acle_se_Secure_WriteFlash_128KB_2+0x10c>
        uint64_t value = test_value + word_index;
 c002dc0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002dc2:	2200      	movs	r2, #0
 c002dc4:	4698      	mov	r8, r3
 c002dc6:	4691      	mov	r9, r2
 c002dc8:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002dcc:	eb12 0108 	adds.w	r1, r2, r8
 c002dd0:	6039      	str	r1, [r7, #0]
 c002dd2:	eb43 0309 	adc.w	r3, r3, r9
 c002dd6:	607b      	str	r3, [r7, #4]
 c002dd8:	e9d7 2300 	ldrd	r2, r3, [r7]
 c002ddc:	e9c7 2304 	strd	r2, r3, [r7, #16]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002de0:	bf00      	nop
 c002de2:	4b61      	ldr	r3, [pc, #388]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002de4:	6a1b      	ldr	r3, [r3, #32]
 c002de6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002dea:	2b00      	cmp	r3, #0
 c002dec:	d1f9      	bne.n	c002de2 <__acle_se_Secure_WriteFlash_128KB_2+0xa2>
        FLASH->NSSR = 0xFFFFFFFF;
 c002dee:	4b5e      	ldr	r3, [pc, #376]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002df0:	f04f 32ff 	mov.w	r2, #4294967295
 c002df4:	621a      	str	r2, [r3, #32]
        SET_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002df6:	4b5c      	ldr	r3, [pc, #368]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002df8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002dfa:	4a5b      	ldr	r2, [pc, #364]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002dfc:	f043 0301 	orr.w	r3, r3, #1
 c002e00:	6293      	str	r3, [r2, #40]	@ 0x28

        *(volatile uint32_t*)addr = (uint32_t)(test_value);
 c002e02:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002e04:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 c002e06:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002e08:	f3bf 8f6f 	isb	sy
}
 c002e0c:	bf00      	nop
        __ISB();
        *(volatile uint32_t*)(addr + 4) = (uint32_t)(test_value >> 32);
 c002e0e:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 c002e12:	f04f 0200 	mov.w	r2, #0
 c002e16:	f04f 0300 	mov.w	r3, #0
 c002e1a:	000a      	movs	r2, r1
 c002e1c:	2300      	movs	r3, #0
 c002e1e:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 c002e20:	3104      	adds	r1, #4
 c002e22:	4613      	mov	r3, r2
 c002e24:	600b      	str	r3, [r1, #0]

        while (FLASH->NSSR & FLASH_NSSR_NSBSY);
 c002e26:	bf00      	nop
 c002e28:	4b4f      	ldr	r3, [pc, #316]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e2a:	6a1b      	ldr	r3, [r3, #32]
 c002e2c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c002e30:	2b00      	cmp	r3, #0
 c002e32:	d1f9      	bne.n	c002e28 <__acle_se_Secure_WriteFlash_128KB_2+0xe8>
        CLEAR_BIT(FLASH->NSCR, FLASH_NSCR_NSPG);
 c002e34:	4b4c      	ldr	r3, [pc, #304]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e36:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002e38:	4a4b      	ldr	r2, [pc, #300]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002e3a:	f023 0301 	bic.w	r3, r3, #1
 c002e3e:	6293      	str	r3, [r2, #40]	@ 0x28

        word_index++;
 c002e40:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002e42:	3301      	adds	r3, #1
 c002e44:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002e46:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 c002e48:	3308      	adds	r3, #8
 c002e4a:	64bb      	str	r3, [r7, #72]	@ 0x48
 c002e4c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 c002e4e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002e50:	429a      	cmp	r2, r3
 c002e52:	d9b5      	bls.n	c002dc0 <__acle_se_Secure_WriteFlash_128KB_2+0x80>
  __ASM volatile ("dsb 0xF":::"memory");
 c002e54:	f3bf 8f4f 	dsb	sy
}
 c002e58:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002e5a:	f3bf 8f6f 	isb	sy
}
 c002e5e:	bf00      	nop

    __DSB();
    __ISB();

    // Invalidate Cache
    HAL_ICACHE_Invalidate();
 c002e60:	f001 fe74 	bl	c004b4c <HAL_ICACHE_Invalidate>
  __ASM volatile ("dsb 0xF":::"memory");
 c002e64:	f3bf 8f4f 	dsb	sy
}
 c002e68:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c002e6a:	f3bf 8f6f 	isb	sy
}
 c002e6e:	bf00      	nop
    __DSB();
    __ISB();

    // ========== Verify ==========
    word_index = 0;
 c002e70:	2300      	movs	r3, #0
 c002e72:	64fb      	str	r3, [r7, #76]	@ 0x4c

    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002e74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 c002e76:	647b      	str	r3, [r7, #68]	@ 0x44
 c002e78:	e025      	b.n	c002ec6 <__acle_se_Secure_WriteFlash_128KB_2+0x186>
        uint64_t expected = test_value + word_index;
 c002e7a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002e7c:	2200      	movs	r2, #0
 c002e7e:	461c      	mov	r4, r3
 c002e80:	4615      	mov	r5, r2
 c002e82:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 c002e86:	eb12 0a04 	adds.w	sl, r2, r4
 c002e8a:	eb43 0b05 	adc.w	fp, r3, r5
 c002e8e:	e9c7 ab08 	strd	sl, fp, [r7, #32]
        uint64_t actual = *(volatile uint64_t*)addr;
 c002e92:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002e94:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002e98:	e9c7 2306 	strd	r2, r3, [r7, #24]

        if (actual == expected) {
 c002e9c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 c002ea0:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 c002ea4:	4299      	cmp	r1, r3
 c002ea6:	bf08      	it	eq
 c002ea8:	4290      	cmpeq	r0, r2
 c002eaa:	d103      	bne.n	c002eb4 <__acle_se_Secure_WriteFlash_128KB_2+0x174>
            success++;
 c002eac:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 c002eae:	3301      	adds	r3, #1
 c002eb0:	657b      	str	r3, [r7, #84]	@ 0x54
 c002eb2:	e002      	b.n	c002eba <__acle_se_Secure_WriteFlash_128KB_2+0x17a>
        } else {
            failed++;
 c002eb4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 c002eb6:	3301      	adds	r3, #1
 c002eb8:	653b      	str	r3, [r7, #80]	@ 0x50
        }

        word_index++;
 c002eba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 c002ebc:	3301      	adds	r3, #1
 c002ebe:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for (uint32_t addr = start_addr; addr <= end_addr; addr += 8) {
 c002ec0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 c002ec2:	3308      	adds	r3, #8
 c002ec4:	647b      	str	r3, [r7, #68]	@ 0x44
 c002ec6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 c002ec8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 c002eca:	429a      	cmp	r2, r3
 c002ecc:	d9d5      	bls.n	c002e7a <__acle_se_Secure_WriteFlash_128KB_2+0x13a>
    }

    SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002ece:	4b26      	ldr	r3, [pc, #152]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002ed0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c002ed2:	4a25      	ldr	r2, [pc, #148]	@ (c002f68 <__acle_se_Secure_WriteFlash_128KB_2+0x228>)
 c002ed4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c002ed8:	6293      	str	r3, [r2, #40]	@ 0x28
    HAL_ICACHE_Enable();
 c002eda:	f001 fdf7 	bl	c004acc <HAL_ICACHE_Enable>

    *success_words = success;
 c002ede:	68fb      	ldr	r3, [r7, #12]
 c002ee0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 c002ee2:	601a      	str	r2, [r3, #0]
    *failed_words = failed;
 c002ee4:	68bb      	ldr	r3, [r7, #8]
 c002ee6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 c002ee8:	601a      	str	r2, [r3, #0]
}
 c002eea:	3758      	adds	r7, #88	@ 0x58
 c002eec:	46bd      	mov	sp, r7
 c002eee:	e8bd 4fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 c002ef2:	4670      	mov	r0, lr
 c002ef4:	4671      	mov	r1, lr
 c002ef6:	4672      	mov	r2, lr
 c002ef8:	4673      	mov	r3, lr
 c002efa:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c002efe:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c002f02:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c002f06:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c002f0a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c002f0e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c002f12:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c002f16:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c002f1a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c002f1e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c002f22:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c002f26:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c002f2a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c002f2e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c002f32:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c002f36:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c002f3a:	f38e 8c00 	msr	CPSR_fs, lr
 c002f3e:	b410      	push	{r4}
 c002f40:	eef1 ca10 	vmrs	ip, fpscr
 c002f44:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c002f48:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c002f4c:	ea0c 0c04 	and.w	ip, ip, r4
 c002f50:	eee1 ca10 	vmsr	fpscr, ip
 c002f54:	bc10      	pop	{r4}
 c002f56:	46f4      	mov	ip, lr
 c002f58:	4774      	bxns	lr
 c002f5a:	bf00      	nop
 c002f5c:	f3af 8000 	nop.w
 c002f60:	08060000 	.word	0x08060000
 c002f64:	0807ffff 	.word	0x0807ffff
 c002f68:	50022000 	.word	0x50022000
 c002f6c:	45670123 	.word	0x45670123
 c002f70:	cdef89ab 	.word	0xcdef89ab
 c002f74:	30000024 	.word	0x30000024
 c002f78:	9abcdef0 	.word	0x9abcdef0
 c002f7c:	12345678 	.word	0x12345678

0c002f80 <__acle_se_Secure_Flash256KB>:
//    }
//}

__attribute__((cmse_nonsecure_entry))
void Secure_Flash256KB(FlashResult_t *result)
{
 c002f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c002f84:	b0b7      	sub	sp, #220	@ 0xdc
 c002f86:	af02      	add	r7, sp, #8
 c002f88:	61f8      	str	r0, [r7, #28]
 c002f8a:	466b      	mov	r3, sp
 c002f8c:	461e      	mov	r6, r3
	// just run 10 pages
    if (!result) return;
 c002f8e:	69fb      	ldr	r3, [r7, #28]
 c002f90:	2b00      	cmp	r3, #0
 c002f92:	f000 8229 	beq.w	c0033e8 <__acle_se_Secure_Flash256KB+0x468>

    //   Pages 128-137 (Non-secure area,  Secure World )
    const uint32_t START_PAGE = 246;
 c002f96:	23f6      	movs	r3, #246	@ 0xf6
 c002f98:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    const uint32_t TOTAL_PAGES = 10;   //  10 pages = 20 KB
 c002f9c:	230a      	movs	r3, #10
 c002f9e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    const uint32_t PAGE_SIZE = 0x800;
 c002fa2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 c002fa6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    const uint32_t BANK2_BASE = 0x08040000;
 c002faa:	4bbb      	ldr	r3, [pc, #748]	@ (c003298 <__acle_se_Secure_Flash256KB+0x318>)
 c002fac:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    const uint32_t DW_PER_PAGE = 256;
 c002fb0:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c002fb4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    const uint64_t FLASH_TEST_DATA_BASE = 0x1234567890ABCDEFULL;
 c002fb8:	a3b5      	add	r3, pc, #724	@ (adr r3, c003290 <__acle_se_Secure_Flash256KB+0x310>)
 c002fba:	e9d3 2300 	ldrd	r2, r3, [r3]
 c002fbe:	e9c7 2328 	strd	r2, r3, [r7, #160]	@ 0xa0

    HAL_StatusTypeDef status;
    uint32_t PageError = 0;
 c002fc2:	2300      	movs	r3, #0
 c002fc4:	65fb      	str	r3, [r7, #92]	@ 0x5c

    result->total_pages = TOTAL_PAGES;
 c002fc6:	69fa      	ldr	r2, [r7, #28]
 c002fc8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c002fcc:	6013      	str	r3, [r2, #0]
    result->success_pages = 0;
 c002fce:	69fa      	ldr	r2, [r7, #28]
 c002fd0:	2300      	movs	r3, #0
 c002fd2:	6053      	str	r3, [r2, #4]
    result->failed_pages = 0;
 c002fd4:	69fa      	ldr	r2, [r7, #28]
 c002fd6:	2300      	movs	r3, #0
 c002fd8:	6093      	str	r3, [r2, #8]
    result->total_words = 0;
 c002fda:	69fa      	ldr	r2, [r7, #28]
 c002fdc:	2300      	movs	r3, #0
 c002fde:	60d3      	str	r3, [r2, #12]
    result->success_words = 0;
 c002fe0:	69fa      	ldr	r2, [r7, #28]
 c002fe2:	2300      	movs	r3, #0
 c002fe4:	6113      	str	r3, [r2, #16]
    result->failed_words = 0;
 c002fe6:	69fa      	ldr	r2, [r7, #28]
 c002fe8:	2300      	movs	r3, #0
 c002fea:	6153      	str	r3, [r2, #20]

    // --- BB Attribute Management Variables ---
    FLASH_BBAttributesTypeDef flash_bb_attr = {0};
 c002fec:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 c002ff0:	2300      	movs	r3, #0
 c002ff2:	6013      	str	r3, [r2, #0]
 c002ff4:	6053      	str	r3, [r2, #4]
 c002ff6:	6093      	str	r3, [r2, #8]
 c002ff8:	60d3      	str	r3, [r2, #12]
 c002ffa:	6113      	str	r3, [r2, #16]
 c002ffc:	6153      	str	r3, [r2, #20]
    uint32_t saved_attr_array[4] = {0}; // Bank 2 has 128 pages, 128/32 = 4 uint32_t values
 c002ffe:	f107 0234 	add.w	r2, r7, #52	@ 0x34
 c003002:	2300      	movs	r3, #0
 c003004:	6013      	str	r3, [r2, #0]
 c003006:	6053      	str	r3, [r2, #4]
 c003008:	6093      	str	r3, [r2, #8]
 c00300a:	60d3      	str	r3, [r2, #12]
    uint8_t original_page_is_secure[TOTAL_PAGES];
 c00300c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003010:	3b01      	subs	r3, #1
 c003012:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 c003016:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c00301a:	2200      	movs	r2, #0
 c00301c:	461c      	mov	r4, r3
 c00301e:	4615      	mov	r5, r2
 c003020:	f04f 0200 	mov.w	r2, #0
 c003024:	f04f 0300 	mov.w	r3, #0
 c003028:	00eb      	lsls	r3, r5, #3
 c00302a:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 c00302e:	00e2      	lsls	r2, r4, #3
 c003030:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003034:	2200      	movs	r2, #0
 c003036:	469a      	mov	sl, r3
 c003038:	4693      	mov	fp, r2
 c00303a:	f04f 0200 	mov.w	r2, #0
 c00303e:	f04f 0300 	mov.w	r3, #0
 c003042:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 c003046:	ea43 735a 	orr.w	r3, r3, sl, lsr #29
 c00304a:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 c00304e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c003052:	3307      	adds	r3, #7
 c003054:	08db      	lsrs	r3, r3, #3
 c003056:	00db      	lsls	r3, r3, #3
 c003058:	ebad 0d03 	sub.w	sp, sp, r3
 c00305c:	ab02      	add	r3, sp, #8
 c00305e:	3300      	adds	r3, #0
 c003060:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98

    flash_bb_attr.Bank = FLASH_BANK_2;
 c003064:	2302      	movs	r3, #2
 c003066:	647b      	str	r3, [r7, #68]	@ 0x44
    flash_bb_attr.BBAttributesType = FLASH_BB_SEC;
 c003068:	2301      	movs	r3, #1
 c00306a:	64bb      	str	r3, [r7, #72]	@ 0x48
    HAL_FLASHEx_GetConfigBBAttributes(&flash_bb_attr);
 c00306c:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 c003070:	4618      	mov	r0, r3
 c003072:	f001 f94d 	bl	c004310 <HAL_FLASHEx_GetConfigBBAttributes>

    if (status != HAL_OK) {
 c003076:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c00307a:	2b00      	cmp	r3, #0
 c00307c:	f040 81b1 	bne.w	c0033e2 <__acle_se_Secure_Flash256KB+0x462>
            // Cannot proceed if we can't read attributes
        return;
    }

    memcpy(saved_attr_array, flash_bb_attr.BBAttributes_array, sizeof(saved_attr_array));
 c003080:	f107 0434 	add.w	r4, r7, #52	@ 0x34
 c003084:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 c003088:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 c00308a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}


    // --- Step 2: Promote all target pages to SECURE ---
       for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c00308e:	2300      	movs	r3, #0
 c003090:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 c003094:	e047      	b.n	c003126 <__acle_se_Secure_Flash256KB+0x1a6>
           uint32_t page = START_PAGE + i;
 c003096:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 c00309a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c00309e:	4413      	add	r3, r2
 c0030a0:	66bb      	str	r3, [r7, #104]	@ 0x68
           uint32_t attr_index = page / 32;
 c0030a2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c0030a4:	095b      	lsrs	r3, r3, #5
 c0030a6:	667b      	str	r3, [r7, #100]	@ 0x64
           uint32_t attr_bit = page % 32;
 c0030a8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 c0030aa:	f003 031f 	and.w	r3, r3, #31
 c0030ae:	663b      	str	r3, [r7, #96]	@ 0x60

           // Check if it's already secure
           if (flash_bb_attr.BBAttributes_array[attr_index] & (1U << attr_bit)) {
 c0030b0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c0030b2:	3302      	adds	r3, #2
 c0030b4:	009b      	lsls	r3, r3, #2
 c0030b6:	33b8      	adds	r3, #184	@ 0xb8
 c0030b8:	f107 0218 	add.w	r2, r7, #24
 c0030bc:	4413      	add	r3, r2
 c0030be:	f853 2c8c 	ldr.w	r2, [r3, #-140]
 c0030c2:	2101      	movs	r1, #1
 c0030c4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 c0030c6:	fa01 f303 	lsl.w	r3, r1, r3
 c0030ca:	4013      	ands	r3, r2
 c0030cc:	2b00      	cmp	r3, #0
 c0030ce:	d007      	beq.n	c0030e0 <__acle_se_Secure_Flash256KB+0x160>
               original_page_is_secure[i] = 1;
 c0030d0:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 c0030d4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c0030d8:	4413      	add	r3, r2
 c0030da:	2201      	movs	r2, #1
 c0030dc:	701a      	strb	r2, [r3, #0]
 c0030de:	e01d      	b.n	c00311c <__acle_se_Secure_Flash256KB+0x19c>
           } else {
               original_page_is_secure[i] = 0;
 c0030e0:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 c0030e4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c0030e8:	4413      	add	r3, r2
 c0030ea:	2200      	movs	r2, #0
 c0030ec:	701a      	strb	r2, [r3, #0]
               // Set bit to make page Secure
               flash_bb_attr.BBAttributes_array[attr_index] |= (1U << attr_bit);
 c0030ee:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c0030f0:	3302      	adds	r3, #2
 c0030f2:	009b      	lsls	r3, r3, #2
 c0030f4:	33b8      	adds	r3, #184	@ 0xb8
 c0030f6:	f107 0218 	add.w	r2, r7, #24
 c0030fa:	4413      	add	r3, r2
 c0030fc:	f853 2c8c 	ldr.w	r2, [r3, #-140]
 c003100:	2101      	movs	r1, #1
 c003102:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 c003104:	fa01 f303 	lsl.w	r3, r1, r3
 c003108:	431a      	orrs	r2, r3
 c00310a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 c00310c:	3302      	adds	r3, #2
 c00310e:	009b      	lsls	r3, r3, #2
 c003110:	33b8      	adds	r3, #184	@ 0xb8
 c003112:	f107 0118 	add.w	r1, r7, #24
 c003116:	440b      	add	r3, r1
 c003118:	f843 2c8c 	str.w	r2, [r3, #-140]
       for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c00311c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 c003120:	3301      	adds	r3, #1
 c003122:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 c003126:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 c00312a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c00312e:	429a      	cmp	r2, r3
 c003130:	d3b1      	bcc.n	c003096 <__acle_se_Secure_Flash256KB+0x116>
           }
       }

       // Apply the new (all-secure) attributes
          status = HAL_FLASHEx_ConfigBBAttributes(&flash_bb_attr);
 c003132:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 c003136:	4618      	mov	r0, r3
 c003138:	f001 f8a0 	bl	c00427c <HAL_FLASHEx_ConfigBBAttributes>
 c00313c:	4603      	mov	r3, r0
 c00313e:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
          if (status != HAL_OK) {
 c003142:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c003146:	2b00      	cmp	r3, #0
 c003148:	f040 814d 	bne.w	c0033e6 <__acle_se_Secure_Flash256KB+0x466>
              // Failed to promote pages, cannot proceed
              return;
          }

    uint32_t start_time = HAL_GetTick();
 c00314c:	f000 fd9e 	bl	c003c8c <HAL_GetTick>
 c003150:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90

    status = HAL_FLASH_Unlock();
 c003154:	f000 ff10 	bl	c003f78 <HAL_FLASH_Unlock>
 c003158:	4603      	mov	r3, r0
 c00315a:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
    if (status != HAL_OK) {
 c00315e:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c003162:	2b00      	cmp	r3, #0
 c003164:	d008      	beq.n	c003178 <__acle_se_Secure_Flash256KB+0x1f8>
        result->time_ms = HAL_GetTick() - start_time;
 c003166:	f000 fd91 	bl	c003c8c <HAL_GetTick>
 c00316a:	4602      	mov	r2, r0
 c00316c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 c003170:	1ad2      	subs	r2, r2, r3
 c003172:	69fb      	ldr	r3, [r7, #28]
 c003174:	619a      	str	r2, [r3, #24]
        return;
 c003176:	e137      	b.n	c0033e8 <__acle_se_Secure_Flash256KB+0x468>
    }

    //  Loop Pages 128-137
    for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c003178:	2300      	movs	r3, #0
 c00317a:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 c00317e:	e11d      	b.n	c0033bc <__acle_se_Secure_Flash256KB+0x43c>
        uint32_t page = START_PAGE + i;
 c003180:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 c003184:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 c003188:	4413      	add	r3, r2
 c00318a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        uint32_t page_addr = BANK2_BASE + (page * PAGE_SIZE);
 c00318e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c003192:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 c003196:	fb02 f303 	mul.w	r3, r2, r3
 c00319a:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 c00319e:	4413      	add	r3, r2
 c0031a0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        uint8_t page_ok = 1;
 c0031a4:	2301      	movs	r3, #1
 c0031a6:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7


        // Erase page

        //  Flash 
        while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {};
 c0031aa:	bf00      	nop
 c0031ac:	4b3b      	ldr	r3, [pc, #236]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031ae:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0031b0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c0031b4:	2b00      	cmp	r3, #0
 c0031b6:	d1f9      	bne.n	c0031ac <__acle_se_Secure_Flash256KB+0x22c>

        //  Error Flag 
        if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS)) {
 c0031b8:	4b38      	ldr	r3, [pc, #224]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031ba:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 c0031bc:	4b38      	ldr	r3, [pc, #224]	@ (c0032a0 <__acle_se_Secure_Flash256KB+0x320>)
 c0031be:	4013      	ands	r3, r2
 c0031c0:	2b00      	cmp	r3, #0
 c0031c2:	d00e      	beq.n	c0031e2 <__acle_se_Secure_Flash256KB+0x262>
            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 c0031c4:	4b35      	ldr	r3, [pc, #212]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c0031c8:	4a34      	ldr	r2, [pc, #208]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031ca:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 c0031ce:	6313      	str	r3, [r2, #48]	@ 0x30
 c0031d0:	4b32      	ldr	r3, [pc, #200]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031d2:	6a1b      	ldr	r3, [r3, #32]
 c0031d4:	4a31      	ldr	r2, [pc, #196]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031d6:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 c0031da:	6213      	str	r3, [r2, #32]
 c0031dc:	4b2f      	ldr	r3, [pc, #188]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c0031de:	22fa      	movs	r2, #250	@ 0xfa
 c0031e0:	625a      	str	r2, [r3, #36]	@ 0x24
        }


        FLASH_EraseInitTypeDef EraseInit = {0};
 c0031e2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 c0031e6:	2200      	movs	r2, #0
 c0031e8:	601a      	str	r2, [r3, #0]
 c0031ea:	605a      	str	r2, [r3, #4]
 c0031ec:	609a      	str	r2, [r3, #8]
 c0031ee:	60da      	str	r2, [r3, #12]
        EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 c0031f0:	2302      	movs	r3, #2
 c0031f2:	627b      	str	r3, [r7, #36]	@ 0x24
        EraseInit.Banks = FLASH_BANK_2;
 c0031f4:	2302      	movs	r3, #2
 c0031f6:	62bb      	str	r3, [r7, #40]	@ 0x28
        EraseInit.Page = page;
 c0031f8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c0031fc:	62fb      	str	r3, [r7, #44]	@ 0x2c
        EraseInit.NbPages = 1;
 c0031fe:	2301      	movs	r3, #1
 c003200:	633b      	str	r3, [r7, #48]	@ 0x30

        status = HAL_FLASHEx_Erase(&EraseInit, &PageError);
 c003202:	f107 025c 	add.w	r2, r7, #92	@ 0x5c
 c003206:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 c00320a:	4611      	mov	r1, r2
 c00320c:	4618      	mov	r0, r3
 c00320e:	f000 ffbd 	bl	c00418c <HAL_FLASHEx_Erase>
 c003212:	4603      	mov	r3, r0
 c003214:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
        if (status != HAL_OK || PageError != 0xFFFFFFFF) {
 c003218:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c00321c:	2b00      	cmp	r3, #0
 c00321e:	d103      	bne.n	c003228 <__acle_se_Secure_Flash256KB+0x2a8>
 c003220:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c003222:	f1b3 3fff 	cmp.w	r3, #4294967295
 c003226:	d024      	beq.n	c003272 <__acle_se_Secure_Flash256KB+0x2f2>

        	//  Error Flag 
        	    uint32_t flash_error = HAL_FLASH_GetError();
 c003228:	f000 ff06 	bl	c004038 <HAL_FLASH_GetError>
 c00322c:	66f8      	str	r0, [r7, #108]	@ 0x6c
        	    printf(" Erase FAIL on Page %lu! HAL_Status=%d, Flash_Error_Flags=0x%08lX, PageError=0x%08lX\r\n",
 c00322e:	f897 2097 	ldrb.w	r2, [r7, #151]	@ 0x97
 c003232:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 c003234:	9300      	str	r3, [sp, #0]
 c003236:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 c003238:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
 c00323c:	4819      	ldr	r0, [pc, #100]	@ (c0032a4 <__acle_se_Secure_Flash256KB+0x324>)
 c00323e:	f002 fadb 	bl	c0057f8 <iprintf>
        	           page, status, flash_error, PageError);

        	    //  Flag 
        	    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 c003242:	4b16      	ldr	r3, [pc, #88]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c003244:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c003246:	4a15      	ldr	r2, [pc, #84]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c003248:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 c00324c:	6313      	str	r3, [r2, #48]	@ 0x30
 c00324e:	4b13      	ldr	r3, [pc, #76]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c003250:	6a1b      	ldr	r3, [r3, #32]
 c003252:	4a12      	ldr	r2, [pc, #72]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c003254:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 c003258:	6213      	str	r3, [r2, #32]
 c00325a:	4b10      	ldr	r3, [pc, #64]	@ (c00329c <__acle_se_Secure_Flash256KB+0x31c>)
 c00325c:	22fa      	movs	r2, #250	@ 0xfa
 c00325e:	625a      	str	r2, [r3, #36]	@ 0x24


            result->failed_pages++;
 c003260:	69fb      	ldr	r3, [r7, #28]
 c003262:	689b      	ldr	r3, [r3, #8]
 c003264:	1c5a      	adds	r2, r3, #1
 c003266:	69fb      	ldr	r3, [r7, #28]
 c003268:	609a      	str	r2, [r3, #8]
            page_ok = 0;
 c00326a:	2300      	movs	r3, #0
 c00326c:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
            continue;
 c003270:	e09f      	b.n	c0033b2 <__acle_se_Secure_Flash256KB+0x432>
        }

        InvalidateICache();
 c003272:	f7fe f9e3 	bl	c00163c <InvalidateICache>
  __ASM volatile ("dsb 0xF":::"memory");
 c003276:	f3bf 8f4f 	dsb	sy
}
 c00327a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c00327c:	f3bf 8f6f 	isb	sy
}
 c003280:	bf00      	nop
        __DSB();
        __ISB();

        // Program 256 doublewords (2 KB)
        for (uint32_t dw = 0; dw < DW_PER_PAGE; dw++) {
 c003282:	2300      	movs	r3, #0
 c003284:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 c003288:	e07e      	b.n	c003388 <__acle_se_Secure_Flash256KB+0x408>
 c00328a:	bf00      	nop
 c00328c:	f3af 8000 	nop.w
 c003290:	90abcdef 	.word	0x90abcdef
 c003294:	12345678 	.word	0x12345678
 c003298:	08040000 	.word	0x08040000
 c00329c:	50022000 	.word	0x50022000
 c0032a0:	f00020fa 	.word	0xf00020fa
 c0032a4:	0c006ad8 	.word	0x0c006ad8

            uint64_t test_value = FLASH_TEST_DATA_BASE + page + dw;
 c0032a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 c0032ac:	2200      	movs	r2, #0
 c0032ae:	613b      	str	r3, [r7, #16]
 c0032b0:	617a      	str	r2, [r7, #20]
 c0032b2:	e9d7 2328 	ldrd	r2, r3, [r7, #160]	@ 0xa0
 c0032b6:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
 c0032ba:	4621      	mov	r1, r4
 c0032bc:	eb11 0802 	adds.w	r8, r1, r2
 c0032c0:	4629      	mov	r1, r5
 c0032c2:	eb41 0903 	adc.w	r9, r1, r3
 c0032c6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c0032ca:	2200      	movs	r2, #0
 c0032cc:	60bb      	str	r3, [r7, #8]
 c0032ce:	60fa      	str	r2, [r7, #12]
 c0032d0:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 c0032d4:	460b      	mov	r3, r1
 c0032d6:	eb18 0303 	adds.w	r3, r8, r3
 c0032da:	603b      	str	r3, [r7, #0]
 c0032dc:	4613      	mov	r3, r2
 c0032de:	eb49 0303 	adc.w	r3, r9, r3
 c0032e2:	607b      	str	r3, [r7, #4]
 c0032e4:	e9d7 3400 	ldrd	r3, r4, [r7]
 c0032e8:	e9c7 3420 	strd	r3, r4, [r7, #128]	@ 0x80
            uint32_t target_addr = page_addr + (dw * 8);
 c0032ec:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c0032f0:	00db      	lsls	r3, r3, #3
 c0032f2:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 c0032f6:	4413      	add	r3, r2
 c0032f8:	67fb      	str	r3, [r7, #124]	@ 0x7c

            result->total_words++;
 c0032fa:	69fb      	ldr	r3, [r7, #28]
 c0032fc:	68db      	ldr	r3, [r3, #12]
 c0032fe:	1c5a      	adds	r2, r3, #1
 c003300:	69fb      	ldr	r3, [r7, #28]
 c003302:	60da      	str	r2, [r3, #12]

            status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD,
 c003304:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 c003308:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 c00330a:	2001      	movs	r0, #1
 c00330c:	f000 fdea 	bl	c003ee4 <HAL_FLASH_Program>
 c003310:	4603      	mov	r3, r0
 c003312:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
                                       target_addr,
                                       test_value);

            if (status != HAL_OK) {
 c003316:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 c00331a:	2b00      	cmp	r3, #0
 c00331c:	d008      	beq.n	c003330 <__acle_se_Secure_Flash256KB+0x3b0>
                result->failed_words++;
 c00331e:	69fb      	ldr	r3, [r7, #28]
 c003320:	695b      	ldr	r3, [r3, #20]
 c003322:	1c5a      	adds	r2, r3, #1
 c003324:	69fb      	ldr	r3, [r7, #28]
 c003326:	615a      	str	r2, [r3, #20]
                page_ok = 0;
 c003328:	2300      	movs	r3, #0
 c00332a:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                break;
 c00332e:	e031      	b.n	c003394 <__acle_se_Secure_Flash256KB+0x414>
            }


            InvalidateICache();
 c003330:	f7fe f984 	bl	c00163c <InvalidateICache>
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 c003334:	f3bf 8f5f 	dmb	sy
}
 c003338:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
 c00333a:	f3bf 8f4f 	dsb	sy
}
 c00333e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 c003340:	f3bf 8f6f 	isb	sy
}
 c003344:	bf00      	nop
            __DMB();
            __DSB();
            __ISB();

            // Verify
            uint64_t verify_value = *(volatile uint64_t*)target_addr;
 c003346:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 c003348:	e9d3 2300 	ldrd	r2, r3, [r3]
 c00334c:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70

            if (verify_value == test_value) {
 c003350:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 c003354:	e9d7 2320 	ldrd	r2, r3, [r7, #128]	@ 0x80
 c003358:	4299      	cmp	r1, r3
 c00335a:	bf08      	it	eq
 c00335c:	4290      	cmpeq	r0, r2
 c00335e:	d105      	bne.n	c00336c <__acle_se_Secure_Flash256KB+0x3ec>
                result->success_words++;
 c003360:	69fb      	ldr	r3, [r7, #28]
 c003362:	691b      	ldr	r3, [r3, #16]
 c003364:	1c5a      	adds	r2, r3, #1
 c003366:	69fb      	ldr	r3, [r7, #28]
 c003368:	611a      	str	r2, [r3, #16]
 c00336a:	e008      	b.n	c00337e <__acle_se_Secure_Flash256KB+0x3fe>
            } else {
                result->failed_words++;
 c00336c:	69fb      	ldr	r3, [r7, #28]
 c00336e:	695b      	ldr	r3, [r3, #20]
 c003370:	1c5a      	adds	r2, r3, #1
 c003372:	69fb      	ldr	r3, [r7, #28]
 c003374:	615a      	str	r2, [r3, #20]
                page_ok = 0;
 c003376:	2300      	movs	r3, #0
 c003378:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                break;
 c00337c:	e00a      	b.n	c003394 <__acle_se_Secure_Flash256KB+0x414>
        for (uint32_t dw = 0; dw < DW_PER_PAGE; dw++) {
 c00337e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 c003382:	3301      	adds	r3, #1
 c003384:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 c003388:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 c00338c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 c003390:	429a      	cmp	r2, r3
 c003392:	d389      	bcc.n	c0032a8 <__acle_se_Secure_Flash256KB+0x328>
            }
        }

        if (page_ok) {
 c003394:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 c003398:	2b00      	cmp	r3, #0
 c00339a:	d005      	beq.n	c0033a8 <__acle_se_Secure_Flash256KB+0x428>
            result->success_pages++;
 c00339c:	69fb      	ldr	r3, [r7, #28]
 c00339e:	685b      	ldr	r3, [r3, #4]
 c0033a0:	1c5a      	adds	r2, r3, #1
 c0033a2:	69fb      	ldr	r3, [r7, #28]
 c0033a4:	605a      	str	r2, [r3, #4]
 c0033a6:	e004      	b.n	c0033b2 <__acle_se_Secure_Flash256KB+0x432>
        } else {
            result->failed_pages++;
 c0033a8:	69fb      	ldr	r3, [r7, #28]
 c0033aa:	689b      	ldr	r3, [r3, #8]
 c0033ac:	1c5a      	adds	r2, r3, #1
 c0033ae:	69fb      	ldr	r3, [r7, #28]
 c0033b0:	609a      	str	r2, [r3, #8]
    for (uint32_t i = 0; i < TOTAL_PAGES; i++) {
 c0033b2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 c0033b6:	3301      	adds	r3, #1
 c0033b8:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 c0033bc:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 c0033c0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 c0033c4:	429a      	cmp	r2, r3
 c0033c6:	f4ff aedb 	bcc.w	c003180 <__acle_se_Secure_Flash256KB+0x200>
        }
    }

    HAL_FLASH_Lock();
 c0033ca:	f000 fe0b 	bl	c003fe4 <HAL_FLASH_Lock>

    result->time_ms = HAL_GetTick() - start_time;
 c0033ce:	f000 fc5d 	bl	c003c8c <HAL_GetTick>
 c0033d2:	4602      	mov	r2, r0
 c0033d4:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 c0033d8:	1ad2      	subs	r2, r2, r3
 c0033da:	69fb      	ldr	r3, [r7, #28]
 c0033dc:	619a      	str	r2, [r3, #24]
 c0033de:	46b5      	mov	sp, r6
 c0033e0:	e003      	b.n	c0033ea <__acle_se_Secure_Flash256KB+0x46a>
        return;
 c0033e2:	bf00      	nop
 c0033e4:	e000      	b.n	c0033e8 <__acle_se_Secure_Flash256KB+0x468>
              return;
 c0033e6:	bf00      	nop
    if (!result) return;
 c0033e8:	46b5      	mov	sp, r6
}
 c0033ea:	37d4      	adds	r7, #212	@ 0xd4
 c0033ec:	46bd      	mov	sp, r7
 c0033ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0033f2:	4670      	mov	r0, lr
 c0033f4:	4671      	mov	r1, lr
 c0033f6:	4672      	mov	r2, lr
 c0033f8:	4673      	mov	r3, lr
 c0033fa:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0033fe:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c003402:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003406:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00340a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00340e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c003412:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003416:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00341a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00341e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003422:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003426:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00342a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00342e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003432:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003436:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00343a:	f38e 8c00 	msr	CPSR_fs, lr
 c00343e:	b410      	push	{r4}
 c003440:	eef1 ca10 	vmrs	ip, fpscr
 c003444:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c003448:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00344c:	ea0c 0c04 	and.w	ip, ip, r4
 c003450:	eee1 ca10 	vmsr	fpscr, ip
 c003454:	bc10      	pop	{r4}
 c003456:	46f4      	mov	ip, lr
 c003458:	4774      	bxns	lr
 c00345a:	bf00      	nop

0c00345c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 c00345c:	b580      	push	{r7, lr}
 c00345e:	b084      	sub	sp, #16
 c003460:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c003462:	4b19      	ldr	r3, [pc, #100]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003464:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c003466:	4a18      	ldr	r2, [pc, #96]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003468:	f043 0301 	orr.w	r3, r3, #1
 c00346c:	6613      	str	r3, [r2, #96]	@ 0x60
 c00346e:	4b16      	ldr	r3, [pc, #88]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003470:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 c003472:	f003 0301 	and.w	r3, r3, #1
 c003476:	60fb      	str	r3, [r7, #12]
 c003478:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_PWR_CLK_ENABLE();
 c00347a:	4b13      	ldr	r3, [pc, #76]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c00347c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 c00347e:	4a12      	ldr	r2, [pc, #72]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003480:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 c003484:	6593      	str	r3, [r2, #88]	@ 0x58
 c003486:	4b10      	ldr	r3, [pc, #64]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003488:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 c00348a:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 c00348e:	60bb      	str	r3, [r7, #8]
 c003490:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GTZC_CLK_ENABLE();
 c003492:	4b0d      	ldr	r3, [pc, #52]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003494:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 c003496:	4a0c      	ldr	r2, [pc, #48]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c003498:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 c00349c:	6493      	str	r3, [r2, #72]	@ 0x48
 c00349e:	4b0a      	ldr	r3, [pc, #40]	@ (c0034c8 <HAL_MspInit+0x6c>)
 c0034a0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 c0034a2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c0034a6:	607b      	str	r3, [r7, #4]
 c0034a8:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* GTZC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(GTZC_IRQn, 0, 0);
 c0034aa:	2200      	movs	r2, #0
 c0034ac:	2100      	movs	r1, #0
 c0034ae:	2008      	movs	r0, #8
 c0034b0:	f000 fce3 	bl	c003e7a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(GTZC_IRQn);
 c0034b4:	2008      	movs	r0, #8
 c0034b6:	f000 fcfa 	bl	c003eae <HAL_NVIC_EnableIRQ>

    /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();
 c0034ba:	f001 fba1 	bl	c004c00 <HAL_PWREx_DisableUCPDDeadBattery>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 c0034be:	bf00      	nop
 c0034c0:	3710      	adds	r7, #16
 c0034c2:	46bd      	mov	sp, r7
 c0034c4:	bd80      	pop	{r7, pc}
 c0034c6:	bf00      	nop
 c0034c8:	50021000 	.word	0x50021000

0c0034cc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 c0034cc:	b480      	push	{r7}
 c0034ce:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 c0034d0:	bf00      	nop
 c0034d2:	46bd      	mov	sp, r7
 c0034d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0034d8:	4770      	bx	lr

0c0034da <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 c0034da:	b480      	push	{r7}
 c0034dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 c0034de:	bf00      	nop
 c0034e0:	e7fd      	b.n	c0034de <HardFault_Handler+0x4>

0c0034e2 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 c0034e2:	b480      	push	{r7}
 c0034e4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 c0034e6:	bf00      	nop
 c0034e8:	e7fd      	b.n	c0034e6 <MemManage_Handler+0x4>

0c0034ea <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 c0034ea:	b480      	push	{r7}
 c0034ec:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 c0034ee:	bf00      	nop
 c0034f0:	e7fd      	b.n	c0034ee <BusFault_Handler+0x4>

0c0034f2 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 c0034f2:	b480      	push	{r7}
 c0034f4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 c0034f6:	bf00      	nop
 c0034f8:	e7fd      	b.n	c0034f6 <UsageFault_Handler+0x4>
	...

0c0034fc <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
 c0034fc:	b590      	push	{r4, r7, lr}
 c0034fe:	b083      	sub	sp, #12
 c003500:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */
  funcptr_NS callback_NS; /* non-secure callback function pointer */

  if(pSecureFaultCallback != (funcptr_NS)NULL)
 c003502:	4b1c      	ldr	r3, [pc, #112]	@ (c003574 <SecureFault_Handler+0x78>)
 c003504:	681b      	ldr	r3, [r3, #0]
 c003506:	2b00      	cmp	r3, #0
 c003508:	d02f      	beq.n	c00356a <SecureFault_Handler+0x6e>
  {
   /* return function pointer with cleared LSB */
   callback_NS = (funcptr_NS)cmse_nsfptr_create(pSecureFaultCallback);
 c00350a:	4b1a      	ldr	r3, [pc, #104]	@ (c003574 <SecureFault_Handler+0x78>)
 c00350c:	681b      	ldr	r3, [r3, #0]
 c00350e:	f023 0301 	bic.w	r3, r3, #1
 c003512:	607b      	str	r3, [r7, #4]

   callback_NS();
 c003514:	687b      	ldr	r3, [r7, #4]
 c003516:	461c      	mov	r4, r3
 c003518:	0864      	lsrs	r4, r4, #1
 c00351a:	0064      	lsls	r4, r4, #1
 c00351c:	4620      	mov	r0, r4
 c00351e:	4621      	mov	r1, r4
 c003520:	4622      	mov	r2, r4
 c003522:	4623      	mov	r3, r4
 c003524:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c003528:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c00352c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003530:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c003534:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c003538:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c00353c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003540:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c003544:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003548:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c00354c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003550:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c003554:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003558:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c00355c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003560:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c003564:	f7fc fe70 	bl	c000248 <__gnu_cmse_nonsecure_call>
   return ;
 c003568:	e000      	b.n	c00356c <SecureFault_Handler+0x70>
  }
  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
 c00356a:	e7fe      	b.n	c00356a <SecureFault_Handler+0x6e>
  {
    /* USER CODE BEGIN W1_SecureFault_IRQn 0 */
    /* USER CODE END W1_SecureFault_IRQn 0 */
  }
}
 c00356c:	370c      	adds	r7, #12
 c00356e:	46bd      	mov	sp, r7
 c003570:	bd90      	pop	{r4, r7, pc}
 c003572:	bf00      	nop
 c003574:	300000bc 	.word	0x300000bc

0c003578 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 c003578:	b480      	push	{r7}
 c00357a:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 c00357c:	bf00      	nop
 c00357e:	46bd      	mov	sp, r7
 c003580:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003584:	4770      	bx	lr

0c003586 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 c003586:	b480      	push	{r7}
 c003588:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 c00358a:	bf00      	nop
 c00358c:	46bd      	mov	sp, r7
 c00358e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003592:	4770      	bx	lr

0c003594 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 c003594:	b480      	push	{r7}
 c003596:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 c003598:	bf00      	nop
 c00359a:	46bd      	mov	sp, r7
 c00359c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0035a0:	4770      	bx	lr

0c0035a2 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 c0035a2:	b580      	push	{r7, lr}
 c0035a4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 c0035a6:	f000 fb5d 	bl	c003c64 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 c0035aa:	bf00      	nop
 c0035ac:	bd80      	pop	{r7, pc}
	...

0c0035b0 <GTZC_IRQHandler>:

/**
  * @brief This function handles Global TrustZone controller global interrupt.
  */
void GTZC_IRQHandler(void)
{
 c0035b0:	b590      	push	{r4, r7, lr}
 c0035b2:	b083      	sub	sp, #12
 c0035b4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN GTZC_IRQn 0 */
  funcptr_NS callback_NS; /* non-secure callback function pointer */
  /* USER CODE END GTZC_IRQn 0 */
  HAL_GTZC_IRQHandler();
 c0035b6:	f001 f9db 	bl	c004970 <HAL_GTZC_IRQHandler>
  /* USER CODE BEGIN GTZC_IRQn 1 */
  if(pSecureErrorCallback != (funcptr_NS)NULL)
 c0035ba:	4b1c      	ldr	r3, [pc, #112]	@ (c00362c <GTZC_IRQHandler+0x7c>)
 c0035bc:	681b      	ldr	r3, [r3, #0]
 c0035be:	2b00      	cmp	r3, #0
 c0035c0:	d02f      	beq.n	c003622 <GTZC_IRQHandler+0x72>
  {
   /* return function pointer with cleared LSB */
   callback_NS = (funcptr_NS)cmse_nsfptr_create(pSecureErrorCallback);
 c0035c2:	4b1a      	ldr	r3, [pc, #104]	@ (c00362c <GTZC_IRQHandler+0x7c>)
 c0035c4:	681b      	ldr	r3, [r3, #0]
 c0035c6:	f023 0301 	bic.w	r3, r3, #1
 c0035ca:	607b      	str	r3, [r7, #4]

   callback_NS();
 c0035cc:	687b      	ldr	r3, [r7, #4]
 c0035ce:	461c      	mov	r4, r3
 c0035d0:	0864      	lsrs	r4, r4, #1
 c0035d2:	0064      	lsls	r4, r4, #1
 c0035d4:	4620      	mov	r0, r4
 c0035d6:	4621      	mov	r1, r4
 c0035d8:	4622      	mov	r2, r4
 c0035da:	4623      	mov	r3, r4
 c0035dc:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0035e0:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0035e4:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0035e8:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0035ec:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0035f0:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0035f4:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0035f8:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0035fc:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003600:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003604:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003608:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00360c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003610:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003614:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003618:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00361c:	f7fc fe14 	bl	c000248 <__gnu_cmse_nonsecure_call>
  {
    /* Something went wrong in test case */
    while(1);
  }
  /* USER CODE END GTZC_IRQn 1 */
}
 c003620:	e000      	b.n	c003624 <GTZC_IRQHandler+0x74>
    while(1);
 c003622:	e7fe      	b.n	c003622 <GTZC_IRQHandler+0x72>
}
 c003624:	370c      	adds	r7, #12
 c003626:	46bd      	mov	sp, r7
 c003628:	bd90      	pop	{r4, r7, pc}
 c00362a:	bf00      	nop
 c00362c:	300000c0 	.word	0x300000c0

0c003630 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 c003630:	b480      	push	{r7}
 c003632:	af00      	add	r7, sp, #0
  return 1;
 c003634:	2301      	movs	r3, #1
}
 c003636:	4618      	mov	r0, r3
 c003638:	46bd      	mov	sp, r7
 c00363a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00363e:	4770      	bx	lr

0c003640 <_kill>:

int _kill(int pid, int sig)
{
 c003640:	b580      	push	{r7, lr}
 c003642:	b082      	sub	sp, #8
 c003644:	af00      	add	r7, sp, #0
 c003646:	6078      	str	r0, [r7, #4]
 c003648:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 c00364a:	f002 fa8f 	bl	c005b6c <__errno>
 c00364e:	4603      	mov	r3, r0
 c003650:	2216      	movs	r2, #22
 c003652:	601a      	str	r2, [r3, #0]
  return -1;
 c003654:	f04f 33ff 	mov.w	r3, #4294967295
}
 c003658:	4618      	mov	r0, r3
 c00365a:	3708      	adds	r7, #8
 c00365c:	46bd      	mov	sp, r7
 c00365e:	bd80      	pop	{r7, pc}

0c003660 <_exit>:

void _exit (int status)
{
 c003660:	b580      	push	{r7, lr}
 c003662:	b082      	sub	sp, #8
 c003664:	af00      	add	r7, sp, #0
 c003666:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 c003668:	f04f 31ff 	mov.w	r1, #4294967295
 c00366c:	6878      	ldr	r0, [r7, #4]
 c00366e:	f7ff ffe7 	bl	c003640 <_kill>
  while (1) {}    /* Make sure we hang here */
 c003672:	bf00      	nop
 c003674:	e7fd      	b.n	c003672 <_exit+0x12>

0c003676 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 c003676:	b580      	push	{r7, lr}
 c003678:	b086      	sub	sp, #24
 c00367a:	af00      	add	r7, sp, #0
 c00367c:	60f8      	str	r0, [r7, #12]
 c00367e:	60b9      	str	r1, [r7, #8]
 c003680:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c003682:	2300      	movs	r3, #0
 c003684:	617b      	str	r3, [r7, #20]
 c003686:	e00a      	b.n	c00369e <_read+0x28>
  {
    *ptr++ = __io_getchar();
 c003688:	f3af 8000 	nop.w
 c00368c:	4601      	mov	r1, r0
 c00368e:	68bb      	ldr	r3, [r7, #8]
 c003690:	1c5a      	adds	r2, r3, #1
 c003692:	60ba      	str	r2, [r7, #8]
 c003694:	b2ca      	uxtb	r2, r1
 c003696:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c003698:	697b      	ldr	r3, [r7, #20]
 c00369a:	3301      	adds	r3, #1
 c00369c:	617b      	str	r3, [r7, #20]
 c00369e:	697a      	ldr	r2, [r7, #20]
 c0036a0:	687b      	ldr	r3, [r7, #4]
 c0036a2:	429a      	cmp	r2, r3
 c0036a4:	dbf0      	blt.n	c003688 <_read+0x12>
  }

  return len;
 c0036a6:	687b      	ldr	r3, [r7, #4]
}
 c0036a8:	4618      	mov	r0, r3
 c0036aa:	3718      	adds	r7, #24
 c0036ac:	46bd      	mov	sp, r7
 c0036ae:	bd80      	pop	{r7, pc}

0c0036b0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 c0036b0:	b580      	push	{r7, lr}
 c0036b2:	b086      	sub	sp, #24
 c0036b4:	af00      	add	r7, sp, #0
 c0036b6:	60f8      	str	r0, [r7, #12]
 c0036b8:	60b9      	str	r1, [r7, #8]
 c0036ba:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c0036bc:	2300      	movs	r3, #0
 c0036be:	617b      	str	r3, [r7, #20]
 c0036c0:	e009      	b.n	c0036d6 <_write+0x26>
  {
    __io_putchar(*ptr++);
 c0036c2:	68bb      	ldr	r3, [r7, #8]
 c0036c4:	1c5a      	adds	r2, r3, #1
 c0036c6:	60ba      	str	r2, [r7, #8]
 c0036c8:	781b      	ldrb	r3, [r3, #0]
 c0036ca:	4618      	mov	r0, r3
 c0036cc:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 c0036d0:	697b      	ldr	r3, [r7, #20]
 c0036d2:	3301      	adds	r3, #1
 c0036d4:	617b      	str	r3, [r7, #20]
 c0036d6:	697a      	ldr	r2, [r7, #20]
 c0036d8:	687b      	ldr	r3, [r7, #4]
 c0036da:	429a      	cmp	r2, r3
 c0036dc:	dbf1      	blt.n	c0036c2 <_write+0x12>
  }
  return len;
 c0036de:	687b      	ldr	r3, [r7, #4]
}
 c0036e0:	4618      	mov	r0, r3
 c0036e2:	3718      	adds	r7, #24
 c0036e4:	46bd      	mov	sp, r7
 c0036e6:	bd80      	pop	{r7, pc}

0c0036e8 <_close>:

int _close(int file)
{
 c0036e8:	b480      	push	{r7}
 c0036ea:	b083      	sub	sp, #12
 c0036ec:	af00      	add	r7, sp, #0
 c0036ee:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 c0036f0:	f04f 33ff 	mov.w	r3, #4294967295
}
 c0036f4:	4618      	mov	r0, r3
 c0036f6:	370c      	adds	r7, #12
 c0036f8:	46bd      	mov	sp, r7
 c0036fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0036fe:	4770      	bx	lr

0c003700 <_fstat>:


int _fstat(int file, struct stat *st)
{
 c003700:	b480      	push	{r7}
 c003702:	b083      	sub	sp, #12
 c003704:	af00      	add	r7, sp, #0
 c003706:	6078      	str	r0, [r7, #4]
 c003708:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 c00370a:	683b      	ldr	r3, [r7, #0]
 c00370c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 c003710:	605a      	str	r2, [r3, #4]
  return 0;
 c003712:	2300      	movs	r3, #0
}
 c003714:	4618      	mov	r0, r3
 c003716:	370c      	adds	r7, #12
 c003718:	46bd      	mov	sp, r7
 c00371a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00371e:	4770      	bx	lr

0c003720 <_isatty>:

int _isatty(int file)
{
 c003720:	b480      	push	{r7}
 c003722:	b083      	sub	sp, #12
 c003724:	af00      	add	r7, sp, #0
 c003726:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 c003728:	2301      	movs	r3, #1
}
 c00372a:	4618      	mov	r0, r3
 c00372c:	370c      	adds	r7, #12
 c00372e:	46bd      	mov	sp, r7
 c003730:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003734:	4770      	bx	lr

0c003736 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 c003736:	b480      	push	{r7}
 c003738:	b085      	sub	sp, #20
 c00373a:	af00      	add	r7, sp, #0
 c00373c:	60f8      	str	r0, [r7, #12]
 c00373e:	60b9      	str	r1, [r7, #8]
 c003740:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 c003742:	2300      	movs	r3, #0
}
 c003744:	4618      	mov	r0, r3
 c003746:	3714      	adds	r7, #20
 c003748:	46bd      	mov	sp, r7
 c00374a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00374e:	4770      	bx	lr

0c003750 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 c003750:	b580      	push	{r7, lr}
 c003752:	b086      	sub	sp, #24
 c003754:	af00      	add	r7, sp, #0
 c003756:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 c003758:	4a14      	ldr	r2, [pc, #80]	@ (c0037ac <_sbrk+0x5c>)
 c00375a:	4b15      	ldr	r3, [pc, #84]	@ (c0037b0 <_sbrk+0x60>)
 c00375c:	1ad3      	subs	r3, r2, r3
 c00375e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 c003760:	697b      	ldr	r3, [r7, #20]
 c003762:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 c003764:	4b13      	ldr	r3, [pc, #76]	@ (c0037b4 <_sbrk+0x64>)
 c003766:	681b      	ldr	r3, [r3, #0]
 c003768:	2b00      	cmp	r3, #0
 c00376a:	d102      	bne.n	c003772 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 c00376c:	4b11      	ldr	r3, [pc, #68]	@ (c0037b4 <_sbrk+0x64>)
 c00376e:	4a12      	ldr	r2, [pc, #72]	@ (c0037b8 <_sbrk+0x68>)
 c003770:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 c003772:	4b10      	ldr	r3, [pc, #64]	@ (c0037b4 <_sbrk+0x64>)
 c003774:	681a      	ldr	r2, [r3, #0]
 c003776:	687b      	ldr	r3, [r7, #4]
 c003778:	4413      	add	r3, r2
 c00377a:	693a      	ldr	r2, [r7, #16]
 c00377c:	429a      	cmp	r2, r3
 c00377e:	d207      	bcs.n	c003790 <_sbrk+0x40>
  {
    errno = ENOMEM;
 c003780:	f002 f9f4 	bl	c005b6c <__errno>
 c003784:	4603      	mov	r3, r0
 c003786:	220c      	movs	r2, #12
 c003788:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 c00378a:	f04f 33ff 	mov.w	r3, #4294967295
 c00378e:	e009      	b.n	c0037a4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 c003790:	4b08      	ldr	r3, [pc, #32]	@ (c0037b4 <_sbrk+0x64>)
 c003792:	681b      	ldr	r3, [r3, #0]
 c003794:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 c003796:	4b07      	ldr	r3, [pc, #28]	@ (c0037b4 <_sbrk+0x64>)
 c003798:	681a      	ldr	r2, [r3, #0]
 c00379a:	687b      	ldr	r3, [r7, #4]
 c00379c:	4413      	add	r3, r2
 c00379e:	4a05      	ldr	r2, [pc, #20]	@ (c0037b4 <_sbrk+0x64>)
 c0037a0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 c0037a2:	68fb      	ldr	r3, [r7, #12]
}
 c0037a4:	4618      	mov	r0, r3
 c0037a6:	3718      	adds	r7, #24
 c0037a8:	46bd      	mov	sp, r7
 c0037aa:	bd80      	pop	{r7, pc}
 c0037ac:	30018000 	.word	0x30018000
 c0037b0:	00000400 	.word	0x00000400
 c0037b4:	30000ab8 	.word	0x30000ab8
 c0037b8:	30003528 	.word	0x30003528

0c0037bc <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP error code
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 c0037bc:	b580      	push	{r7, lr}
 c0037be:	b08a      	sub	sp, #40	@ 0x28
 c0037c0:	af00      	add	r7, sp, #0
 c0037c2:	4603      	mov	r3, r0
 c0037c4:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef GPIO_Init;

  /* Enable the GPIO_LED Clock */
  if (Led == LED1)
 c0037c6:	79fb      	ldrb	r3, [r7, #7]
 c0037c8:	2b00      	cmp	r3, #0
 c0037ca:	d10c      	bne.n	c0037e6 <BSP_LED_Init+0x2a>
  {
    LED1_GPIO_CLK_ENABLE();
 c0037cc:	4b27      	ldr	r3, [pc, #156]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037ce:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0037d0:	4a26      	ldr	r2, [pc, #152]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037d2:	f043 0304 	orr.w	r3, r3, #4
 c0037d6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c0037d8:	4b24      	ldr	r3, [pc, #144]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0037dc:	f003 0304 	and.w	r3, r3, #4
 c0037e0:	613b      	str	r3, [r7, #16]
 c0037e2:	693b      	ldr	r3, [r7, #16]
 c0037e4:	e01b      	b.n	c00381e <BSP_LED_Init+0x62>
  }
  else if (Led == LED2)
 c0037e6:	79fb      	ldrb	r3, [r7, #7]
 c0037e8:	2b01      	cmp	r3, #1
 c0037ea:	d10c      	bne.n	c003806 <BSP_LED_Init+0x4a>
  {
    LED2_GPIO_CLK_ENABLE();
 c0037ec:	4b1f      	ldr	r3, [pc, #124]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037ee:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0037f0:	4a1e      	ldr	r2, [pc, #120]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037f2:	f043 0302 	orr.w	r3, r3, #2
 c0037f6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c0037f8:	4b1c      	ldr	r3, [pc, #112]	@ (c00386c <BSP_LED_Init+0xb0>)
 c0037fa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c0037fc:	f003 0302 	and.w	r3, r3, #2
 c003800:	60fb      	str	r3, [r7, #12]
 c003802:	68fb      	ldr	r3, [r7, #12]
 c003804:	e00b      	b.n	c00381e <BSP_LED_Init+0x62>
  }
  else /* Led = LED3 */
  {
    LED3_GPIO_CLK_ENABLE();
 c003806:	4b19      	ldr	r3, [pc, #100]	@ (c00386c <BSP_LED_Init+0xb0>)
 c003808:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c00380a:	4a18      	ldr	r2, [pc, #96]	@ (c00386c <BSP_LED_Init+0xb0>)
 c00380c:	f043 0301 	orr.w	r3, r3, #1
 c003810:	64d3      	str	r3, [r2, #76]	@ 0x4c
 c003812:	4b16      	ldr	r3, [pc, #88]	@ (c00386c <BSP_LED_Init+0xb0>)
 c003814:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 c003816:	f003 0301 	and.w	r3, r3, #1
 c00381a:	60bb      	str	r3, [r7, #8]
 c00381c:	68bb      	ldr	r3, [r7, #8]
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
 c00381e:	79fb      	ldrb	r3, [r7, #7]
 c003820:	4a13      	ldr	r2, [pc, #76]	@ (c003870 <BSP_LED_Init+0xb4>)
 c003822:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 c003826:	617b      	str	r3, [r7, #20]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
 c003828:	2301      	movs	r3, #1
 c00382a:	61bb      	str	r3, [r7, #24]
  GPIO_Init.Pull  = GPIO_PULLUP;
 c00382c:	2301      	movs	r3, #1
 c00382e:	61fb      	str	r3, [r7, #28]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 c003830:	2303      	movs	r3, #3
 c003832:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
 c003834:	79fb      	ldrb	r3, [r7, #7]
 c003836:	4a0f      	ldr	r2, [pc, #60]	@ (c003874 <BSP_LED_Init+0xb8>)
 c003838:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c00383c:	f107 0214 	add.w	r2, r7, #20
 c003840:	4611      	mov	r1, r2
 c003842:	4618      	mov	r0, r3
 c003844:	f000 fe3e 	bl	c0044c4 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 c003848:	79fb      	ldrb	r3, [r7, #7]
 c00384a:	4a0a      	ldr	r2, [pc, #40]	@ (c003874 <BSP_LED_Init+0xb8>)
 c00384c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c003850:	79fb      	ldrb	r3, [r7, #7]
 c003852:	4a07      	ldr	r2, [pc, #28]	@ (c003870 <BSP_LED_Init+0xb4>)
 c003854:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 c003858:	2200      	movs	r2, #0
 c00385a:	4619      	mov	r1, r3
 c00385c:	f000 ffb2 	bl	c0047c4 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 c003860:	2300      	movs	r3, #0
}
 c003862:	4618      	mov	r0, r3
 c003864:	3728      	adds	r7, #40	@ 0x28
 c003866:	46bd      	mov	sp, r7
 c003868:	bd80      	pop	{r7, pc}
 c00386a:	bf00      	nop
 c00386c:	50021000 	.word	0x50021000
 c003870:	30000004 	.word	0x30000004
 c003874:	3000000c 	.word	0x3000000c

0c003878 <BSP_LED_Toggle>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP error code
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
 c003878:	b580      	push	{r7, lr}
 c00387a:	b082      	sub	sp, #8
 c00387c:	af00      	add	r7, sp, #0
 c00387e:	4603      	mov	r3, r0
 c003880:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
 c003882:	79fb      	ldrb	r3, [r7, #7]
 c003884:	4a07      	ldr	r2, [pc, #28]	@ (c0038a4 <BSP_LED_Toggle+0x2c>)
 c003886:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 c00388a:	79fb      	ldrb	r3, [r7, #7]
 c00388c:	4906      	ldr	r1, [pc, #24]	@ (c0038a8 <BSP_LED_Toggle+0x30>)
 c00388e:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 c003892:	4619      	mov	r1, r3
 c003894:	4610      	mov	r0, r2
 c003896:	f000 ffad 	bl	c0047f4 <HAL_GPIO_TogglePin>
  return BSP_ERROR_NONE;
 c00389a:	2300      	movs	r3, #0
}
 c00389c:	4618      	mov	r0, r3
 c00389e:	3708      	adds	r7, #8
 c0038a0:	46bd      	mov	sp, r7
 c0038a2:	bd80      	pop	{r7, pc}
 c0038a4:	3000000c 	.word	0x3000000c
 c0038a8:	30000004 	.word	0x30000004

0c0038ac <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
 c0038ac:	b480      	push	{r7}
 c0038ae:	af00      	add	r7, sp, #0

#if defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U)

  #if defined (SAU_INIT_REGION0) && (SAU_INIT_REGION0 == 1U)
    SAU_INIT_REGION(0);
 c0038b0:	4b30      	ldr	r3, [pc, #192]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038b2:	2200      	movs	r2, #0
 c0038b4:	609a      	str	r2, [r3, #8]
 c0038b6:	4b2f      	ldr	r3, [pc, #188]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038b8:	4a2f      	ldr	r2, [pc, #188]	@ (c003978 <TZ_SAU_Setup+0xcc>)
 c0038ba:	60da      	str	r2, [r3, #12]
 c0038bc:	4b2d      	ldr	r3, [pc, #180]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038be:	4a2f      	ldr	r2, [pc, #188]	@ (c00397c <TZ_SAU_Setup+0xd0>)
 c0038c0:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION1) && (SAU_INIT_REGION1 == 1U)
    SAU_INIT_REGION(1);
 c0038c2:	4b2c      	ldr	r3, [pc, #176]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038c4:	2201      	movs	r2, #1
 c0038c6:	609a      	str	r2, [r3, #8]
 c0038c8:	4b2a      	ldr	r3, [pc, #168]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038ca:	4a2d      	ldr	r2, [pc, #180]	@ (c003980 <TZ_SAU_Setup+0xd4>)
 c0038cc:	60da      	str	r2, [r3, #12]
 c0038ce:	4b29      	ldr	r3, [pc, #164]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038d0:	4a2c      	ldr	r2, [pc, #176]	@ (c003984 <TZ_SAU_Setup+0xd8>)
 c0038d2:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION2) && (SAU_INIT_REGION2 == 1U)
    SAU_INIT_REGION(2);
 c0038d4:	4b27      	ldr	r3, [pc, #156]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038d6:	2202      	movs	r2, #2
 c0038d8:	609a      	str	r2, [r3, #8]
 c0038da:	4b26      	ldr	r3, [pc, #152]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038dc:	4a2a      	ldr	r2, [pc, #168]	@ (c003988 <TZ_SAU_Setup+0xdc>)
 c0038de:	60da      	str	r2, [r3, #12]
 c0038e0:	4b24      	ldr	r3, [pc, #144]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038e2:	4a2a      	ldr	r2, [pc, #168]	@ (c00398c <TZ_SAU_Setup+0xe0>)
 c0038e4:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION3) && (SAU_INIT_REGION3 == 1U)
    SAU_INIT_REGION(3);
 c0038e6:	4b23      	ldr	r3, [pc, #140]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038e8:	2203      	movs	r2, #3
 c0038ea:	609a      	str	r2, [r3, #8]
 c0038ec:	4b21      	ldr	r3, [pc, #132]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038ee:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 c0038f2:	60da      	str	r2, [r3, #12]
 c0038f4:	4b1f      	ldr	r3, [pc, #124]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038f6:	4a26      	ldr	r2, [pc, #152]	@ (c003990 <TZ_SAU_Setup+0xe4>)
 c0038f8:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION4) && (SAU_INIT_REGION4 == 1U)
    SAU_INIT_REGION(4);
 c0038fa:	4b1e      	ldr	r3, [pc, #120]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c0038fc:	2204      	movs	r2, #4
 c0038fe:	609a      	str	r2, [r3, #8]
 c003900:	4b1c      	ldr	r3, [pc, #112]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c003902:	f04f 42c0 	mov.w	r2, #1610612736	@ 0x60000000
 c003906:	60da      	str	r2, [r3, #12]
 c003908:	4b1a      	ldr	r3, [pc, #104]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c00390a:	4a22      	ldr	r2, [pc, #136]	@ (c003994 <TZ_SAU_Setup+0xe8>)
 c00390c:	611a      	str	r2, [r3, #16]
  #endif

  #if defined (SAU_INIT_REGION5) && (SAU_INIT_REGION5 == 1U)
    SAU_INIT_REGION(5);
 c00390e:	4b19      	ldr	r3, [pc, #100]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c003910:	2205      	movs	r2, #5
 c003912:	609a      	str	r2, [r3, #8]
 c003914:	4b17      	ldr	r3, [pc, #92]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c003916:	4a20      	ldr	r2, [pc, #128]	@ (c003998 <TZ_SAU_Setup+0xec>)
 c003918:	60da      	str	r2, [r3, #12]
 c00391a:	4b16      	ldr	r3, [pc, #88]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c00391c:	4a1f      	ldr	r2, [pc, #124]	@ (c00399c <TZ_SAU_Setup+0xf0>)
 c00391e:	611a      	str	r2, [r3, #16]
  /* repeat this for all possible SAU regions */

#endif /* defined (__SAUREGION_PRESENT) && (__SAUREGION_PRESENT == 1U) */

  #if defined (SAU_INIT_CTRL) && (SAU_INIT_CTRL == 1U)
    SAU->CTRL = ((SAU_INIT_CTRL_ENABLE << SAU_CTRL_ENABLE_Pos) & SAU_CTRL_ENABLE_Msk) |
 c003920:	4b14      	ldr	r3, [pc, #80]	@ (c003974 <TZ_SAU_Setup+0xc8>)
 c003922:	2201      	movs	r2, #1
 c003924:	601a      	str	r2, [r3, #0]
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c003926:	4b1e      	ldr	r3, [pc, #120]	@ (c0039a0 <TZ_SAU_Setup+0xf4>)
 c003928:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c00392c:	4a1c      	ldr	r2, [pc, #112]	@ (c0039a0 <TZ_SAU_Setup+0xf4>)
 c00392e:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c003932:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c003936:	4b1b      	ldr	r3, [pc, #108]	@ (c0039a4 <TZ_SAU_Setup+0xf8>)
 c003938:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
 c00393a:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c00393e:	4a19      	ldr	r2, [pc, #100]	@ (c0039a4 <TZ_SAU_Setup+0xf8>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
 c003940:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c003944:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
 c003946:	4b18      	ldr	r3, [pc, #96]	@ (c0039a8 <TZ_SAU_Setup+0xfc>)
 c003948:	2200      	movs	r2, #0
 c00394a:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
 c00394e:	4b16      	ldr	r3, [pc, #88]	@ (c0039a8 <TZ_SAU_Setup+0xfc>)
 c003950:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 c003954:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
 c003958:	4b13      	ldr	r3, [pc, #76]	@ (c0039a8 <TZ_SAU_Setup+0xfc>)
 c00395a:	2204      	movs	r2, #4
 c00395c:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
 c003960:	4b11      	ldr	r3, [pc, #68]	@ (c0039a8 <TZ_SAU_Setup+0xfc>)
 c003962:	2200      	movs	r2, #0
 c003964:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

}
 c003968:	bf00      	nop
 c00396a:	46bd      	mov	sp, r7
 c00396c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003970:	4770      	bx	lr
 c003972:	bf00      	nop
 c003974:	e000edd0 	.word	0xe000edd0
 c003978:	0c03e000 	.word	0x0c03e000
 c00397c:	0c03ffe3 	.word	0x0c03ffe3
 c003980:	08040000 	.word	0x08040000
 c003984:	0807ffe1 	.word	0x0807ffe1
 c003988:	20018000 	.word	0x20018000
 c00398c:	2003ffe1 	.word	0x2003ffe1
 c003990:	4fffffe1 	.word	0x4fffffe1
 c003994:	9fffffe1 	.word	0x9fffffe1
 c003998:	0bf90000 	.word	0x0bf90000
 c00399c:	0bfa8fe1 	.word	0x0bfa8fe1
 c0039a0:	e000ed00 	.word	0xe000ed00
 c0039a4:	e000ef30 	.word	0xe000ef30
 c0039a8:	e000e100 	.word	0xe000e100

0c0039ac <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
 c0039ac:	b580      	push	{r7, lr}
 c0039ae:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
 c0039b0:	f7ff ff7c 	bl	c0038ac <TZ_SAU_Setup>
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0039b4:	4b08      	ldr	r3, [pc, #32]	@ (c0039d8 <SystemInit+0x2c>)
 c0039b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 c0039ba:	4a07      	ldr	r2, [pc, #28]	@ (c0039d8 <SystemInit+0x2c>)
 c0039bc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 c0039c0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0039c4:	4b05      	ldr	r3, [pc, #20]	@ (c0039dc <SystemInit+0x30>)
 c0039c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 c0039ca:	4a04      	ldr	r2, [pc, #16]	@ (c0039dc <SystemInit+0x30>)
 c0039cc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 c0039d0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif
}
 c0039d4:	bf00      	nop
 c0039d6:	bd80      	pop	{r7, pc}
 c0039d8:	e000ed00 	.word	0xe000ed00
 c0039dc:	e002ed00 	.word	0xe002ed00

0c0039e0 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 c0039e0:	b480      	push	{r7}
 c0039e2:	b087      	sub	sp, #28
 c0039e4:	af00      	add	r7, sp, #0
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c0039e6:	4b4f      	ldr	r3, [pc, #316]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c0039e8:	681b      	ldr	r3, [r3, #0]
 c0039ea:	f003 0308 	and.w	r3, r3, #8
 c0039ee:	2b00      	cmp	r3, #0
 c0039f0:	d107      	bne.n	c003a02 <SystemCoreClockUpdate+0x22>
  { /* MSISRANGE from RCC_CSR applies */
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c0039f2:	4b4c      	ldr	r3, [pc, #304]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c0039f4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 c0039f8:	0a1b      	lsrs	r3, r3, #8
 c0039fa:	f003 030f 	and.w	r3, r3, #15
 c0039fe:	617b      	str	r3, [r7, #20]
 c003a00:	e005      	b.n	c003a0e <SystemCoreClockUpdate+0x2e>
  }
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c003a02:	4b48      	ldr	r3, [pc, #288]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003a04:	681b      	ldr	r3, [r3, #0]
 c003a06:	091b      	lsrs	r3, r3, #4
 c003a08:	f003 030f 	and.w	r3, r3, #15
 c003a0c:	617b      	str	r3, [r7, #20]
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 c003a0e:	4a46      	ldr	r2, [pc, #280]	@ (c003b28 <SystemCoreClockUpdate+0x148>)
 c003a10:	697b      	ldr	r3, [r7, #20]
 c003a12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c003a16:	617b      	str	r3, [r7, #20]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c003a18:	4b42      	ldr	r3, [pc, #264]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003a1a:	689b      	ldr	r3, [r3, #8]
 c003a1c:	f003 030c 	and.w	r3, r3, #12
 c003a20:	2b0c      	cmp	r3, #12
 c003a22:	d866      	bhi.n	c003af2 <SystemCoreClockUpdate+0x112>
 c003a24:	a201      	add	r2, pc, #4	@ (adr r2, c003a2c <SystemCoreClockUpdate+0x4c>)
 c003a26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c003a2a:	bf00      	nop
 c003a2c:	0c003a61 	.word	0x0c003a61
 c003a30:	0c003af3 	.word	0x0c003af3
 c003a34:	0c003af3 	.word	0x0c003af3
 c003a38:	0c003af3 	.word	0x0c003af3
 c003a3c:	0c003a69 	.word	0x0c003a69
 c003a40:	0c003af3 	.word	0x0c003af3
 c003a44:	0c003af3 	.word	0x0c003af3
 c003a48:	0c003af3 	.word	0x0c003af3
 c003a4c:	0c003a71 	.word	0x0c003a71
 c003a50:	0c003af3 	.word	0x0c003af3
 c003a54:	0c003af3 	.word	0x0c003af3
 c003a58:	0c003af3 	.word	0x0c003af3
 c003a5c:	0c003a79 	.word	0x0c003a79
  {
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
 c003a60:	4a32      	ldr	r2, [pc, #200]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003a62:	697b      	ldr	r3, [r7, #20]
 c003a64:	6013      	str	r3, [r2, #0]
      break;
 c003a66:	e048      	b.n	c003afa <SystemCoreClockUpdate+0x11a>

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 c003a68:	4b30      	ldr	r3, [pc, #192]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003a6a:	4a31      	ldr	r2, [pc, #196]	@ (c003b30 <SystemCoreClockUpdate+0x150>)
 c003a6c:	601a      	str	r2, [r3, #0]
      break;
 c003a6e:	e044      	b.n	c003afa <SystemCoreClockUpdate+0x11a>

    case 0x08:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 c003a70:	4b2e      	ldr	r3, [pc, #184]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003a72:	4a2f      	ldr	r2, [pc, #188]	@ (c003b30 <SystemCoreClockUpdate+0x150>)
 c003a74:	601a      	str	r2, [r3, #0]
      break;
 c003a76:	e040      	b.n	c003afa <SystemCoreClockUpdate+0x11a>

    case 0x0C:  /* PLL used as system clock  source */
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLR
         */
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c003a78:	4b2a      	ldr	r3, [pc, #168]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003a7a:	68db      	ldr	r3, [r3, #12]
 c003a7c:	f003 0303 	and.w	r3, r3, #3
 c003a80:	60fb      	str	r3, [r7, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c003a82:	4b28      	ldr	r3, [pc, #160]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003a84:	68db      	ldr	r3, [r3, #12]
 c003a86:	091b      	lsrs	r3, r3, #4
 c003a88:	f003 030f 	and.w	r3, r3, #15
 c003a8c:	3301      	adds	r3, #1
 c003a8e:	60bb      	str	r3, [r7, #8]

      switch (pllsource)
 c003a90:	68fb      	ldr	r3, [r7, #12]
 c003a92:	2b02      	cmp	r3, #2
 c003a94:	d003      	beq.n	c003a9e <SystemCoreClockUpdate+0xbe>
 c003a96:	68fb      	ldr	r3, [r7, #12]
 c003a98:	2b03      	cmp	r3, #3
 c003a9a:	d006      	beq.n	c003aaa <SystemCoreClockUpdate+0xca>
 c003a9c:	e00b      	b.n	c003ab6 <SystemCoreClockUpdate+0xd6>
      {
        case 0x02:  /* HSI used as PLL clock source */
          pllvco = (HSI_VALUE / pllm);
 c003a9e:	4a24      	ldr	r2, [pc, #144]	@ (c003b30 <SystemCoreClockUpdate+0x150>)
 c003aa0:	68bb      	ldr	r3, [r7, #8]
 c003aa2:	fbb2 f3f3 	udiv	r3, r2, r3
 c003aa6:	613b      	str	r3, [r7, #16]
          break;
 c003aa8:	e00b      	b.n	c003ac2 <SystemCoreClockUpdate+0xe2>

        case 0x03:  /* HSE used as PLL clock source */
          pllvco = (HSE_VALUE / pllm);
 c003aaa:	4a21      	ldr	r2, [pc, #132]	@ (c003b30 <SystemCoreClockUpdate+0x150>)
 c003aac:	68bb      	ldr	r3, [r7, #8]
 c003aae:	fbb2 f3f3 	udiv	r3, r2, r3
 c003ab2:	613b      	str	r3, [r7, #16]
          break;
 c003ab4:	e005      	b.n	c003ac2 <SystemCoreClockUpdate+0xe2>

        default:    /* MSI used as PLL clock source */
          pllvco = (msirange / pllm);
 c003ab6:	697a      	ldr	r2, [r7, #20]
 c003ab8:	68bb      	ldr	r3, [r7, #8]
 c003aba:	fbb2 f3f3 	udiv	r3, r2, r3
 c003abe:	613b      	str	r3, [r7, #16]
          break;
 c003ac0:	bf00      	nop
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c003ac2:	4b18      	ldr	r3, [pc, #96]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003ac4:	68db      	ldr	r3, [r3, #12]
 c003ac6:	0a1b      	lsrs	r3, r3, #8
 c003ac8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 c003acc:	693b      	ldr	r3, [r7, #16]
 c003ace:	fb02 f303 	mul.w	r3, r2, r3
 c003ad2:	613b      	str	r3, [r7, #16]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c003ad4:	4b13      	ldr	r3, [pc, #76]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003ad6:	68db      	ldr	r3, [r3, #12]
 c003ad8:	0e5b      	lsrs	r3, r3, #25
 c003ada:	f003 0303 	and.w	r3, r3, #3
 c003ade:	3301      	adds	r3, #1
 c003ae0:	005b      	lsls	r3, r3, #1
 c003ae2:	607b      	str	r3, [r7, #4]
      SystemCoreClock = pllvco/pllr;
 c003ae4:	693a      	ldr	r2, [r7, #16]
 c003ae6:	687b      	ldr	r3, [r7, #4]
 c003ae8:	fbb2 f3f3 	udiv	r3, r2, r3
 c003aec:	4a0f      	ldr	r2, [pc, #60]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003aee:	6013      	str	r3, [r2, #0]
      break;
 c003af0:	e003      	b.n	c003afa <SystemCoreClockUpdate+0x11a>

    default:
      SystemCoreClock = msirange;
 c003af2:	4a0e      	ldr	r2, [pc, #56]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003af4:	697b      	ldr	r3, [r7, #20]
 c003af6:	6013      	str	r3, [r2, #0]
      break;
 c003af8:	bf00      	nop
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 c003afa:	4b0a      	ldr	r3, [pc, #40]	@ (c003b24 <SystemCoreClockUpdate+0x144>)
 c003afc:	689b      	ldr	r3, [r3, #8]
 c003afe:	091b      	lsrs	r3, r3, #4
 c003b00:	f003 030f 	and.w	r3, r3, #15
 c003b04:	4a0b      	ldr	r2, [pc, #44]	@ (c003b34 <SystemCoreClockUpdate+0x154>)
 c003b06:	5cd3      	ldrb	r3, [r2, r3]
 c003b08:	603b      	str	r3, [r7, #0]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 c003b0a:	4b08      	ldr	r3, [pc, #32]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003b0c:	681a      	ldr	r2, [r3, #0]
 c003b0e:	683b      	ldr	r3, [r7, #0]
 c003b10:	fa22 f303 	lsr.w	r3, r2, r3
 c003b14:	4a05      	ldr	r2, [pc, #20]	@ (c003b2c <SystemCoreClockUpdate+0x14c>)
 c003b16:	6013      	str	r3, [r2, #0]
}
 c003b18:	bf00      	nop
 c003b1a:	371c      	adds	r7, #28
 c003b1c:	46bd      	mov	sp, r7
 c003b1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003b22:	4770      	bx	lr
 c003b24:	50021000 	.word	0x50021000
 c003b28:	0c006c6c 	.word	0x0c006c6c
 c003b2c:	30000018 	.word	0x30000018
 c003b30:	00f42400 	.word	0x00f42400
 c003b34:	0c006c5c 	.word	0x0c006c5c

0c003b38 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value (HCLK)
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
 c003b38:	b580      	push	{r7, lr}
 c003b3a:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
 c003b3c:	f7ff ff50 	bl	c0039e0 <SystemCoreClockUpdate>
  
  return SystemCoreClock;
 c003b40:	4b1c      	ldr	r3, [pc, #112]	@ (c003bb4 <__acle_se_SECURE_SystemCoreClockUpdate+0x7c>)
 c003b42:	681b      	ldr	r3, [r3, #0]
}
 c003b44:	4618      	mov	r0, r3
 c003b46:	46bd      	mov	sp, r7
 c003b48:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c003b4c:	4671      	mov	r1, lr
 c003b4e:	4672      	mov	r2, lr
 c003b50:	4673      	mov	r3, lr
 c003b52:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c003b56:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c003b5a:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c003b5e:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c003b62:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c003b66:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c003b6a:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c003b6e:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c003b72:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c003b76:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c003b7a:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c003b7e:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c003b82:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c003b86:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c003b8a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c003b8e:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c003b92:	f38e 8c00 	msr	CPSR_fs, lr
 c003b96:	b410      	push	{r4}
 c003b98:	eef1 ca10 	vmrs	ip, fpscr
 c003b9c:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c003ba0:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c003ba4:	ea0c 0c04 	and.w	ip, ip, r4
 c003ba8:	eee1 ca10 	vmsr	fpscr, ip
 c003bac:	bc10      	pop	{r4}
 c003bae:	46f4      	mov	ip, lr
 c003bb0:	4774      	bxns	lr
 c003bb2:	bf00      	nop
 c003bb4:	30000018 	.word	0x30000018

0c003bb8 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 c003bb8:	b580      	push	{r7, lr}
 c003bba:	b082      	sub	sp, #8
 c003bbc:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 c003bbe:	2300      	movs	r3, #0
 c003bc0:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 c003bc2:	2004      	movs	r0, #4
 c003bc4:	f000 f94e 	bl	c003e64 <HAL_NVIC_SetPriorityGrouping>

  /* Insure time base clock coherency */
  SystemCoreClockUpdate();
 c003bc8:	f7ff ff0a 	bl	c0039e0 <SystemCoreClockUpdate>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c003bcc:	2000      	movs	r0, #0
 c003bce:	f000 f80d 	bl	c003bec <HAL_InitTick>
 c003bd2:	4603      	mov	r3, r0
 c003bd4:	2b00      	cmp	r3, #0
 c003bd6:	d002      	beq.n	c003bde <HAL_Init+0x26>
  {
    status = HAL_ERROR;
 c003bd8:	2301      	movs	r3, #1
 c003bda:	71fb      	strb	r3, [r7, #7]
 c003bdc:	e001      	b.n	c003be2 <HAL_Init+0x2a>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 c003bde:	f7ff fc3d 	bl	c00345c <HAL_MspInit>
  }

  /* Return function status */
  return status;
 c003be2:	79fb      	ldrb	r3, [r7, #7]
}
 c003be4:	4618      	mov	r0, r3
 c003be6:	3708      	adds	r7, #8
 c003be8:	46bd      	mov	sp, r7
 c003bea:	bd80      	pop	{r7, pc}

0c003bec <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 c003bec:	b580      	push	{r7, lr}
 c003bee:	b084      	sub	sp, #16
 c003bf0:	af00      	add	r7, sp, #0
 c003bf2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 c003bf4:	2300      	movs	r3, #0
 c003bf6:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 c003bf8:	4b17      	ldr	r3, [pc, #92]	@ (c003c58 <HAL_InitTick+0x6c>)
 c003bfa:	781b      	ldrb	r3, [r3, #0]
 c003bfc:	2b00      	cmp	r3, #0
 c003bfe:	d023      	beq.n	c003c48 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 c003c00:	4b16      	ldr	r3, [pc, #88]	@ (c003c5c <HAL_InitTick+0x70>)
 c003c02:	681a      	ldr	r2, [r3, #0]
 c003c04:	4b14      	ldr	r3, [pc, #80]	@ (c003c58 <HAL_InitTick+0x6c>)
 c003c06:	781b      	ldrb	r3, [r3, #0]
 c003c08:	4619      	mov	r1, r3
 c003c0a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 c003c0e:	fbb3 f3f1 	udiv	r3, r3, r1
 c003c12:	fbb2 f3f3 	udiv	r3, r2, r3
 c003c16:	4618      	mov	r0, r3
 c003c18:	f000 f957 	bl	c003eca <HAL_SYSTICK_Config>
 c003c1c:	4603      	mov	r3, r0
 c003c1e:	2b00      	cmp	r3, #0
 c003c20:	d10f      	bne.n	c003c42 <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 c003c22:	687b      	ldr	r3, [r7, #4]
 c003c24:	2b07      	cmp	r3, #7
 c003c26:	d809      	bhi.n	c003c3c <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 c003c28:	2200      	movs	r2, #0
 c003c2a:	6879      	ldr	r1, [r7, #4]
 c003c2c:	f04f 30ff 	mov.w	r0, #4294967295
 c003c30:	f000 f923 	bl	c003e7a <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 c003c34:	4a0a      	ldr	r2, [pc, #40]	@ (c003c60 <HAL_InitTick+0x74>)
 c003c36:	687b      	ldr	r3, [r7, #4]
 c003c38:	6013      	str	r3, [r2, #0]
 c003c3a:	e007      	b.n	c003c4c <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
 c003c3c:	2301      	movs	r3, #1
 c003c3e:	73fb      	strb	r3, [r7, #15]
 c003c40:	e004      	b.n	c003c4c <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
 c003c42:	2301      	movs	r3, #1
 c003c44:	73fb      	strb	r3, [r7, #15]
 c003c46:	e001      	b.n	c003c4c <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
 c003c48:	2301      	movs	r3, #1
 c003c4a:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 c003c4c:	7bfb      	ldrb	r3, [r7, #15]
}
 c003c4e:	4618      	mov	r0, r3
 c003c50:	3710      	adds	r7, #16
 c003c52:	46bd      	mov	sp, r7
 c003c54:	bd80      	pop	{r7, pc}
 c003c56:	bf00      	nop
 c003c58:	30000020 	.word	0x30000020
 c003c5c:	30000018 	.word	0x30000018
 c003c60:	3000001c 	.word	0x3000001c

0c003c64 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 c003c64:	b480      	push	{r7}
 c003c66:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 c003c68:	4b06      	ldr	r3, [pc, #24]	@ (c003c84 <HAL_IncTick+0x20>)
 c003c6a:	781b      	ldrb	r3, [r3, #0]
 c003c6c:	461a      	mov	r2, r3
 c003c6e:	4b06      	ldr	r3, [pc, #24]	@ (c003c88 <HAL_IncTick+0x24>)
 c003c70:	681b      	ldr	r3, [r3, #0]
 c003c72:	4413      	add	r3, r2
 c003c74:	4a04      	ldr	r2, [pc, #16]	@ (c003c88 <HAL_IncTick+0x24>)
 c003c76:	6013      	str	r3, [r2, #0]
}
 c003c78:	bf00      	nop
 c003c7a:	46bd      	mov	sp, r7
 c003c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003c80:	4770      	bx	lr
 c003c82:	bf00      	nop
 c003c84:	30000020 	.word	0x30000020
 c003c88:	30000abc 	.word	0x30000abc

0c003c8c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 c003c8c:	b480      	push	{r7}
 c003c8e:	af00      	add	r7, sp, #0
  return uwTick;
 c003c90:	4b03      	ldr	r3, [pc, #12]	@ (c003ca0 <HAL_GetTick+0x14>)
 c003c92:	681b      	ldr	r3, [r3, #0]
}
 c003c94:	4618      	mov	r0, r3
 c003c96:	46bd      	mov	sp, r7
 c003c98:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003c9c:	4770      	bx	lr
 c003c9e:	bf00      	nop
 c003ca0:	30000abc 	.word	0x30000abc

0c003ca4 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
 c003ca4:	b480      	push	{r7}
 c003ca6:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 c003ca8:	4b05      	ldr	r3, [pc, #20]	@ (c003cc0 <HAL_SuspendTick+0x1c>)
 c003caa:	681b      	ldr	r3, [r3, #0]
 c003cac:	4a04      	ldr	r2, [pc, #16]	@ (c003cc0 <HAL_SuspendTick+0x1c>)
 c003cae:	f023 0302 	bic.w	r3, r3, #2
 c003cb2:	6013      	str	r3, [r2, #0]
}
 c003cb4:	bf00      	nop
 c003cb6:	46bd      	mov	sp, r7
 c003cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003cbc:	4770      	bx	lr
 c003cbe:	bf00      	nop
 c003cc0:	e000e010 	.word	0xe000e010

0c003cc4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 c003cc4:	b480      	push	{r7}
 c003cc6:	b085      	sub	sp, #20
 c003cc8:	af00      	add	r7, sp, #0
 c003cca:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 c003ccc:	687b      	ldr	r3, [r7, #4]
 c003cce:	f003 0307 	and.w	r3, r3, #7
 c003cd2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c003cd4:	4b0c      	ldr	r3, [pc, #48]	@ (c003d08 <__NVIC_SetPriorityGrouping+0x44>)
 c003cd6:	68db      	ldr	r3, [r3, #12]
 c003cd8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c003cda:	68ba      	ldr	r2, [r7, #8]
 c003cdc:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 c003ce0:	4013      	ands	r3, r2
 c003ce2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c003ce4:	68fb      	ldr	r3, [r7, #12]
 c003ce6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 c003ce8:	68bb      	ldr	r3, [r7, #8]
 c003cea:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 c003cec:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 c003cf0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 c003cf4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 c003cf6:	4a04      	ldr	r2, [pc, #16]	@ (c003d08 <__NVIC_SetPriorityGrouping+0x44>)
 c003cf8:	68bb      	ldr	r3, [r7, #8]
 c003cfa:	60d3      	str	r3, [r2, #12]
}
 c003cfc:	bf00      	nop
 c003cfe:	3714      	adds	r7, #20
 c003d00:	46bd      	mov	sp, r7
 c003d02:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d06:	4770      	bx	lr
 c003d08:	e000ed00 	.word	0xe000ed00

0c003d0c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 c003d0c:	b480      	push	{r7}
 c003d0e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c003d10:	4b04      	ldr	r3, [pc, #16]	@ (c003d24 <__NVIC_GetPriorityGrouping+0x18>)
 c003d12:	68db      	ldr	r3, [r3, #12]
 c003d14:	0a1b      	lsrs	r3, r3, #8
 c003d16:	f003 0307 	and.w	r3, r3, #7
}
 c003d1a:	4618      	mov	r0, r3
 c003d1c:	46bd      	mov	sp, r7
 c003d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d22:	4770      	bx	lr
 c003d24:	e000ed00 	.word	0xe000ed00

0c003d28 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 c003d28:	b480      	push	{r7}
 c003d2a:	b083      	sub	sp, #12
 c003d2c:	af00      	add	r7, sp, #0
 c003d2e:	4603      	mov	r3, r0
 c003d30:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 c003d32:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d36:	2b00      	cmp	r3, #0
 c003d38:	db0b      	blt.n	c003d52 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c003d3a:	79fb      	ldrb	r3, [r7, #7]
 c003d3c:	f003 021f 	and.w	r2, r3, #31
 c003d40:	4907      	ldr	r1, [pc, #28]	@ (c003d60 <__NVIC_EnableIRQ+0x38>)
 c003d42:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d46:	095b      	lsrs	r3, r3, #5
 c003d48:	2001      	movs	r0, #1
 c003d4a:	fa00 f202 	lsl.w	r2, r0, r2
 c003d4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 c003d52:	bf00      	nop
 c003d54:	370c      	adds	r7, #12
 c003d56:	46bd      	mov	sp, r7
 c003d58:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003d5c:	4770      	bx	lr
 c003d5e:	bf00      	nop
 c003d60:	e000e100 	.word	0xe000e100

0c003d64 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 c003d64:	b480      	push	{r7}
 c003d66:	b083      	sub	sp, #12
 c003d68:	af00      	add	r7, sp, #0
 c003d6a:	4603      	mov	r3, r0
 c003d6c:	6039      	str	r1, [r7, #0]
 c003d6e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 c003d70:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d74:	2b00      	cmp	r3, #0
 c003d76:	db0a      	blt.n	c003d8e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c003d78:	683b      	ldr	r3, [r7, #0]
 c003d7a:	b2da      	uxtb	r2, r3
 c003d7c:	490c      	ldr	r1, [pc, #48]	@ (c003db0 <__NVIC_SetPriority+0x4c>)
 c003d7e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003d82:	0152      	lsls	r2, r2, #5
 c003d84:	b2d2      	uxtb	r2, r2
 c003d86:	440b      	add	r3, r1
 c003d88:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 c003d8c:	e00a      	b.n	c003da4 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c003d8e:	683b      	ldr	r3, [r7, #0]
 c003d90:	b2da      	uxtb	r2, r3
 c003d92:	4908      	ldr	r1, [pc, #32]	@ (c003db4 <__NVIC_SetPriority+0x50>)
 c003d94:	79fb      	ldrb	r3, [r7, #7]
 c003d96:	f003 030f 	and.w	r3, r3, #15
 c003d9a:	3b04      	subs	r3, #4
 c003d9c:	0152      	lsls	r2, r2, #5
 c003d9e:	b2d2      	uxtb	r2, r2
 c003da0:	440b      	add	r3, r1
 c003da2:	761a      	strb	r2, [r3, #24]
}
 c003da4:	bf00      	nop
 c003da6:	370c      	adds	r7, #12
 c003da8:	46bd      	mov	sp, r7
 c003daa:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003dae:	4770      	bx	lr
 c003db0:	e000e100 	.word	0xe000e100
 c003db4:	e000ed00 	.word	0xe000ed00

0c003db8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c003db8:	b480      	push	{r7}
 c003dba:	b089      	sub	sp, #36	@ 0x24
 c003dbc:	af00      	add	r7, sp, #0
 c003dbe:	60f8      	str	r0, [r7, #12]
 c003dc0:	60b9      	str	r1, [r7, #8]
 c003dc2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 c003dc4:	68fb      	ldr	r3, [r7, #12]
 c003dc6:	f003 0307 	and.w	r3, r3, #7
 c003dca:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c003dcc:	69fb      	ldr	r3, [r7, #28]
 c003dce:	f1c3 0307 	rsb	r3, r3, #7
 c003dd2:	2b03      	cmp	r3, #3
 c003dd4:	bf28      	it	cs
 c003dd6:	2303      	movcs	r3, #3
 c003dd8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c003dda:	69fb      	ldr	r3, [r7, #28]
 c003ddc:	3303      	adds	r3, #3
 c003dde:	2b06      	cmp	r3, #6
 c003de0:	d902      	bls.n	c003de8 <NVIC_EncodePriority+0x30>
 c003de2:	69fb      	ldr	r3, [r7, #28]
 c003de4:	3b04      	subs	r3, #4
 c003de6:	e000      	b.n	c003dea <NVIC_EncodePriority+0x32>
 c003de8:	2300      	movs	r3, #0
 c003dea:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c003dec:	f04f 32ff 	mov.w	r2, #4294967295
 c003df0:	69bb      	ldr	r3, [r7, #24]
 c003df2:	fa02 f303 	lsl.w	r3, r2, r3
 c003df6:	43da      	mvns	r2, r3
 c003df8:	68bb      	ldr	r3, [r7, #8]
 c003dfa:	401a      	ands	r2, r3
 c003dfc:	697b      	ldr	r3, [r7, #20]
 c003dfe:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 c003e00:	f04f 31ff 	mov.w	r1, #4294967295
 c003e04:	697b      	ldr	r3, [r7, #20]
 c003e06:	fa01 f303 	lsl.w	r3, r1, r3
 c003e0a:	43d9      	mvns	r1, r3
 c003e0c:	687b      	ldr	r3, [r7, #4]
 c003e0e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c003e10:	4313      	orrs	r3, r2
         );
}
 c003e12:	4618      	mov	r0, r3
 c003e14:	3724      	adds	r7, #36	@ 0x24
 c003e16:	46bd      	mov	sp, r7
 c003e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003e1c:	4770      	bx	lr
	...

0c003e20 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 c003e20:	b580      	push	{r7, lr}
 c003e22:	b082      	sub	sp, #8
 c003e24:	af00      	add	r7, sp, #0
 c003e26:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 c003e28:	687b      	ldr	r3, [r7, #4]
 c003e2a:	3b01      	subs	r3, #1
 c003e2c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 c003e30:	d301      	bcc.n	c003e36 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 c003e32:	2301      	movs	r3, #1
 c003e34:	e00f      	b.n	c003e56 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c003e36:	4a0a      	ldr	r2, [pc, #40]	@ (c003e60 <SysTick_Config+0x40>)
 c003e38:	687b      	ldr	r3, [r7, #4]
 c003e3a:	3b01      	subs	r3, #1
 c003e3c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 c003e3e:	2107      	movs	r1, #7
 c003e40:	f04f 30ff 	mov.w	r0, #4294967295
 c003e44:	f7ff ff8e 	bl	c003d64 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c003e48:	4b05      	ldr	r3, [pc, #20]	@ (c003e60 <SysTick_Config+0x40>)
 c003e4a:	2200      	movs	r2, #0
 c003e4c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c003e4e:	4b04      	ldr	r3, [pc, #16]	@ (c003e60 <SysTick_Config+0x40>)
 c003e50:	2207      	movs	r2, #7
 c003e52:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 c003e54:	2300      	movs	r3, #0
}
 c003e56:	4618      	mov	r0, r3
 c003e58:	3708      	adds	r7, #8
 c003e5a:	46bd      	mov	sp, r7
 c003e5c:	bd80      	pop	{r7, pc}
 c003e5e:	bf00      	nop
 c003e60:	e000e010 	.word	0xe000e010

0c003e64 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 c003e64:	b580      	push	{r7, lr}
 c003e66:	b082      	sub	sp, #8
 c003e68:	af00      	add	r7, sp, #0
 c003e6a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 c003e6c:	6878      	ldr	r0, [r7, #4]
 c003e6e:	f7ff ff29 	bl	c003cc4 <__NVIC_SetPriorityGrouping>
}
 c003e72:	bf00      	nop
 c003e74:	3708      	adds	r7, #8
 c003e76:	46bd      	mov	sp, r7
 c003e78:	bd80      	pop	{r7, pc}

0c003e7a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c003e7a:	b580      	push	{r7, lr}
 c003e7c:	b086      	sub	sp, #24
 c003e7e:	af00      	add	r7, sp, #0
 c003e80:	4603      	mov	r3, r0
 c003e82:	60b9      	str	r1, [r7, #8]
 c003e84:	607a      	str	r2, [r7, #4]
 c003e86:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 c003e88:	f7ff ff40 	bl	c003d0c <__NVIC_GetPriorityGrouping>
 c003e8c:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 c003e8e:	687a      	ldr	r2, [r7, #4]
 c003e90:	68b9      	ldr	r1, [r7, #8]
 c003e92:	6978      	ldr	r0, [r7, #20]
 c003e94:	f7ff ff90 	bl	c003db8 <NVIC_EncodePriority>
 c003e98:	4602      	mov	r2, r0
 c003e9a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 c003e9e:	4611      	mov	r1, r2
 c003ea0:	4618      	mov	r0, r3
 c003ea2:	f7ff ff5f 	bl	c003d64 <__NVIC_SetPriority>
}
 c003ea6:	bf00      	nop
 c003ea8:	3718      	adds	r7, #24
 c003eaa:	46bd      	mov	sp, r7
 c003eac:	bd80      	pop	{r7, pc}

0c003eae <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32l5xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 c003eae:	b580      	push	{r7, lr}
 c003eb0:	b082      	sub	sp, #8
 c003eb2:	af00      	add	r7, sp, #0
 c003eb4:	4603      	mov	r3, r0
 c003eb6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 c003eb8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 c003ebc:	4618      	mov	r0, r3
 c003ebe:	f7ff ff33 	bl	c003d28 <__NVIC_EnableIRQ>
}
 c003ec2:	bf00      	nop
 c003ec4:	3708      	adds	r7, #8
 c003ec6:	46bd      	mov	sp, r7
 c003ec8:	bd80      	pop	{r7, pc}

0c003eca <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 c003eca:	b580      	push	{r7, lr}
 c003ecc:	b082      	sub	sp, #8
 c003ece:	af00      	add	r7, sp, #0
 c003ed0:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 c003ed2:	6878      	ldr	r0, [r7, #4]
 c003ed4:	f7ff ffa4 	bl	c003e20 <SysTick_Config>
 c003ed8:	4603      	mov	r3, r0
}
 c003eda:	4618      	mov	r0, r3
 c003edc:	3708      	adds	r7, #8
 c003ede:	46bd      	mov	sp, r7
 c003ee0:	bd80      	pop	{r7, pc}
	...

0c003ee4 <HAL_FLASH_Program>:
  *                This parameter is the data for the double word program
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 c003ee4:	b580      	push	{r7, lr}
 c003ee6:	b086      	sub	sp, #24
 c003ee8:	af00      	add	r7, sp, #0
 c003eea:	60f8      	str	r0, [r7, #12]
 c003eec:	60b9      	str	r1, [r7, #8]
 c003eee:	e9c7 2300 	strd	r2, r3, [r7]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 c003ef2:	4b1e      	ldr	r3, [pc, #120]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003ef4:	781b      	ldrb	r3, [r3, #0]
 c003ef6:	2b01      	cmp	r3, #1
 c003ef8:	d101      	bne.n	c003efe <HAL_FLASH_Program+0x1a>
 c003efa:	2302      	movs	r3, #2
 c003efc:	e032      	b.n	c003f64 <HAL_FLASH_Program+0x80>
 c003efe:	4b1b      	ldr	r3, [pc, #108]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f00:	2201      	movs	r2, #1
 c003f02:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c003f04:	4b19      	ldr	r3, [pc, #100]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f06:	2200      	movs	r2, #0
 c003f08:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c003f0a:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c003f0e:	f000 f89f 	bl	c004050 <FLASH_WaitForLastOperation>
 c003f12:	4603      	mov	r3, r0
 c003f14:	75fb      	strb	r3, [r7, #23]

  if(status == HAL_OK)
 c003f16:	7dfb      	ldrb	r3, [r7, #23]
 c003f18:	2b00      	cmp	r3, #0
 c003f1a:	d11f      	bne.n	c003f5c <HAL_FLASH_Program+0x78>
  {
    pFlash.ProcedureOnGoing = TypeProgram;
 c003f1c:	4a13      	ldr	r2, [pc, #76]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f1e:	68fb      	ldr	r3, [r7, #12]
 c003f20:	6093      	str	r3, [r2, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c003f22:	4b12      	ldr	r3, [pc, #72]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f24:	689b      	ldr	r3, [r3, #8]
 c003f26:	2b00      	cmp	r3, #0
 c003f28:	db01      	blt.n	c003f2e <HAL_FLASH_Program+0x4a>
 c003f2a:	4b11      	ldr	r3, [pc, #68]	@ (c003f70 <HAL_FLASH_Program+0x8c>)
 c003f2c:	e000      	b.n	c003f30 <HAL_FLASH_Program+0x4c>
 c003f2e:	4b11      	ldr	r3, [pc, #68]	@ (c003f74 <HAL_FLASH_Program+0x90>)
 c003f30:	613b      	str	r3, [r7, #16]

    /* Program double-word (64-bit) at a specified address */
    FLASH_Program_DoubleWord(Address, Data);
 c003f32:	e9d7 2300 	ldrd	r2, r3, [r7]
 c003f36:	68b8      	ldr	r0, [r7, #8]
 c003f38:	f000 f8e8 	bl	c00410c <FLASH_Program_DoubleWord>

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c003f3c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c003f40:	f000 f886 	bl	c004050 <FLASH_WaitForLastOperation>
 c003f44:	4603      	mov	r3, r0
 c003f46:	75fb      	strb	r3, [r7, #23]

    /* If the program operation is completed, disable the PG Bit */
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c003f48:	693b      	ldr	r3, [r7, #16]
 c003f4a:	681a      	ldr	r2, [r3, #0]
 c003f4c:	4b07      	ldr	r3, [pc, #28]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f4e:	689b      	ldr	r3, [r3, #8]
 c003f50:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c003f54:	43db      	mvns	r3, r3
 c003f56:	401a      	ands	r2, r3
 c003f58:	693b      	ldr	r3, [r7, #16]
 c003f5a:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c003f5c:	4b03      	ldr	r3, [pc, #12]	@ (c003f6c <HAL_FLASH_Program+0x88>)
 c003f5e:	2200      	movs	r2, #0
 c003f60:	701a      	strb	r2, [r3, #0]

  return status;
 c003f62:	7dfb      	ldrb	r3, [r7, #23]
}
 c003f64:	4618      	mov	r0, r3
 c003f66:	3718      	adds	r7, #24
 c003f68:	46bd      	mov	sp, r7
 c003f6a:	bd80      	pop	{r7, pc}
 c003f6c:	30000024 	.word	0x30000024
 c003f70:	5002202c 	.word	0x5002202c
 c003f74:	40022028 	.word	0x40022028

0c003f78 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 c003f78:	b480      	push	{r7}
 c003f7a:	b083      	sub	sp, #12
 c003f7c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c003f7e:	2300      	movs	r3, #0
 c003f80:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003f82:	4b15      	ldr	r3, [pc, #84]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003f84:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003f86:	2b00      	cmp	r3, #0
 c003f88:	da0b      	bge.n	c003fa2 <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c003f8a:	4b13      	ldr	r3, [pc, #76]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003f8c:	4a13      	ldr	r2, [pc, #76]	@ (c003fdc <HAL_FLASH_Unlock+0x64>)
 c003f8e:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c003f90:	4b11      	ldr	r3, [pc, #68]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003f92:	4a13      	ldr	r2, [pc, #76]	@ (c003fe0 <HAL_FLASH_Unlock+0x68>)
 c003f94:	609a      	str	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003f96:	4b10      	ldr	r3, [pc, #64]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003f98:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003f9a:	2b00      	cmp	r3, #0
 c003f9c:	da01      	bge.n	c003fa2 <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 c003f9e:	2301      	movs	r3, #1
 c003fa0:	71fb      	strb	r3, [r7, #7]
    }
  }

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if (status == HAL_OK)
 c003fa2:	79fb      	ldrb	r3, [r7, #7]
 c003fa4:	2b00      	cmp	r3, #0
 c003fa6:	d10f      	bne.n	c003fc8 <HAL_FLASH_Unlock+0x50>
  {
    if(READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c003fa8:	4b0b      	ldr	r3, [pc, #44]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003faa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c003fac:	2b00      	cmp	r3, #0
 c003fae:	da0b      	bge.n	c003fc8 <HAL_FLASH_Unlock+0x50>
    {
      /* Authorize the FLASH Registers access */
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c003fb0:	4b09      	ldr	r3, [pc, #36]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003fb2:	4a0a      	ldr	r2, [pc, #40]	@ (c003fdc <HAL_FLASH_Unlock+0x64>)
 c003fb4:	60da      	str	r2, [r3, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c003fb6:	4b08      	ldr	r3, [pc, #32]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003fb8:	4a09      	ldr	r2, [pc, #36]	@ (c003fe0 <HAL_FLASH_Unlock+0x68>)
 c003fba:	60da      	str	r2, [r3, #12]

      /* verify Flash is unlocked */
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c003fbc:	4b06      	ldr	r3, [pc, #24]	@ (c003fd8 <HAL_FLASH_Unlock+0x60>)
 c003fbe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c003fc0:	2b00      	cmp	r3, #0
 c003fc2:	da01      	bge.n	c003fc8 <HAL_FLASH_Unlock+0x50>
      {
        status = HAL_ERROR;
 c003fc4:	2301      	movs	r3, #1
 c003fc6:	71fb      	strb	r3, [r7, #7]
      }
    }
  }
#endif

  return status;
 c003fc8:	79fb      	ldrb	r3, [r7, #7]
}
 c003fca:	4618      	mov	r0, r3
 c003fcc:	370c      	adds	r7, #12
 c003fce:	46bd      	mov	sp, r7
 c003fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 c003fd4:	4770      	bx	lr
 c003fd6:	bf00      	nop
 c003fd8:	50022000 	.word	0x50022000
 c003fdc:	45670123 	.word	0x45670123
 c003fe0:	cdef89ab 	.word	0xcdef89ab

0c003fe4 <HAL_FLASH_Lock>:
/**
  * @brief  Lock the FLASH control register access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 c003fe4:	b480      	push	{r7}
 c003fe6:	b083      	sub	sp, #12
 c003fe8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_ERROR;
 c003fea:	2301      	movs	r3, #1
 c003fec:	71fb      	strb	r3, [r7, #7]

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c003fee:	4b11      	ldr	r3, [pc, #68]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c003ff0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003ff2:	4a10      	ldr	r2, [pc, #64]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c003ff4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c003ff8:	6293      	str	r3, [r2, #40]	@ 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003ffa:	4b0e      	ldr	r3, [pc, #56]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c003ffc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c003ffe:	2b00      	cmp	r3, #0
 c004000:	da01      	bge.n	c004006 <HAL_FLASH_Lock+0x22>
  {
    status = HAL_OK;
 c004002:	2300      	movs	r3, #0
 c004004:	71fb      	strb	r3, [r7, #7]
  }

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  if (status == HAL_OK)
 c004006:	79fb      	ldrb	r3, [r7, #7]
 c004008:	2b00      	cmp	r3, #0
 c00400a:	d10b      	bne.n	c004024 <HAL_FLASH_Lock+0x40>
  {
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c00400c:	4b09      	ldr	r3, [pc, #36]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c00400e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c004010:	4a08      	ldr	r2, [pc, #32]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c004012:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c004016:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* verify Flash is locked */
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c004018:	4b06      	ldr	r3, [pc, #24]	@ (c004034 <HAL_FLASH_Lock+0x50>)
 c00401a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c00401c:	2b00      	cmp	r3, #0
 c00401e:	da01      	bge.n	c004024 <HAL_FLASH_Lock+0x40>
    {
      status = HAL_OK;
 c004020:	2300      	movs	r3, #0
 c004022:	71fb      	strb	r3, [r7, #7]
    }
  }
#endif

  return status;
 c004024:	79fb      	ldrb	r3, [r7, #7]
}
 c004026:	4618      	mov	r0, r3
 c004028:	370c      	adds	r7, #12
 c00402a:	46bd      	mov	sp, r7
 c00402c:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004030:	4770      	bx	lr
 c004032:	bf00      	nop
 c004034:	50022000 	.word	0x50022000

0c004038 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_SIZ: FLASH Size error
  *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming sequence error
  *            @arg HAL_FLASH_ERROR_OPTW: FLASH Option modification error
  */
uint32_t HAL_FLASH_GetError(void)
{
 c004038:	b480      	push	{r7}
 c00403a:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
 c00403c:	4b03      	ldr	r3, [pc, #12]	@ (c00404c <HAL_FLASH_GetError+0x14>)
 c00403e:	685b      	ldr	r3, [r3, #4]
}
 c004040:	4618      	mov	r0, r3
 c004042:	46bd      	mov	sp, r7
 c004044:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004048:	4770      	bx	lr
 c00404a:	bf00      	nop
 c00404c:	30000024 	.word	0x30000024

0c004050 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 c004050:	b580      	push	{r7, lr}
 c004052:	b086      	sub	sp, #24
 c004054:	af00      	add	r7, sp, #0
 c004056:	6078      	str	r0, [r7, #4]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
 c004058:	f7ff fe18 	bl	c003c8c <HAL_GetTick>
 c00405c:	4602      	mov	r2, r0
 c00405e:	687b      	ldr	r3, [r7, #4]
 c004060:	4413      	add	r3, r2
 c004062:	617b      	str	r3, [r7, #20]
  uint32_t error;
  __IO uint32_t *reg_sr;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c004064:	e00b      	b.n	c00407e <FLASH_WaitForLastOperation+0x2e>
  {
    if(Timeout != HAL_MAX_DELAY)
 c004066:	687b      	ldr	r3, [r7, #4]
 c004068:	f1b3 3fff 	cmp.w	r3, #4294967295
 c00406c:	d007      	beq.n	c00407e <FLASH_WaitForLastOperation+0x2e>
    {
      if(HAL_GetTick() >= timeout)
 c00406e:	f7ff fe0d 	bl	c003c8c <HAL_GetTick>
 c004072:	4602      	mov	r2, r0
 c004074:	697b      	ldr	r3, [r7, #20]
 c004076:	4293      	cmp	r3, r2
 c004078:	d801      	bhi.n	c00407e <FLASH_WaitForLastOperation+0x2e>
      {
        return HAL_TIMEOUT;
 c00407a:	2303      	movs	r3, #3
 c00407c:	e03a      	b.n	c0040f4 <FLASH_WaitForLastOperation+0xa4>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c00407e:	4b1f      	ldr	r3, [pc, #124]	@ (c0040fc <FLASH_WaitForLastOperation+0xac>)
 c004080:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c004082:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c004086:	2b00      	cmp	r3, #0
 c004088:	d1ed      	bne.n	c004066 <FLASH_WaitForLastOperation+0x16>
      }
    }
  }
  
  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c00408a:	4b1d      	ldr	r3, [pc, #116]	@ (c004100 <FLASH_WaitForLastOperation+0xb0>)
 c00408c:	689b      	ldr	r3, [r3, #8]
 c00408e:	2b00      	cmp	r3, #0
 c004090:	db01      	blt.n	c004096 <FLASH_WaitForLastOperation+0x46>
 c004092:	4b1c      	ldr	r3, [pc, #112]	@ (c004104 <FLASH_WaitForLastOperation+0xb4>)
 c004094:	e000      	b.n	c004098 <FLASH_WaitForLastOperation+0x48>
 c004096:	4b1c      	ldr	r3, [pc, #112]	@ (c004108 <FLASH_WaitForLastOperation+0xb8>)
 c004098:	613b      	str	r3, [r7, #16]

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c00409a:	693b      	ldr	r3, [r7, #16]
 c00409c:	681b      	ldr	r3, [r3, #0]
 c00409e:	f003 03fa 	and.w	r3, r3, #250	@ 0xfa
 c0040a2:	60fb      	str	r3, [r7, #12]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c0040a4:	4b15      	ldr	r3, [pc, #84]	@ (c0040fc <FLASH_WaitForLastOperation+0xac>)
 c0040a6:	6a1b      	ldr	r3, [r3, #32]
 c0040a8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 c0040ac:	68fa      	ldr	r2, [r7, #12]
 c0040ae:	4313      	orrs	r3, r2
 c0040b0:	60fb      	str	r3, [r7, #12]
#endif /* __ARM_FEATURE_CMSE */ 

  if(error != 0u)
 c0040b2:	68fb      	ldr	r3, [r7, #12]
 c0040b4:	2b00      	cmp	r3, #0
 c0040b6:	d013      	beq.n	c0040e0 <FLASH_WaitForLastOperation+0x90>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 c0040b8:	4b11      	ldr	r3, [pc, #68]	@ (c004100 <FLASH_WaitForLastOperation+0xb0>)
 c0040ba:	685a      	ldr	r2, [r3, #4]
 c0040bc:	68fb      	ldr	r3, [r7, #12]
 c0040be:	4313      	orrs	r3, r2
 c0040c0:	4a0f      	ldr	r2, [pc, #60]	@ (c004100 <FLASH_WaitForLastOperation+0xb0>)
 c0040c2:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    (*reg_sr) = error;
 c0040c4:	693b      	ldr	r3, [r7, #16]
 c0040c6:	68fa      	ldr	r2, [r7, #12]
 c0040c8:	601a      	str	r2, [r3, #0]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c0040ca:	68fb      	ldr	r3, [r7, #12]
 c0040cc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 c0040d0:	2b00      	cmp	r3, #0
 c0040d2:	d003      	beq.n	c0040dc <FLASH_WaitForLastOperation+0x8c>
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c0040d4:	4b09      	ldr	r3, [pc, #36]	@ (c0040fc <FLASH_WaitForLastOperation+0xac>)
 c0040d6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 c0040da:	621a      	str	r2, [r3, #32]
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
 c0040dc:	2301      	movs	r3, #1
 c0040de:	e009      	b.n	c0040f4 <FLASH_WaitForLastOperation+0xa4>
  }

  /* Check FLASH End of Operation flag  */
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c0040e0:	693b      	ldr	r3, [r7, #16]
 c0040e2:	681b      	ldr	r3, [r3, #0]
 c0040e4:	f003 0301 	and.w	r3, r3, #1
 c0040e8:	2b00      	cmp	r3, #0
 c0040ea:	d002      	beq.n	c0040f2 <FLASH_WaitForLastOperation+0xa2>
  {
    /* Clear FLASH End of Operation pending bit */
    (*reg_sr) = FLASH_FLAG_EOP;
 c0040ec:	693b      	ldr	r3, [r7, #16]
 c0040ee:	2201      	movs	r2, #1
 c0040f0:	601a      	str	r2, [r3, #0]
  }

  /* If there is an error flag set */
  return HAL_OK;
 c0040f2:	2300      	movs	r3, #0
}
 c0040f4:	4618      	mov	r0, r3
 c0040f6:	3718      	adds	r7, #24
 c0040f8:	46bd      	mov	sp, r7
 c0040fa:	bd80      	pop	{r7, pc}
 c0040fc:	50022000 	.word	0x50022000
 c004100:	30000024 	.word	0x30000024
 c004104:	50022024 	.word	0x50022024
 c004108:	40022020 	.word	0x40022020

0c00410c <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 c00410c:	b480      	push	{r7}
 c00410e:	b089      	sub	sp, #36	@ 0x24
 c004110:	af00      	add	r7, sp, #0
 c004112:	60f8      	str	r0, [r7, #12]
 c004114:	e9c7 2300 	strd	r2, r3, [r7]
  __IO uint32_t *reg;
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c004118:	4b19      	ldr	r3, [pc, #100]	@ (c004180 <FLASH_Program_DoubleWord+0x74>)
 c00411a:	689b      	ldr	r3, [r3, #8]
 c00411c:	2b00      	cmp	r3, #0
 c00411e:	db01      	blt.n	c004124 <FLASH_Program_DoubleWord+0x18>
 c004120:	4b18      	ldr	r3, [pc, #96]	@ (c004184 <FLASH_Program_DoubleWord+0x78>)
 c004122:	e000      	b.n	c004126 <FLASH_Program_DoubleWord+0x1a>
 c004124:	4b18      	ldr	r3, [pc, #96]	@ (c004188 <FLASH_Program_DoubleWord+0x7c>)
 c004126:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c004128:	f3ef 8310 	mrs	r3, PRIMASK
 c00412c:	613b      	str	r3, [r7, #16]
  return(result);
 c00412e:	693b      	ldr	r3, [r7, #16]

  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
 c004130:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 c004132:	b672      	cpsid	i
}
 c004134:	bf00      	nop
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 c004136:	69fb      	ldr	r3, [r7, #28]
 c004138:	681b      	ldr	r3, [r3, #0]
 c00413a:	f043 0201 	orr.w	r2, r3, #1
 c00413e:	69fb      	ldr	r3, [r7, #28]
 c004140:	601a      	str	r2, [r3, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 c004142:	68fb      	ldr	r3, [r7, #12]
 c004144:	683a      	ldr	r2, [r7, #0]
 c004146:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c004148:	f3bf 8f6f 	isb	sy
}
 c00414c:	bf00      	nop
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 c00414e:	e9d7 0100 	ldrd	r0, r1, [r7]
 c004152:	f04f 0200 	mov.w	r2, #0
 c004156:	f04f 0300 	mov.w	r3, #0
 c00415a:	000a      	movs	r2, r1
 c00415c:	2300      	movs	r3, #0
 c00415e:	68f9      	ldr	r1, [r7, #12]
 c004160:	3104      	adds	r1, #4
 c004162:	4613      	mov	r3, r2
 c004164:	600b      	str	r3, [r1, #0]
 c004166:	69bb      	ldr	r3, [r7, #24]
 c004168:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c00416a:	697b      	ldr	r3, [r7, #20]
 c00416c:	f383 8810 	msr	PRIMASK, r3
}
 c004170:	bf00      	nop

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 c004172:	bf00      	nop
 c004174:	3724      	adds	r7, #36	@ 0x24
 c004176:	46bd      	mov	sp, r7
 c004178:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00417c:	4770      	bx	lr
 c00417e:	bf00      	nop
 c004180:	30000024 	.word	0x30000024
 c004184:	5002202c 	.word	0x5002202c
 c004188:	40022028 	.word	0x40022028

0c00418c <HAL_FLASHEx_Erase>:
  *         the pages have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 c00418c:	b580      	push	{r7, lr}
 c00418e:	b086      	sub	sp, #24
 c004190:	af00      	add	r7, sp, #0
 c004192:	6078      	str	r0, [r7, #4]
 c004194:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 c004196:	4b36      	ldr	r3, [pc, #216]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c004198:	781b      	ldrb	r3, [r3, #0]
 c00419a:	2b01      	cmp	r3, #1
 c00419c:	d101      	bne.n	c0041a2 <HAL_FLASHEx_Erase+0x16>
 c00419e:	2302      	movs	r3, #2
 c0041a0:	e062      	b.n	c004268 <HAL_FLASHEx_Erase+0xdc>
 c0041a2:	4b33      	ldr	r3, [pc, #204]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c0041a4:	2201      	movs	r2, #1
 c0041a6:	701a      	strb	r2, [r3, #0]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0041a8:	4b31      	ldr	r3, [pc, #196]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c0041aa:	2200      	movs	r2, #0
 c0041ac:	605a      	str	r2, [r3, #4]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0041ae:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c0041b2:	f7ff ff4d 	bl	c004050 <FLASH_WaitForLastOperation>
 c0041b6:	4603      	mov	r3, r0
 c0041b8:	75fb      	strb	r3, [r7, #23]

  if (status == HAL_OK)
 c0041ba:	7dfb      	ldrb	r3, [r7, #23]
 c0041bc:	2b00      	cmp	r3, #0
 c0041be:	d14f      	bne.n	c004260 <HAL_FLASHEx_Erase+0xd4>
  {
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0041c0:	687b      	ldr	r3, [r7, #4]
 c0041c2:	681b      	ldr	r3, [r3, #0]
 c0041c4:	4a2a      	ldr	r2, [pc, #168]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c0041c6:	6093      	str	r3, [r2, #8]

    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0041c8:	4b29      	ldr	r3, [pc, #164]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c0041ca:	689b      	ldr	r3, [r3, #8]
 c0041cc:	2b00      	cmp	r3, #0
 c0041ce:	db01      	blt.n	c0041d4 <HAL_FLASHEx_Erase+0x48>
 c0041d0:	4b28      	ldr	r3, [pc, #160]	@ (c004274 <HAL_FLASHEx_Erase+0xe8>)
 c0041d2:	e000      	b.n	c0041d6 <HAL_FLASHEx_Erase+0x4a>
 c0041d4:	4b28      	ldr	r3, [pc, #160]	@ (c004278 <HAL_FLASHEx_Erase+0xec>)
 c0041d6:	60fb      	str	r3, [r7, #12]

    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c0041d8:	4b25      	ldr	r3, [pc, #148]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c0041da:	689b      	ldr	r3, [r3, #8]
 c0041dc:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c0041e0:	f248 0204 	movw	r2, #32772	@ 0x8004
 c0041e4:	4293      	cmp	r3, r2
 c0041e6:	d10b      	bne.n	c004200 <HAL_FLASHEx_Erase+0x74>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->Banks);
 c0041e8:	687b      	ldr	r3, [r7, #4]
 c0041ea:	685b      	ldr	r3, [r3, #4]
 c0041ec:	4618      	mov	r0, r3
 c0041ee:	f000 f8bd 	bl	c00436c <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0041f2:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c0041f6:	f7ff ff2b 	bl	c004050 <FLASH_WaitForLastOperation>
 c0041fa:	4603      	mov	r3, r0
 c0041fc:	75fb      	strb	r3, [r7, #23]
 c0041fe:	e025      	b.n	c00424c <HAL_FLASHEx_Erase+0xc0>
    }
    else
    {
      /*Initialization of PageError variable*/
      *PageError = 0xFFFFFFFFU;
 c004200:	683b      	ldr	r3, [r7, #0]
 c004202:	f04f 32ff 	mov.w	r2, #4294967295
 c004206:	601a      	str	r2, [r3, #0]

      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c004208:	687b      	ldr	r3, [r7, #4]
 c00420a:	689b      	ldr	r3, [r3, #8]
 c00420c:	613b      	str	r3, [r7, #16]
 c00420e:	e015      	b.n	c00423c <HAL_FLASHEx_Erase+0xb0>
      {
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c004210:	687b      	ldr	r3, [r7, #4]
 c004212:	685b      	ldr	r3, [r3, #4]
 c004214:	4619      	mov	r1, r3
 c004216:	6938      	ldr	r0, [r7, #16]
 c004218:	f000 f8fa 	bl	c004410 <FLASH_PageErase>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c00421c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c004220:	f7ff ff16 	bl	c004050 <FLASH_WaitForLastOperation>
 c004224:	4603      	mov	r3, r0
 c004226:	75fb      	strb	r3, [r7, #23]

        if (status != HAL_OK)
 c004228:	7dfb      	ldrb	r3, [r7, #23]
 c00422a:	2b00      	cmp	r3, #0
 c00422c:	d003      	beq.n	c004236 <HAL_FLASHEx_Erase+0xaa>
        {
          /* In case of error, stop erase procedure and return the faulty page */
          *PageError = page_index;
 c00422e:	683b      	ldr	r3, [r7, #0]
 c004230:	693a      	ldr	r2, [r7, #16]
 c004232:	601a      	str	r2, [r3, #0]
          break;
 c004234:	e00a      	b.n	c00424c <HAL_FLASHEx_Erase+0xc0>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c004236:	693b      	ldr	r3, [r7, #16]
 c004238:	3301      	adds	r3, #1
 c00423a:	613b      	str	r3, [r7, #16]
 c00423c:	687b      	ldr	r3, [r7, #4]
 c00423e:	689a      	ldr	r2, [r3, #8]
 c004240:	687b      	ldr	r3, [r7, #4]
 c004242:	68db      	ldr	r3, [r3, #12]
 c004244:	4413      	add	r3, r2
 c004246:	693a      	ldr	r2, [r7, #16]
 c004248:	429a      	cmp	r2, r3
 c00424a:	d3e1      	bcc.n	c004210 <HAL_FLASHEx_Erase+0x84>
        }
      }
    }

    /* If the erase operation is completed, disable the associated bits */
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c00424c:	68fb      	ldr	r3, [r7, #12]
 c00424e:	681a      	ldr	r2, [r3, #0]
 c004250:	4b07      	ldr	r3, [pc, #28]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c004252:	689b      	ldr	r3, [r3, #8]
 c004254:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c004258:	43db      	mvns	r3, r3
 c00425a:	401a      	ands	r2, r3
 c00425c:	68fb      	ldr	r3, [r7, #12]
 c00425e:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c004260:	4b03      	ldr	r3, [pc, #12]	@ (c004270 <HAL_FLASHEx_Erase+0xe4>)
 c004262:	2200      	movs	r2, #0
 c004264:	701a      	strb	r2, [r3, #0]

  return status;
 c004266:	7dfb      	ldrb	r3, [r7, #23]
}
 c004268:	4618      	mov	r0, r3
 c00426a:	3718      	adds	r7, #24
 c00426c:	46bd      	mov	sp, r7
 c00426e:	bd80      	pop	{r7, pc}
 c004270:	30000024 	.word	0x30000024
 c004274:	5002202c 	.word	0x5002202c
 c004278:	40022028 	.word	0x40022028

0c00427c <HAL_FLASHEx_ConfigBBAttributes>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_ConfigBBAttributes(FLASH_BBAttributesTypeDef *pBBAttributes)
{
 c00427c:	b580      	push	{r7, lr}
 c00427e:	b084      	sub	sp, #16
 c004280:	af00      	add	r7, sp, #0
 c004282:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pBBAttributes->Bank));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c004284:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c004288:	f7ff fee2 	bl	c004050 <FLASH_WaitForLastOperation>
 c00428c:	4603      	mov	r3, r0
 c00428e:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
 c004290:	7bfb      	ldrb	r3, [r7, #15]
 c004292:	2b00      	cmp	r3, #0
 c004294:	d12d      	bne.n	c0042f2 <HAL_FLASHEx_ConfigBBAttributes+0x76>
  {
    if (pBBAttributes->BBAttributesType == FLASH_BB_SEC)
 c004296:	687b      	ldr	r3, [r7, #4]
 c004298:	685b      	ldr	r3, [r3, #4]
 c00429a:	2b01      	cmp	r3, #1
 c00429c:	d126      	bne.n	c0042ec <HAL_FLASHEx_ConfigBBAttributes+0x70>
    {
      if (pBBAttributes->Bank == FLASH_BANK_1)
 c00429e:	687b      	ldr	r3, [r7, #4]
 c0042a0:	681b      	ldr	r3, [r3, #0]
 c0042a2:	2b01      	cmp	r3, #1
 c0042a4:	d102      	bne.n	c0042ac <HAL_FLASHEx_ConfigBBAttributes+0x30>
      {
        reg = &(FLASH->SECBB1R1);
 c0042a6:	4b17      	ldr	r3, [pc, #92]	@ (c004304 <HAL_FLASHEx_ConfigBBAttributes+0x88>)
 c0042a8:	60bb      	str	r3, [r7, #8]
 c0042aa:	e001      	b.n	c0042b0 <HAL_FLASHEx_ConfigBBAttributes+0x34>
      }
      else
      {
        reg = &(FLASH->SECBB2R1);
 c0042ac:	4b16      	ldr	r3, [pc, #88]	@ (c004308 <HAL_FLASHEx_ConfigBBAttributes+0x8c>)
 c0042ae:	60bb      	str	r3, [r7, #8]
      }

      /* Modify the register values and check that new attributes are taken in account */
      for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c0042b0:	2300      	movs	r3, #0
 c0042b2:	73bb      	strb	r3, [r7, #14]
 c0042b4:	e017      	b.n	c0042e6 <HAL_FLASHEx_ConfigBBAttributes+0x6a>
      {
        *reg = pBBAttributes->BBAttributes_array[index];
 c0042b6:	7bba      	ldrb	r2, [r7, #14]
 c0042b8:	687b      	ldr	r3, [r7, #4]
 c0042ba:	3202      	adds	r2, #2
 c0042bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 c0042c0:	68bb      	ldr	r3, [r7, #8]
 c0042c2:	601a      	str	r2, [r3, #0]
        if (*reg != pBBAttributes->BBAttributes_array[index])
 c0042c4:	68bb      	ldr	r3, [r7, #8]
 c0042c6:	681a      	ldr	r2, [r3, #0]
 c0042c8:	7bb9      	ldrb	r1, [r7, #14]
 c0042ca:	687b      	ldr	r3, [r7, #4]
 c0042cc:	3102      	adds	r1, #2
 c0042ce:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c0042d2:	429a      	cmp	r2, r3
 c0042d4:	d001      	beq.n	c0042da <HAL_FLASHEx_ConfigBBAttributes+0x5e>
        {
          status = HAL_ERROR;
 c0042d6:	2301      	movs	r3, #1
 c0042d8:	73fb      	strb	r3, [r7, #15]
        }
        reg++;
 c0042da:	68bb      	ldr	r3, [r7, #8]
 c0042dc:	3304      	adds	r3, #4
 c0042de:	60bb      	str	r3, [r7, #8]
      for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c0042e0:	7bbb      	ldrb	r3, [r7, #14]
 c0042e2:	3301      	adds	r3, #1
 c0042e4:	73bb      	strb	r3, [r7, #14]
 c0042e6:	7bbb      	ldrb	r3, [r7, #14]
 c0042e8:	2b03      	cmp	r3, #3
 c0042ea:	d9e4      	bls.n	c0042b6 <HAL_FLASHEx_ConfigBBAttributes+0x3a>
  __ASM volatile ("isb 0xF":::"memory");
 c0042ec:	f3bf 8f6f 	isb	sy
}
 c0042f0:	bf00      	nop
    /* ISB instruction is called to be sure next instructions are performed with correct attributes */
    __ISB();
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 c0042f2:	4b06      	ldr	r3, [pc, #24]	@ (c00430c <HAL_FLASHEx_ConfigBBAttributes+0x90>)
 c0042f4:	2200      	movs	r2, #0
 c0042f6:	701a      	strb	r2, [r3, #0]

  return status;
 c0042f8:	7bfb      	ldrb	r3, [r7, #15]
}
 c0042fa:	4618      	mov	r0, r3
 c0042fc:	3710      	adds	r7, #16
 c0042fe:	46bd      	mov	sp, r7
 c004300:	bd80      	pop	{r7, pc}
 c004302:	bf00      	nop
 c004304:	50022080 	.word	0x50022080
 c004308:	500220a0 	.word	0x500220a0
 c00430c:	30000024 	.word	0x30000024

0c004310 <HAL_FLASHEx_GetConfigBBAttributes>:
  *          for the block-based security, else no information will be returned
  *
  * @retval None
  */
void HAL_FLASHEx_GetConfigBBAttributes(FLASH_BBAttributesTypeDef *pBBAttributes)
{
 c004310:	b480      	push	{r7}
 c004312:	b085      	sub	sp, #20
 c004314:	af00      	add	r7, sp, #0
 c004316:	6078      	str	r0, [r7, #4]
  __IO uint32_t *reg;

  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pBBAttributes->Bank));

  if (pBBAttributes->BBAttributesType == FLASH_BB_SEC)
 c004318:	687b      	ldr	r3, [r7, #4]
 c00431a:	685b      	ldr	r3, [r3, #4]
 c00431c:	2b01      	cmp	r3, #1
 c00431e:	d11b      	bne.n	c004358 <HAL_FLASHEx_GetConfigBBAttributes+0x48>
  {
    if (pBBAttributes->Bank == FLASH_BANK_1)
 c004320:	687b      	ldr	r3, [r7, #4]
 c004322:	681b      	ldr	r3, [r3, #0]
 c004324:	2b01      	cmp	r3, #1
 c004326:	d102      	bne.n	c00432e <HAL_FLASHEx_GetConfigBBAttributes+0x1e>
    {
      reg = &(FLASH->SECBB1R1);
 c004328:	4b0e      	ldr	r3, [pc, #56]	@ (c004364 <HAL_FLASHEx_GetConfigBBAttributes+0x54>)
 c00432a:	60bb      	str	r3, [r7, #8]
 c00432c:	e001      	b.n	c004332 <HAL_FLASHEx_GetConfigBBAttributes+0x22>
    }
    else
    {
      reg = &(FLASH->SECBB2R1);
 c00432e:	4b0e      	ldr	r3, [pc, #56]	@ (c004368 <HAL_FLASHEx_GetConfigBBAttributes+0x58>)
 c004330:	60bb      	str	r3, [r7, #8]
    }

    for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c004332:	2300      	movs	r3, #0
 c004334:	73fb      	strb	r3, [r7, #15]
 c004336:	e00c      	b.n	c004352 <HAL_FLASHEx_GetConfigBBAttributes+0x42>
    {
      pBBAttributes->BBAttributes_array[index] = *reg;
 c004338:	7bfa      	ldrb	r2, [r7, #15]
 c00433a:	68bb      	ldr	r3, [r7, #8]
 c00433c:	6819      	ldr	r1, [r3, #0]
 c00433e:	687b      	ldr	r3, [r7, #4]
 c004340:	3202      	adds	r2, #2
 c004342:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      reg++;
 c004346:	68bb      	ldr	r3, [r7, #8]
 c004348:	3304      	adds	r3, #4
 c00434a:	60bb      	str	r3, [r7, #8]
    for (index = 0; index < FLASH_BLOCKBASED_NB_REG; index++)
 c00434c:	7bfb      	ldrb	r3, [r7, #15]
 c00434e:	3301      	adds	r3, #1
 c004350:	73fb      	strb	r3, [r7, #15]
 c004352:	7bfb      	ldrb	r3, [r7, #15]
 c004354:	2b03      	cmp	r3, #3
 c004356:	d9ef      	bls.n	c004338 <HAL_FLASHEx_GetConfigBBAttributes+0x28>
    }
  }
}
 c004358:	bf00      	nop
 c00435a:	3714      	adds	r7, #20
 c00435c:	46bd      	mov	sp, r7
 c00435e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004362:	4770      	bx	lr
 c004364:	50022080 	.word	0x50022080
 c004368:	500220a0 	.word	0x500220a0

0c00436c <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 c00436c:	b480      	push	{r7}
 c00436e:	b087      	sub	sp, #28
 c004370:	af00      	add	r7, sp, #0
 c004372:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c004374:	f3ef 8310 	mrs	r3, PRIMASK
 c004378:	60fb      	str	r3, [r7, #12]
  return(result);
 c00437a:	68fb      	ldr	r3, [r7, #12]
  
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  uint32_t primask_bit;

  /* Disable interrupts to avoid any interruption */
  primask_bit = __get_PRIMASK();
 c00437c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 c00437e:	b672      	cpsid	i
}
 c004380:	bf00      	nop
  __disable_irq();
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c004382:	4b1f      	ldr	r3, [pc, #124]	@ (c004400 <FLASH_MassErase+0x94>)
 c004384:	689b      	ldr	r3, [r3, #8]
 c004386:	2b00      	cmp	r3, #0
 c004388:	db01      	blt.n	c00438e <FLASH_MassErase+0x22>
 c00438a:	4b1e      	ldr	r3, [pc, #120]	@ (c004404 <FLASH_MassErase+0x98>)
 c00438c:	e000      	b.n	c004390 <FLASH_MassErase+0x24>
 c00438e:	4b1e      	ldr	r3, [pc, #120]	@ (c004408 <FLASH_MassErase+0x9c>)
 c004390:	613b      	str	r3, [r7, #16]

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 c004392:	4b1e      	ldr	r3, [pc, #120]	@ (c00440c <FLASH_MassErase+0xa0>)
 c004394:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 c004396:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c00439a:	2b00      	cmp	r3, #0
 c00439c:	d016      	beq.n	c0043cc <FLASH_MassErase+0x60>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 c00439e:	687b      	ldr	r3, [r7, #4]
 c0043a0:	f003 0301 	and.w	r3, r3, #1
 c0043a4:	2b00      	cmp	r3, #0
 c0043a6:	d005      	beq.n	c0043b4 <FLASH_MassErase+0x48>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 c0043a8:	693b      	ldr	r3, [r7, #16]
 c0043aa:	681b      	ldr	r3, [r3, #0]
 c0043ac:	f043 0204 	orr.w	r2, r3, #4
 c0043b0:	693b      	ldr	r3, [r7, #16]
 c0043b2:	601a      	str	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 c0043b4:	687b      	ldr	r3, [r7, #4]
 c0043b6:	f003 0302 	and.w	r3, r3, #2
 c0043ba:	2b00      	cmp	r3, #0
 c0043bc:	d00e      	beq.n	c0043dc <FLASH_MassErase+0x70>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 c0043be:	693b      	ldr	r3, [r7, #16]
 c0043c0:	681b      	ldr	r3, [r3, #0]
 c0043c2:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
 c0043c6:	693b      	ldr	r3, [r7, #16]
 c0043c8:	601a      	str	r2, [r3, #0]
 c0043ca:	e007      	b.n	c0043dc <FLASH_MassErase+0x70>
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c0043cc:	693b      	ldr	r3, [r7, #16]
 c0043ce:	681b      	ldr	r3, [r3, #0]
 c0043d0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 c0043d4:	f043 0304 	orr.w	r3, r3, #4
 c0043d8:	693a      	ldr	r2, [r7, #16]
 c0043da:	6013      	str	r3, [r2, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c0043dc:	693b      	ldr	r3, [r7, #16]
 c0043de:	681b      	ldr	r3, [r3, #0]
 c0043e0:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 c0043e4:	693b      	ldr	r3, [r7, #16]
 c0043e6:	601a      	str	r2, [r3, #0]
 c0043e8:	697b      	ldr	r3, [r7, #20]
 c0043ea:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c0043ec:	68bb      	ldr	r3, [r7, #8]
 c0043ee:	f383 8810 	msr	PRIMASK, r3
}
 c0043f2:	bf00      	nop

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c0043f4:	bf00      	nop
 c0043f6:	371c      	adds	r7, #28
 c0043f8:	46bd      	mov	sp, r7
 c0043fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0043fe:	4770      	bx	lr
 c004400:	30000024 	.word	0x30000024
 c004404:	5002202c 	.word	0x5002202c
 c004408:	40022028 	.word	0x40022028
 c00440c:	50022000 	.word	0x50022000

0c004410 <FLASH_PageErase>:
  *            @arg FLASH_BANK_1: Page in bank 1 to be erased
  *            @arg FLASH_BANK_2: Page in bank 2 to be erased
  * @retval None
  */
void FLASH_PageErase(uint32_t Page, uint32_t Banks)
{
 c004410:	b480      	push	{r7}
 c004412:	b087      	sub	sp, #28
 c004414:	af00      	add	r7, sp, #0
 c004416:	6078      	str	r0, [r7, #4]
 c004418:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c00441a:	f3ef 8310 	mrs	r3, PRIMASK
 c00441e:	60fb      	str	r3, [r7, #12]
  return(result);
 c004420:	68fb      	ldr	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Disable interrupts to avoid any interruption */
  primask_bit = __get_PRIMASK();
 c004422:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 c004424:	b672      	cpsid	i
}
 c004426:	bf00      	nop
  __disable_irq();
#endif

  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c004428:	4b22      	ldr	r3, [pc, #136]	@ (c0044b4 <FLASH_PageErase+0xa4>)
 c00442a:	689b      	ldr	r3, [r3, #8]
 c00442c:	2b00      	cmp	r3, #0
 c00442e:	db01      	blt.n	c004434 <FLASH_PageErase+0x24>
 c004430:	4b21      	ldr	r3, [pc, #132]	@ (c0044b8 <FLASH_PageErase+0xa8>)
 c004432:	e000      	b.n	c004436 <FLASH_PageErase+0x26>
 c004434:	4b21      	ldr	r3, [pc, #132]	@ (c0044bc <FLASH_PageErase+0xac>)
 c004436:	613b      	str	r3, [r7, #16]

  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c004438:	4b21      	ldr	r3, [pc, #132]	@ (c0044c0 <FLASH_PageErase+0xb0>)
 c00443a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 c00443c:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 c004440:	2b00      	cmp	r3, #0
 c004442:	d106      	bne.n	c004452 <FLASH_PageErase+0x42>
  {
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c004444:	693b      	ldr	r3, [r7, #16]
 c004446:	681b      	ldr	r3, [r3, #0]
 c004448:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 c00444c:	693b      	ldr	r3, [r7, #16]
 c00444e:	601a      	str	r2, [r3, #0]
 c004450:	e011      	b.n	c004476 <FLASH_PageErase+0x66>
  }
  else
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
 c004452:	683b      	ldr	r3, [r7, #0]
 c004454:	f003 0301 	and.w	r3, r3, #1
 c004458:	2b00      	cmp	r3, #0
 c00445a:	d006      	beq.n	c00446a <FLASH_PageErase+0x5a>
    {
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c00445c:	693b      	ldr	r3, [r7, #16]
 c00445e:	681b      	ldr	r3, [r3, #0]
 c004460:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 c004464:	693b      	ldr	r3, [r7, #16]
 c004466:	601a      	str	r2, [r3, #0]
 c004468:	e005      	b.n	c004476 <FLASH_PageErase+0x66>
    }
    else
    {
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c00446a:	693b      	ldr	r3, [r7, #16]
 c00446c:	681b      	ldr	r3, [r3, #0]
 c00446e:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
 c004472:	693b      	ldr	r3, [r7, #16]
 c004474:	601a      	str	r2, [r3, #0]
    }
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 c004476:	693b      	ldr	r3, [r7, #16]
 c004478:	681b      	ldr	r3, [r3, #0]
 c00447a:	f423 737e 	bic.w	r3, r3, #1016	@ 0x3f8
 c00447e:	f023 0302 	bic.w	r3, r3, #2
 c004482:	687a      	ldr	r2, [r7, #4]
 c004484:	00d2      	lsls	r2, r2, #3
 c004486:	4313      	orrs	r3, r2
 c004488:	f043 0202 	orr.w	r2, r3, #2
 c00448c:	693b      	ldr	r3, [r7, #16]
 c00448e:	601a      	str	r2, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c004490:	693b      	ldr	r3, [r7, #16]
 c004492:	681b      	ldr	r3, [r3, #0]
 c004494:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 c004498:	693b      	ldr	r3, [r7, #16]
 c00449a:	601a      	str	r2, [r3, #0]
 c00449c:	697b      	ldr	r3, [r7, #20]
 c00449e:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c0044a0:	68bb      	ldr	r3, [r7, #8]
 c0044a2:	f383 8810 	msr	PRIMASK, r3
}
 c0044a6:	bf00      	nop

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c0044a8:	bf00      	nop
 c0044aa:	371c      	adds	r7, #28
 c0044ac:	46bd      	mov	sp, r7
 c0044ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0044b2:	4770      	bx	lr
 c0044b4:	30000024 	.word	0x30000024
 c0044b8:	5002202c 	.word	0x5002202c
 c0044bc:	40022028 	.word	0x40022028
 c0044c0:	50022000 	.word	0x50022000

0c0044c4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 c0044c4:	b480      	push	{r7}
 c0044c6:	b087      	sub	sp, #28
 c0044c8:	af00      	add	r7, sp, #0
 c0044ca:	6078      	str	r0, [r7, #4]
 c0044cc:	6039      	str	r1, [r7, #0]
  uint32_t position = 0U;
 c0044ce:	2300      	movs	r3, #0
 c0044d0:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 c0044d2:	e158      	b.n	c004786 <HAL_GPIO_Init+0x2c2>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 c0044d4:	683b      	ldr	r3, [r7, #0]
 c0044d6:	681a      	ldr	r2, [r3, #0]
 c0044d8:	2101      	movs	r1, #1
 c0044da:	697b      	ldr	r3, [r7, #20]
 c0044dc:	fa01 f303 	lsl.w	r3, r1, r3
 c0044e0:	4013      	ands	r3, r2
 c0044e2:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0U)
 c0044e4:	68fb      	ldr	r3, [r7, #12]
 c0044e6:	2b00      	cmp	r3, #0
 c0044e8:	f000 814a 	beq.w	c004780 <HAL_GPIO_Init+0x2bc>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 c0044ec:	683b      	ldr	r3, [r7, #0]
 c0044ee:	685b      	ldr	r3, [r3, #4]
 c0044f0:	f003 0303 	and.w	r3, r3, #3
 c0044f4:	2b01      	cmp	r3, #1
 c0044f6:	d005      	beq.n	c004504 <HAL_GPIO_Init+0x40>
 c0044f8:	683b      	ldr	r3, [r7, #0]
 c0044fa:	685b      	ldr	r3, [r3, #4]
 c0044fc:	f003 0303 	and.w	r3, r3, #3
 c004500:	2b02      	cmp	r3, #2
 c004502:	d130      	bne.n	c004566 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 c004504:	687b      	ldr	r3, [r7, #4]
 c004506:	689b      	ldr	r3, [r3, #8]
 c004508:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00450a:	697b      	ldr	r3, [r7, #20]
 c00450c:	005b      	lsls	r3, r3, #1
 c00450e:	2203      	movs	r2, #3
 c004510:	fa02 f303 	lsl.w	r3, r2, r3
 c004514:	43db      	mvns	r3, r3
 c004516:	693a      	ldr	r2, [r7, #16]
 c004518:	4013      	ands	r3, r2
 c00451a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 c00451c:	683b      	ldr	r3, [r7, #0]
 c00451e:	68da      	ldr	r2, [r3, #12]
 c004520:	697b      	ldr	r3, [r7, #20]
 c004522:	005b      	lsls	r3, r3, #1
 c004524:	fa02 f303 	lsl.w	r3, r2, r3
 c004528:	693a      	ldr	r2, [r7, #16]
 c00452a:	4313      	orrs	r3, r2
 c00452c:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 c00452e:	687b      	ldr	r3, [r7, #4]
 c004530:	693a      	ldr	r2, [r7, #16]
 c004532:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 c004534:	687b      	ldr	r3, [r7, #4]
 c004536:	685b      	ldr	r3, [r3, #4]
 c004538:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 c00453a:	2201      	movs	r2, #1
 c00453c:	697b      	ldr	r3, [r7, #20]
 c00453e:	fa02 f303 	lsl.w	r3, r2, r3
 c004542:	43db      	mvns	r3, r3
 c004544:	693a      	ldr	r2, [r7, #16]
 c004546:	4013      	ands	r3, r2
 c004548:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 c00454a:	683b      	ldr	r3, [r7, #0]
 c00454c:	685b      	ldr	r3, [r3, #4]
 c00454e:	091b      	lsrs	r3, r3, #4
 c004550:	f003 0201 	and.w	r2, r3, #1
 c004554:	697b      	ldr	r3, [r7, #20]
 c004556:	fa02 f303 	lsl.w	r3, r2, r3
 c00455a:	693a      	ldr	r2, [r7, #16]
 c00455c:	4313      	orrs	r3, r2
 c00455e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 c004560:	687b      	ldr	r3, [r7, #4]
 c004562:	693a      	ldr	r2, [r7, #16]
 c004564:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 c004566:	683b      	ldr	r3, [r7, #0]
 c004568:	685b      	ldr	r3, [r3, #4]
 c00456a:	f003 0303 	and.w	r3, r3, #3
 c00456e:	2b03      	cmp	r3, #3
 c004570:	d017      	beq.n	c0045a2 <HAL_GPIO_Init+0xde>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        temp = GPIOx->PUPDR;
 c004572:	687b      	ldr	r3, [r7, #4]
 c004574:	68db      	ldr	r3, [r3, #12]
 c004576:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c004578:	697b      	ldr	r3, [r7, #20]
 c00457a:	005b      	lsls	r3, r3, #1
 c00457c:	2203      	movs	r2, #3
 c00457e:	fa02 f303 	lsl.w	r3, r2, r3
 c004582:	43db      	mvns	r3, r3
 c004584:	693a      	ldr	r2, [r7, #16]
 c004586:	4013      	ands	r3, r2
 c004588:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 c00458a:	683b      	ldr	r3, [r7, #0]
 c00458c:	689a      	ldr	r2, [r3, #8]
 c00458e:	697b      	ldr	r3, [r7, #20]
 c004590:	005b      	lsls	r3, r3, #1
 c004592:	fa02 f303 	lsl.w	r3, r2, r3
 c004596:	693a      	ldr	r2, [r7, #16]
 c004598:	4313      	orrs	r3, r2
 c00459a:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 c00459c:	687b      	ldr	r3, [r7, #4]
 c00459e:	693a      	ldr	r2, [r7, #16]
 c0045a0:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 c0045a2:	683b      	ldr	r3, [r7, #0]
 c0045a4:	685b      	ldr	r3, [r3, #4]
 c0045a6:	f003 0303 	and.w	r3, r3, #3
 c0045aa:	2b02      	cmp	r3, #2
 c0045ac:	d123      	bne.n	c0045f6 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 c0045ae:	697b      	ldr	r3, [r7, #20]
 c0045b0:	08da      	lsrs	r2, r3, #3
 c0045b2:	687b      	ldr	r3, [r7, #4]
 c0045b4:	3208      	adds	r2, #8
 c0045b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0045ba:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0045bc:	697b      	ldr	r3, [r7, #20]
 c0045be:	f003 0307 	and.w	r3, r3, #7
 c0045c2:	009b      	lsls	r3, r3, #2
 c0045c4:	220f      	movs	r2, #15
 c0045c6:	fa02 f303 	lsl.w	r3, r2, r3
 c0045ca:	43db      	mvns	r3, r3
 c0045cc:	693a      	ldr	r2, [r7, #16]
 c0045ce:	4013      	ands	r3, r2
 c0045d0:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 c0045d2:	683b      	ldr	r3, [r7, #0]
 c0045d4:	691a      	ldr	r2, [r3, #16]
 c0045d6:	697b      	ldr	r3, [r7, #20]
 c0045d8:	f003 0307 	and.w	r3, r3, #7
 c0045dc:	009b      	lsls	r3, r3, #2
 c0045de:	fa02 f303 	lsl.w	r3, r2, r3
 c0045e2:	693a      	ldr	r2, [r7, #16]
 c0045e4:	4313      	orrs	r3, r2
 c0045e6:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 c0045e8:	697b      	ldr	r3, [r7, #20]
 c0045ea:	08da      	lsrs	r2, r3, #3
 c0045ec:	687b      	ldr	r3, [r7, #4]
 c0045ee:	3208      	adds	r2, #8
 c0045f0:	6939      	ldr	r1, [r7, #16]
 c0045f2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 c0045f6:	687b      	ldr	r3, [r7, #4]
 c0045f8:	681b      	ldr	r3, [r3, #0]
 c0045fa:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 c0045fc:	697b      	ldr	r3, [r7, #20]
 c0045fe:	005b      	lsls	r3, r3, #1
 c004600:	2203      	movs	r2, #3
 c004602:	fa02 f303 	lsl.w	r3, r2, r3
 c004606:	43db      	mvns	r3, r3
 c004608:	693a      	ldr	r2, [r7, #16]
 c00460a:	4013      	ands	r3, r2
 c00460c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 c00460e:	683b      	ldr	r3, [r7, #0]
 c004610:	685b      	ldr	r3, [r3, #4]
 c004612:	f003 0203 	and.w	r2, r3, #3
 c004616:	697b      	ldr	r3, [r7, #20]
 c004618:	005b      	lsls	r3, r3, #1
 c00461a:	fa02 f303 	lsl.w	r3, r2, r3
 c00461e:	693a      	ldr	r2, [r7, #16]
 c004620:	4313      	orrs	r3, r2
 c004622:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 c004624:	687b      	ldr	r3, [r7, #4]
 c004626:	693a      	ldr	r2, [r7, #16]
 c004628:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 c00462a:	683b      	ldr	r3, [r7, #0]
 c00462c:	685b      	ldr	r3, [r3, #4]
 c00462e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 c004632:	2b00      	cmp	r3, #0
 c004634:	f000 80a4 	beq.w	c004780 <HAL_GPIO_Init+0x2bc>
      {
        temp = EXTI->EXTICR[position >> 2U];
 c004638:	4a5a      	ldr	r2, [pc, #360]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c00463a:	697b      	ldr	r3, [r7, #20]
 c00463c:	089b      	lsrs	r3, r3, #2
 c00463e:	3318      	adds	r3, #24
 c004640:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 c004644:	613b      	str	r3, [r7, #16]
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c004646:	697b      	ldr	r3, [r7, #20]
 c004648:	f003 0303 	and.w	r3, r3, #3
 c00464c:	00db      	lsls	r3, r3, #3
 c00464e:	220f      	movs	r2, #15
 c004650:	fa02 f303 	lsl.w	r3, r2, r3
 c004654:	43db      	mvns	r3, r3
 c004656:	693a      	ldr	r2, [r7, #16]
 c004658:	4013      	ands	r3, r2
 c00465a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c00465c:	687b      	ldr	r3, [r7, #4]
 c00465e:	4a52      	ldr	r2, [pc, #328]	@ (c0047a8 <HAL_GPIO_Init+0x2e4>)
 c004660:	4293      	cmp	r3, r2
 c004662:	d025      	beq.n	c0046b0 <HAL_GPIO_Init+0x1ec>
 c004664:	687b      	ldr	r3, [r7, #4]
 c004666:	4a51      	ldr	r2, [pc, #324]	@ (c0047ac <HAL_GPIO_Init+0x2e8>)
 c004668:	4293      	cmp	r3, r2
 c00466a:	d01f      	beq.n	c0046ac <HAL_GPIO_Init+0x1e8>
 c00466c:	687b      	ldr	r3, [r7, #4]
 c00466e:	4a50      	ldr	r2, [pc, #320]	@ (c0047b0 <HAL_GPIO_Init+0x2ec>)
 c004670:	4293      	cmp	r3, r2
 c004672:	d019      	beq.n	c0046a8 <HAL_GPIO_Init+0x1e4>
 c004674:	687b      	ldr	r3, [r7, #4]
 c004676:	4a4f      	ldr	r2, [pc, #316]	@ (c0047b4 <HAL_GPIO_Init+0x2f0>)
 c004678:	4293      	cmp	r3, r2
 c00467a:	d013      	beq.n	c0046a4 <HAL_GPIO_Init+0x1e0>
 c00467c:	687b      	ldr	r3, [r7, #4]
 c00467e:	4a4e      	ldr	r2, [pc, #312]	@ (c0047b8 <HAL_GPIO_Init+0x2f4>)
 c004680:	4293      	cmp	r3, r2
 c004682:	d00d      	beq.n	c0046a0 <HAL_GPIO_Init+0x1dc>
 c004684:	687b      	ldr	r3, [r7, #4]
 c004686:	4a4d      	ldr	r2, [pc, #308]	@ (c0047bc <HAL_GPIO_Init+0x2f8>)
 c004688:	4293      	cmp	r3, r2
 c00468a:	d007      	beq.n	c00469c <HAL_GPIO_Init+0x1d8>
 c00468c:	687b      	ldr	r3, [r7, #4]
 c00468e:	4a4c      	ldr	r2, [pc, #304]	@ (c0047c0 <HAL_GPIO_Init+0x2fc>)
 c004690:	4293      	cmp	r3, r2
 c004692:	d101      	bne.n	c004698 <HAL_GPIO_Init+0x1d4>
 c004694:	2306      	movs	r3, #6
 c004696:	e00c      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c004698:	2307      	movs	r3, #7
 c00469a:	e00a      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c00469c:	2305      	movs	r3, #5
 c00469e:	e008      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c0046a0:	2304      	movs	r3, #4
 c0046a2:	e006      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c0046a4:	2303      	movs	r3, #3
 c0046a6:	e004      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c0046a8:	2302      	movs	r3, #2
 c0046aa:	e002      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c0046ac:	2301      	movs	r3, #1
 c0046ae:	e000      	b.n	c0046b2 <HAL_GPIO_Init+0x1ee>
 c0046b0:	2300      	movs	r3, #0
 c0046b2:	697a      	ldr	r2, [r7, #20]
 c0046b4:	f002 0203 	and.w	r2, r2, #3
 c0046b8:	00d2      	lsls	r2, r2, #3
 c0046ba:	4093      	lsls	r3, r2
 c0046bc:	693a      	ldr	r2, [r7, #16]
 c0046be:	4313      	orrs	r3, r2
 c0046c0:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2U] = temp;
 c0046c2:	4938      	ldr	r1, [pc, #224]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c0046c4:	697b      	ldr	r3, [r7, #20]
 c0046c6:	089b      	lsrs	r3, r3, #2
 c0046c8:	3318      	adds	r3, #24
 c0046ca:	693a      	ldr	r2, [r7, #16]
 c0046cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 c0046d0:	4b34      	ldr	r3, [pc, #208]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c0046d2:	681b      	ldr	r3, [r3, #0]
 c0046d4:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c0046d6:	68fb      	ldr	r3, [r7, #12]
 c0046d8:	43db      	mvns	r3, r3
 c0046da:	693a      	ldr	r2, [r7, #16]
 c0046dc:	4013      	ands	r3, r2
 c0046de:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 c0046e0:	683b      	ldr	r3, [r7, #0]
 c0046e2:	685b      	ldr	r3, [r3, #4]
 c0046e4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 c0046e8:	2b00      	cmp	r3, #0
 c0046ea:	d003      	beq.n	c0046f4 <HAL_GPIO_Init+0x230>
        {
          temp |= iocurrent;
 c0046ec:	693a      	ldr	r2, [r7, #16]
 c0046ee:	68fb      	ldr	r3, [r7, #12]
 c0046f0:	4313      	orrs	r3, r2
 c0046f2:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 c0046f4:	4a2b      	ldr	r2, [pc, #172]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c0046f6:	693b      	ldr	r3, [r7, #16]
 c0046f8:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 c0046fa:	4b2a      	ldr	r3, [pc, #168]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c0046fc:	685b      	ldr	r3, [r3, #4]
 c0046fe:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c004700:	68fb      	ldr	r3, [r7, #12]
 c004702:	43db      	mvns	r3, r3
 c004704:	693a      	ldr	r2, [r7, #16]
 c004706:	4013      	ands	r3, r2
 c004708:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 c00470a:	683b      	ldr	r3, [r7, #0]
 c00470c:	685b      	ldr	r3, [r3, #4]
 c00470e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 c004712:	2b00      	cmp	r3, #0
 c004714:	d003      	beq.n	c00471e <HAL_GPIO_Init+0x25a>
        {
          temp |= iocurrent;
 c004716:	693a      	ldr	r2, [r7, #16]
 c004718:	68fb      	ldr	r3, [r7, #12]
 c00471a:	4313      	orrs	r3, r2
 c00471c:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 c00471e:	4a21      	ldr	r2, [pc, #132]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c004720:	693b      	ldr	r3, [r7, #16]
 c004722:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->EMR1;
 c004724:	4b1f      	ldr	r3, [pc, #124]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c004726:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 c00472a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c00472c:	68fb      	ldr	r3, [r7, #12]
 c00472e:	43db      	mvns	r3, r3
 c004730:	693a      	ldr	r2, [r7, #16]
 c004732:	4013      	ands	r3, r2
 c004734:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 c004736:	683b      	ldr	r3, [r7, #0]
 c004738:	685b      	ldr	r3, [r3, #4]
 c00473a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 c00473e:	2b00      	cmp	r3, #0
 c004740:	d003      	beq.n	c00474a <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 c004742:	693a      	ldr	r2, [r7, #16]
 c004744:	68fb      	ldr	r3, [r7, #12]
 c004746:	4313      	orrs	r3, r2
 c004748:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 c00474a:	4a16      	ldr	r2, [pc, #88]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c00474c:	693b      	ldr	r3, [r7, #16]
 c00474e:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        temp = EXTI->IMR1;
 c004752:	4b14      	ldr	r3, [pc, #80]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c004754:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 c004758:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 c00475a:	68fb      	ldr	r3, [r7, #12]
 c00475c:	43db      	mvns	r3, r3
 c00475e:	693a      	ldr	r2, [r7, #16]
 c004760:	4013      	ands	r3, r2
 c004762:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 c004764:	683b      	ldr	r3, [r7, #0]
 c004766:	685b      	ldr	r3, [r3, #4]
 c004768:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c00476c:	2b00      	cmp	r3, #0
 c00476e:	d003      	beq.n	c004778 <HAL_GPIO_Init+0x2b4>
        {
          temp |= iocurrent;
 c004770:	693a      	ldr	r2, [r7, #16]
 c004772:	68fb      	ldr	r3, [r7, #12]
 c004774:	4313      	orrs	r3, r2
 c004776:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 c004778:	4a0a      	ldr	r2, [pc, #40]	@ (c0047a4 <HAL_GPIO_Init+0x2e0>)
 c00477a:	693b      	ldr	r3, [r7, #16]
 c00477c:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
 c004780:	697b      	ldr	r3, [r7, #20]
 c004782:	3301      	adds	r3, #1
 c004784:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0U)
 c004786:	683b      	ldr	r3, [r7, #0]
 c004788:	681a      	ldr	r2, [r3, #0]
 c00478a:	697b      	ldr	r3, [r7, #20]
 c00478c:	fa22 f303 	lsr.w	r3, r2, r3
 c004790:	2b00      	cmp	r3, #0
 c004792:	f47f ae9f 	bne.w	c0044d4 <HAL_GPIO_Init+0x10>
  }
}
 c004796:	bf00      	nop
 c004798:	bf00      	nop
 c00479a:	371c      	adds	r7, #28
 c00479c:	46bd      	mov	sp, r7
 c00479e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0047a2:	4770      	bx	lr
 c0047a4:	5002f400 	.word	0x5002f400
 c0047a8:	52020000 	.word	0x52020000
 c0047ac:	52020400 	.word	0x52020400
 c0047b0:	52020800 	.word	0x52020800
 c0047b4:	52020c00 	.word	0x52020c00
 c0047b8:	52021000 	.word	0x52021000
 c0047bc:	52021400 	.word	0x52021400
 c0047c0:	52021800 	.word	0x52021800

0c0047c4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 c0047c4:	b480      	push	{r7}
 c0047c6:	b083      	sub	sp, #12
 c0047c8:	af00      	add	r7, sp, #0
 c0047ca:	6078      	str	r0, [r7, #4]
 c0047cc:	460b      	mov	r3, r1
 c0047ce:	807b      	strh	r3, [r7, #2]
 c0047d0:	4613      	mov	r3, r2
 c0047d2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 c0047d4:	787b      	ldrb	r3, [r7, #1]
 c0047d6:	2b00      	cmp	r3, #0
 c0047d8:	d003      	beq.n	c0047e2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 c0047da:	887a      	ldrh	r2, [r7, #2]
 c0047dc:	687b      	ldr	r3, [r7, #4]
 c0047de:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 c0047e0:	e002      	b.n	c0047e8 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 c0047e2:	887a      	ldrh	r2, [r7, #2]
 c0047e4:	687b      	ldr	r3, [r7, #4]
 c0047e6:	629a      	str	r2, [r3, #40]	@ 0x28
}
 c0047e8:	bf00      	nop
 c0047ea:	370c      	adds	r7, #12
 c0047ec:	46bd      	mov	sp, r7
 c0047ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0047f2:	4770      	bx	lr

0c0047f4 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 c0047f4:	b480      	push	{r7}
 c0047f6:	b085      	sub	sp, #20
 c0047f8:	af00      	add	r7, sp, #0
 c0047fa:	6078      	str	r0, [r7, #4]
 c0047fc:	460b      	mov	r3, r1
 c0047fe:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 c004800:	687b      	ldr	r3, [r7, #4]
 c004802:	695b      	ldr	r3, [r3, #20]
 c004804:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 c004806:	887a      	ldrh	r2, [r7, #2]
 c004808:	68fb      	ldr	r3, [r7, #12]
 c00480a:	4013      	ands	r3, r2
 c00480c:	041a      	lsls	r2, r3, #16
 c00480e:	68fb      	ldr	r3, [r7, #12]
 c004810:	43d9      	mvns	r1, r3
 c004812:	887b      	ldrh	r3, [r7, #2]
 c004814:	400b      	ands	r3, r1
 c004816:	431a      	orrs	r2, r3
 c004818:	687b      	ldr	r3, [r7, #4]
 c00481a:	619a      	str	r2, [r3, #24]
}
 c00481c:	bf00      	nop
 c00481e:	3714      	adds	r7, #20
 c004820:	46bd      	mov	sp, r7
 c004822:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004826:	4770      	bx	lr

0c004828 <HAL_GPIO_ConfigPinAttributes>:
  * @param  GPIO_Pin specifies the pin(s) to configure the secure attribute
  * @param  PinAttributes specifies the pin(s) to be set in secure mode, other being set non secured.
  * @retval None
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
 c004828:	b480      	push	{r7}
 c00482a:	b087      	sub	sp, #28
 c00482c:	af00      	add	r7, sp, #0
 c00482e:	60f8      	str	r0, [r7, #12]
 c004830:	460b      	mov	r3, r1
 c004832:	607a      	str	r2, [r7, #4]
 c004834:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

  /* Configure the port pins */
  temp = GPIOx->SECCFGR;
 c004836:	68fb      	ldr	r3, [r7, #12]
 c004838:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 c00483a:	617b      	str	r3, [r7, #20]
  if (PinAttributes != GPIO_PIN_NSEC)
 c00483c:	687b      	ldr	r3, [r7, #4]
 c00483e:	2b00      	cmp	r3, #0
 c004840:	d004      	beq.n	c00484c <HAL_GPIO_ConfigPinAttributes+0x24>
  {
    temp |= (uint32_t)GPIO_Pin;
 c004842:	897b      	ldrh	r3, [r7, #10]
 c004844:	697a      	ldr	r2, [r7, #20]
 c004846:	4313      	orrs	r3, r2
 c004848:	617b      	str	r3, [r7, #20]
 c00484a:	e004      	b.n	c004856 <HAL_GPIO_ConfigPinAttributes+0x2e>
  }
  else
  {
    temp &= ~((uint32_t)GPIO_Pin);
 c00484c:	897b      	ldrh	r3, [r7, #10]
 c00484e:	43db      	mvns	r3, r3
 c004850:	697a      	ldr	r2, [r7, #20]
 c004852:	4013      	ands	r3, r2
 c004854:	617b      	str	r3, [r7, #20]
  }

  /* Set secure attributes */
  GPIOx->SECCFGR = temp;
 c004856:	68fb      	ldr	r3, [r7, #12]
 c004858:	697a      	ldr	r2, [r7, #20]
 c00485a:	631a      	str	r2, [r3, #48]	@ 0x30
}
 c00485c:	bf00      	nop
 c00485e:	371c      	adds	r7, #28
 c004860:	46bd      	mov	sp, r7
 c004862:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004866:	4770      	bx	lr

0c004868 <HAL_GTZC_MPCBB_ConfigMem>:
  *         The structure description is available in @ref GTZC_Exported_Types.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_GTZC_MPCBB_ConfigMem(uint32_t MemBaseAddress,
                                           const MPCBB_ConfigTypeDef *pMPCBB_desc)
{
 c004868:	b480      	push	{r7}
 c00486a:	b089      	sub	sp, #36	@ 0x24
 c00486c:	af00      	add	r7, sp, #0
 c00486e:	6078      	str	r0, [r7, #4]
 c004870:	6039      	str	r1, [r7, #0]
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c004872:	687b      	ldr	r3, [r7, #4]
 c004874:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 c004878:	d00b      	beq.n	c004892 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
 c00487a:	687b      	ldr	r3, [r7, #4]
 c00487c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 c004880:	d007      	beq.n	c004892 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c004882:	687b      	ldr	r3, [r7, #4]
 c004884:	4a36      	ldr	r2, [pc, #216]	@ (c004960 <HAL_GTZC_MPCBB_ConfigMem+0xf8>)
 c004886:	4293      	cmp	r3, r2
 c004888:	d003      	beq.n	c004892 <HAL_GTZC_MPCBB_ConfigMem+0x2a>
 c00488a:	687b      	ldr	r3, [r7, #4]
 c00488c:	4a35      	ldr	r2, [pc, #212]	@ (c004964 <HAL_GTZC_MPCBB_ConfigMem+0xfc>)
 c00488e:	4293      	cmp	r3, r2
 c004890:	d111      	bne.n	c0048b6 <HAL_GTZC_MPCBB_ConfigMem+0x4e>
      || ((pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_ENABLE)
 c004892:	683b      	ldr	r3, [r7, #0]
 c004894:	681b      	ldr	r3, [r3, #0]
 c004896:	2b00      	cmp	r3, #0
 c004898:	d004      	beq.n	c0048a4 <HAL_GTZC_MPCBB_ConfigMem+0x3c>
          && (pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_DISABLE))
 c00489a:	683b      	ldr	r3, [r7, #0]
 c00489c:	681b      	ldr	r3, [r3, #0]
 c00489e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 c0048a2:	d108      	bne.n	c0048b6 <HAL_GTZC_MPCBB_ConfigMem+0x4e>
      || ((pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_NOT_INVERTED)
 c0048a4:	683b      	ldr	r3, [r7, #0]
 c0048a6:	685b      	ldr	r3, [r3, #4]
 c0048a8:	2b00      	cmp	r3, #0
 c0048aa:	d006      	beq.n	c0048ba <HAL_GTZC_MPCBB_ConfigMem+0x52>
          && (pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_INVERTED)))
 c0048ac:	683b      	ldr	r3, [r7, #0]
 c0048ae:	685b      	ldr	r3, [r3, #4]
 c0048b0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 c0048b4:	d001      	beq.n	c0048ba <HAL_GTZC_MPCBB_ConfigMem+0x52>
  {
    return HAL_ERROR;
 c0048b6:	2301      	movs	r3, #1
 c0048b8:	e04b      	b.n	c004952 <HAL_GTZC_MPCBB_ConfigMem+0xea>
  }

  /* write InvertSecureState and SecureRWIllegalMode properties */
  /* assume their Position/Mask is identical for all sub-blocks */
  reg_value = pMPCBB_desc->InvertSecureState;
 c0048ba:	683b      	ldr	r3, [r7, #0]
 c0048bc:	685b      	ldr	r3, [r3, #4]
 c0048be:	613b      	str	r3, [r7, #16]
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
 c0048c0:	683b      	ldr	r3, [r7, #0]
 c0048c2:	681b      	ldr	r3, [r3, #0]
 c0048c4:	693a      	ldr	r2, [r7, #16]
 c0048c6:	4313      	orrs	r3, r2
 c0048c8:	613b      	str	r3, [r7, #16]
  if (IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c0048ca:	687b      	ldr	r3, [r7, #4]
 c0048cc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 c0048d0:	d003      	beq.n	c0048da <HAL_GTZC_MPCBB_ConfigMem+0x72>
 c0048d2:	687b      	ldr	r3, [r7, #4]
 c0048d4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 c0048d8:	d105      	bne.n	c0048e6 <HAL_GTZC_MPCBB_ConfigMem+0x7e>
  {
    mpcbb_ptr = GTZC_MPCBB1_S;
 c0048da:	4b23      	ldr	r3, [pc, #140]	@ (c004968 <HAL_GTZC_MPCBB_ConfigMem+0x100>)
 c0048dc:	61fb      	str	r3, [r7, #28]
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c0048de:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
 c0048e2:	61bb      	str	r3, [r7, #24]
 c0048e4:	e004      	b.n	c0048f0 <HAL_GTZC_MPCBB_ConfigMem+0x88>
  }
  else
  {
    /* Here MemBaseAddress is inside SRAM2 (already tested) */
    mpcbb_ptr = GTZC_MPCBB2_S;
 c0048e6:	4b21      	ldr	r3, [pc, #132]	@ (c00496c <HAL_GTZC_MPCBB_ConfigMem+0x104>)
 c0048e8:	61fb      	str	r3, [r7, #28]
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c0048ea:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 c0048ee:	61bb      	str	r3, [r7, #24]
  }

  /* write vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
 c0048f0:	69bb      	ldr	r3, [r7, #24]
 c0048f2:	0b5b      	lsrs	r3, r3, #13
 c0048f4:	60fb      	str	r3, [r7, #12]
  for (i = 0U; i < size_in_superblocks; i++)
 c0048f6:	2300      	movs	r3, #0
 c0048f8:	617b      	str	r3, [r7, #20]
 c0048fa:	e00c      	b.n	c004916 <HAL_GTZC_MPCBB_ConfigMem+0xae>
  {
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c0048fc:	683b      	ldr	r3, [r7, #0]
 c0048fe:	697a      	ldr	r2, [r7, #20]
 c004900:	3202      	adds	r2, #2
 c004902:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c004906:	69fb      	ldr	r3, [r7, #28]
 c004908:	697a      	ldr	r2, [r7, #20]
 c00490a:	3240      	adds	r2, #64	@ 0x40
 c00490c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c004910:	697b      	ldr	r3, [r7, #20]
 c004912:	3301      	adds	r3, #1
 c004914:	617b      	str	r3, [r7, #20]
 c004916:	697a      	ldr	r2, [r7, #20]
 c004918:	68fb      	ldr	r3, [r7, #12]
 c00491a:	429a      	cmp	r2, r3
 c00491c:	d3ee      	bcc.n	c0048fc <HAL_GTZC_MPCBB_ConfigMem+0x94>
              pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i]);
  }

  /* write configuration and lock register information */
  MODIFY_REG(mpcbb_ptr->CR,
 c00491e:	69fb      	ldr	r3, [r7, #28]
 c004920:	681b      	ldr	r3, [r3, #0]
 c004922:	f023 4240 	bic.w	r2, r3, #3221225472	@ 0xc0000000
 c004926:	693b      	ldr	r3, [r7, #16]
 c004928:	431a      	orrs	r2, r3
 c00492a:	69fb      	ldr	r3, [r7, #28]
 c00492c:	601a      	str	r2, [r3, #0]
             GTZC_MPCBB_CR_INVSECSTATE_Msk | GTZC_MPCBB_CR_SRWILADIS_Msk, reg_value);

  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c00492e:	69bb      	ldr	r3, [r7, #24]
 c004930:	0b5b      	lsrs	r3, r3, #13
 c004932:	2201      	movs	r2, #1
 c004934:	fa02 f303 	lsl.w	r3, r2, r3
 c004938:	3b01      	subs	r3, #1
 c00493a:	60bb      	str	r3, [r7, #8]
  /* limitation: code not portable with memory > 256K */
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c00493c:	69fb      	ldr	r3, [r7, #28]
 c00493e:	691a      	ldr	r2, [r3, #16]
 c004940:	68bb      	ldr	r3, [r7, #8]
 c004942:	43db      	mvns	r3, r3
 c004944:	401a      	ands	r2, r3
 c004946:	683b      	ldr	r3, [r7, #0]
 c004948:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 c00494a:	431a      	orrs	r2, r3
 c00494c:	69fb      	ldr	r3, [r7, #28]
 c00494e:	611a      	str	r2, [r3, #16]

  return HAL_OK;
 c004950:	2300      	movs	r3, #0
}
 c004952:	4618      	mov	r0, r3
 c004954:	3724      	adds	r7, #36	@ 0x24
 c004956:	46bd      	mov	sp, r7
 c004958:	f85d 7b04 	ldr.w	r7, [sp], #4
 c00495c:	4770      	bx	lr
 c00495e:	bf00      	nop
 c004960:	20030000 	.word	0x20030000
 c004964:	30030000 	.word	0x30030000
 c004968:	50032c00 	.word	0x50032c00
 c00496c:	50033000 	.word	0x50033000

0c004970 <HAL_GTZC_IRQHandler>:
/**
  * @brief  This function handles GTZC interrupt request.
  * @retval None.
  */
void HAL_GTZC_IRQHandler(void)
{
 c004970:	b580      	push	{r7, lr}
 c004972:	b084      	sub	sp, #16
 c004974:	af00      	add	r7, sp, #0
  uint32_t flag;
  uint32_t ier_itsources;
  uint32_t sr_flags;

  /* Get current IT Flags and IT sources value on 1st register */
  ier_itsources = READ_REG(GTZC_TZIC->IER1);
 c004976:	4b3f      	ldr	r3, [pc, #252]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c004978:	681b      	ldr	r3, [r3, #0]
 c00497a:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR1);
 c00497c:	4b3d      	ldr	r3, [pc, #244]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c00497e:	691b      	ldr	r3, [r3, #16]
 c004980:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c004982:	68ba      	ldr	r2, [r7, #8]
 c004984:	687b      	ldr	r3, [r7, #4]
 c004986:	4013      	ands	r3, r2
 c004988:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c00498a:	683b      	ldr	r3, [r7, #0]
 c00498c:	2b00      	cmp	r3, #0
 c00498e:	d019      	beq.n	c0049c4 <HAL_GTZC_IRQHandler+0x54>
  {
    WRITE_REG(GTZC_TZIC->FCR1, flag);
 c004990:	4a38      	ldr	r2, [pc, #224]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c004992:	683b      	ldr	r3, [r7, #0]
 c004994:	6213      	str	r3, [r2, #32]

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c004996:	2300      	movs	r3, #0
 c004998:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c00499a:	e00d      	b.n	c0049b8 <HAL_GTZC_IRQHandler+0x48>
    {
      if ((flag & (1UL << position)) != 0U)
 c00499c:	683a      	ldr	r2, [r7, #0]
 c00499e:	68fb      	ldr	r3, [r7, #12]
 c0049a0:	fa22 f303 	lsr.w	r3, r2, r3
 c0049a4:	f003 0301 	and.w	r3, r3, #1
 c0049a8:	2b00      	cmp	r3, #0
 c0049aa:	d002      	beq.n	c0049b2 <HAL_GTZC_IRQHandler+0x42>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG1 | position);
 c0049ac:	68f8      	ldr	r0, [r7, #12]
 c0049ae:	f000 f863 	bl	c004a78 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c0049b2:	68fb      	ldr	r3, [r7, #12]
 c0049b4:	3301      	adds	r3, #1
 c0049b6:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c0049b8:	683a      	ldr	r2, [r7, #0]
 c0049ba:	68fb      	ldr	r3, [r7, #12]
 c0049bc:	fa22 f303 	lsr.w	r3, r2, r3
 c0049c0:	2b00      	cmp	r3, #0
 c0049c2:	d1eb      	bne.n	c00499c <HAL_GTZC_IRQHandler+0x2c>
    }
  }

  /* Get current IT Flags and IT sources value on 2nd register */
  ier_itsources = READ_REG(GTZC_TZIC->IER2);
 c0049c4:	4b2b      	ldr	r3, [pc, #172]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c0049c6:	685b      	ldr	r3, [r3, #4]
 c0049c8:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR2);
 c0049ca:	4b2a      	ldr	r3, [pc, #168]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c0049cc:	695b      	ldr	r3, [r3, #20]
 c0049ce:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c0049d0:	68ba      	ldr	r2, [r7, #8]
 c0049d2:	687b      	ldr	r3, [r7, #4]
 c0049d4:	4013      	ands	r3, r2
 c0049d6:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c0049d8:	683b      	ldr	r3, [r7, #0]
 c0049da:	2b00      	cmp	r3, #0
 c0049dc:	d01c      	beq.n	c004a18 <HAL_GTZC_IRQHandler+0xa8>
  {
    WRITE_REG(GTZC_TZIC->FCR2, flag);
 c0049de:	4a25      	ldr	r2, [pc, #148]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c0049e0:	683b      	ldr	r3, [r7, #0]
 c0049e2:	6253      	str	r3, [r2, #36]	@ 0x24

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c0049e4:	2300      	movs	r3, #0
 c0049e6:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c0049e8:	e010      	b.n	c004a0c <HAL_GTZC_IRQHandler+0x9c>
    {
      if ((flag & (1UL << position)) != 0U)
 c0049ea:	683a      	ldr	r2, [r7, #0]
 c0049ec:	68fb      	ldr	r3, [r7, #12]
 c0049ee:	fa22 f303 	lsr.w	r3, r2, r3
 c0049f2:	f003 0301 	and.w	r3, r3, #1
 c0049f6:	2b00      	cmp	r3, #0
 c0049f8:	d005      	beq.n	c004a06 <HAL_GTZC_IRQHandler+0x96>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG2 | position);
 c0049fa:	68fb      	ldr	r3, [r7, #12]
 c0049fc:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 c004a00:	4618      	mov	r0, r3
 c004a02:	f000 f839 	bl	c004a78 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c004a06:	68fb      	ldr	r3, [r7, #12]
 c004a08:	3301      	adds	r3, #1
 c004a0a:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a0c:	683a      	ldr	r2, [r7, #0]
 c004a0e:	68fb      	ldr	r3, [r7, #12]
 c004a10:	fa22 f303 	lsr.w	r3, r2, r3
 c004a14:	2b00      	cmp	r3, #0
 c004a16:	d1e8      	bne.n	c0049ea <HAL_GTZC_IRQHandler+0x7a>
    }
  }

  /* Get current IT Flags and IT sources value on 3rd register */
  ier_itsources = READ_REG(GTZC_TZIC->IER3);
 c004a18:	4b16      	ldr	r3, [pc, #88]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c004a1a:	689b      	ldr	r3, [r3, #8]
 c004a1c:	60bb      	str	r3, [r7, #8]
  sr_flags      = READ_REG(GTZC_TZIC->SR3);
 c004a1e:	4b15      	ldr	r3, [pc, #84]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c004a20:	699b      	ldr	r3, [r3, #24]
 c004a22:	607b      	str	r3, [r7, #4]

  /* Get Mask interrupt and then clear them */
  flag = ier_itsources & sr_flags;
 c004a24:	68ba      	ldr	r2, [r7, #8]
 c004a26:	687b      	ldr	r3, [r7, #4]
 c004a28:	4013      	ands	r3, r2
 c004a2a:	603b      	str	r3, [r7, #0]
  if (flag != 0U)
 c004a2c:	683b      	ldr	r3, [r7, #0]
 c004a2e:	2b00      	cmp	r3, #0
 c004a30:	d01c      	beq.n	c004a6c <HAL_GTZC_IRQHandler+0xfc>
  {
    WRITE_REG(GTZC_TZIC->FCR3, flag);
 c004a32:	4a10      	ldr	r2, [pc, #64]	@ (c004a74 <HAL_GTZC_IRQHandler+0x104>)
 c004a34:	683b      	ldr	r3, [r7, #0]
 c004a36:	6293      	str	r3, [r2, #40]	@ 0x28

    /* Loop on flag to check, which ones have been raised */
    position = 0U;
 c004a38:	2300      	movs	r3, #0
 c004a3a:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a3c:	e010      	b.n	c004a60 <HAL_GTZC_IRQHandler+0xf0>
    {
      if ((flag & (1UL << position)) != 0U)
 c004a3e:	683a      	ldr	r2, [r7, #0]
 c004a40:	68fb      	ldr	r3, [r7, #12]
 c004a42:	fa22 f303 	lsr.w	r3, r2, r3
 c004a46:	f003 0301 	and.w	r3, r3, #1
 c004a4a:	2b00      	cmp	r3, #0
 c004a4c:	d005      	beq.n	c004a5a <HAL_GTZC_IRQHandler+0xea>
      {
        HAL_GTZC_TZIC_Callback(GTZC_PERIPH_REG3 | position);
 c004a4e:	68fb      	ldr	r3, [r7, #12]
 c004a50:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 c004a54:	4618      	mov	r0, r3
 c004a56:	f000 f80f 	bl	c004a78 <HAL_GTZC_TZIC_Callback>
      }

      /* Position bit to be updated */
      position++;
 c004a5a:	68fb      	ldr	r3, [r7, #12]
 c004a5c:	3301      	adds	r3, #1
 c004a5e:	60fb      	str	r3, [r7, #12]
    while ((flag >> position) != 0U)
 c004a60:	683a      	ldr	r2, [r7, #0]
 c004a62:	68fb      	ldr	r3, [r7, #12]
 c004a64:	fa22 f303 	lsr.w	r3, r2, r3
 c004a68:	2b00      	cmp	r3, #0
 c004a6a:	d1e8      	bne.n	c004a3e <HAL_GTZC_IRQHandler+0xce>
    }
  }
}
 c004a6c:	bf00      	nop
 c004a6e:	3710      	adds	r7, #16
 c004a70:	46bd      	mov	sp, r7
 c004a72:	bd80      	pop	{r7, pc}
 c004a74:	50032800 	.word	0x50032800

0c004a78 <HAL_GTZC_TZIC_Callback>:
  * @param  PeriphId Peripheral identifier triggering the illegal access.
  *         This parameter can be a value of @ref GTZC_TZSC_TZIC_PeriphId
  * @retval None.
  */
__weak void HAL_GTZC_TZIC_Callback(uint32_t PeriphId)
{
 c004a78:	b480      	push	{r7}
 c004a7a:	b083      	sub	sp, #12
 c004a7c:	af00      	add	r7, sp, #0
 c004a7e:	6078      	str	r0, [r7, #4]
  UNUSED(PeriphId);

  /* NOTE: This function should not be modified. When the callback is needed,
   * the HAL_GTZC_TZIC_Callback is to be implemented in the user file
   */
}
 c004a80:	bf00      	nop
 c004a82:	370c      	adds	r7, #12
 c004a84:	46bd      	mov	sp, r7
 c004a86:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004a8a:	4770      	bx	lr

0c004a8c <HAL_ICACHE_ConfigAssociativityMode>:
  *            @arg ICACHE_1WAY   1-way cache (direct mapped cache)
  *            @arg ICACHE_2WAYS  2-ways set associative cache (default)
  * @retval HAL status (HAL_OK/HAL_ERROR)
  */
HAL_StatusTypeDef HAL_ICACHE_ConfigAssociativityMode(uint32_t AssociativityMode)
{
 c004a8c:	b480      	push	{r7}
 c004a8e:	b085      	sub	sp, #20
 c004a90:	af00      	add	r7, sp, #0
 c004a92:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 c004a94:	2300      	movs	r3, #0
 c004a96:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_ICACHE_ASSOCIATIVITY_MODE(AssociativityMode));

  /* Check cache is not enabled */
  if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004a98:	4b0b      	ldr	r3, [pc, #44]	@ (c004ac8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004a9a:	681b      	ldr	r3, [r3, #0]
 c004a9c:	f003 0301 	and.w	r3, r3, #1
 c004aa0:	2b00      	cmp	r3, #0
 c004aa2:	d002      	beq.n	c004aaa <HAL_ICACHE_ConfigAssociativityMode+0x1e>
  {
    status = HAL_ERROR;
 c004aa4:	2301      	movs	r3, #1
 c004aa6:	73fb      	strb	r3, [r7, #15]
 c004aa8:	e007      	b.n	c004aba <HAL_ICACHE_ConfigAssociativityMode+0x2e>
  }
  else
  {
    MODIFY_REG(ICACHE->CR, ICACHE_CR_WAYSEL, AssociativityMode);
 c004aaa:	4b07      	ldr	r3, [pc, #28]	@ (c004ac8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004aac:	681b      	ldr	r3, [r3, #0]
 c004aae:	f023 0204 	bic.w	r2, r3, #4
 c004ab2:	4905      	ldr	r1, [pc, #20]	@ (c004ac8 <HAL_ICACHE_ConfigAssociativityMode+0x3c>)
 c004ab4:	687b      	ldr	r3, [r7, #4]
 c004ab6:	4313      	orrs	r3, r2
 c004ab8:	600b      	str	r3, [r1, #0]
  }

  return status;
 c004aba:	7bfb      	ldrb	r3, [r7, #15]
}
 c004abc:	4618      	mov	r0, r3
 c004abe:	3714      	adds	r7, #20
 c004ac0:	46bd      	mov	sp, r7
 c004ac2:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004ac6:	4770      	bx	lr
 c004ac8:	50030400 	.word	0x50030400

0c004acc <HAL_ICACHE_Enable>:
  *         cache operation. The Instruction Cache is bypassed until the
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
 c004acc:	b480      	push	{r7}
 c004ace:	af00      	add	r7, sp, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c004ad0:	4b05      	ldr	r3, [pc, #20]	@ (c004ae8 <HAL_ICACHE_Enable+0x1c>)
 c004ad2:	681b      	ldr	r3, [r3, #0]
 c004ad4:	4a04      	ldr	r2, [pc, #16]	@ (c004ae8 <HAL_ICACHE_Enable+0x1c>)
 c004ad6:	f043 0301 	orr.w	r3, r3, #1
 c004ada:	6013      	str	r3, [r2, #0]

  return HAL_OK;
 c004adc:	2300      	movs	r3, #0
}
 c004ade:	4618      	mov	r0, r3
 c004ae0:	46bd      	mov	sp, r7
 c004ae2:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004ae6:	4770      	bx	lr
 c004ae8:	50030400 	.word	0x50030400

0c004aec <HAL_ICACHE_Disable>:
  * @note   This function waits for the cache being disabled but
  *         not for the end of the automatic cache invalidation procedure.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_Disable(void)
{
 c004aec:	b580      	push	{r7, lr}
 c004aee:	b082      	sub	sp, #8
 c004af0:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c004af2:	2300      	movs	r3, #0
 c004af4:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart;

  /* Make sure BSYENDF is reset before to disable the instruction cache */
  /* as it automatically starts a cache invalidation procedure */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c004af6:	4b14      	ldr	r3, [pc, #80]	@ (c004b48 <HAL_ICACHE_Disable+0x5c>)
 c004af8:	2202      	movs	r2, #2
 c004afa:	60da      	str	r2, [r3, #12]

  CLEAR_BIT(ICACHE->CR, ICACHE_CR_EN);
 c004afc:	4b12      	ldr	r3, [pc, #72]	@ (c004b48 <HAL_ICACHE_Disable+0x5c>)
 c004afe:	681b      	ldr	r3, [r3, #0]
 c004b00:	4a11      	ldr	r2, [pc, #68]	@ (c004b48 <HAL_ICACHE_Disable+0x5c>)
 c004b02:	f023 0301 	bic.w	r3, r3, #1
 c004b06:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 c004b08:	f7ff f8c0 	bl	c003c8c <HAL_GetTick>
 c004b0c:	6038      	str	r0, [r7, #0]

  /* Wait for instruction cache being disabled */
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b0e:	e00f      	b.n	c004b30 <HAL_ICACHE_Disable+0x44>
  {
    if ((HAL_GetTick() - tickstart) > ICACHE_DISABLE_TIMEOUT_VALUE)
 c004b10:	f7ff f8bc 	bl	c003c8c <HAL_GetTick>
 c004b14:	4602      	mov	r2, r0
 c004b16:	683b      	ldr	r3, [r7, #0]
 c004b18:	1ad3      	subs	r3, r2, r3
 c004b1a:	2b01      	cmp	r3, #1
 c004b1c:	d908      	bls.n	c004b30 <HAL_ICACHE_Disable+0x44>
    {
      /* New check to avoid false timeout detection in case of preemption */
      if (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b1e:	4b0a      	ldr	r3, [pc, #40]	@ (c004b48 <HAL_ICACHE_Disable+0x5c>)
 c004b20:	681b      	ldr	r3, [r3, #0]
 c004b22:	f003 0301 	and.w	r3, r3, #1
 c004b26:	2b00      	cmp	r3, #0
 c004b28:	d002      	beq.n	c004b30 <HAL_ICACHE_Disable+0x44>
      {
        status = HAL_TIMEOUT;
 c004b2a:	2303      	movs	r3, #3
 c004b2c:	71fb      	strb	r3, [r7, #7]
        break;
 c004b2e:	e005      	b.n	c004b3c <HAL_ICACHE_Disable+0x50>
  while (READ_BIT(ICACHE->CR, ICACHE_CR_EN) != 0U)
 c004b30:	4b05      	ldr	r3, [pc, #20]	@ (c004b48 <HAL_ICACHE_Disable+0x5c>)
 c004b32:	681b      	ldr	r3, [r3, #0]
 c004b34:	f003 0301 	and.w	r3, r3, #1
 c004b38:	2b00      	cmp	r3, #0
 c004b3a:	d1e9      	bne.n	c004b10 <HAL_ICACHE_Disable+0x24>
      }
    }
  }

  return status;
 c004b3c:	79fb      	ldrb	r3, [r7, #7]
}
 c004b3e:	4618      	mov	r0, r3
 c004b40:	3708      	adds	r7, #8
 c004b42:	46bd      	mov	sp, r7
 c004b44:	bd80      	pop	{r7, pc}
 c004b46:	bf00      	nop
 c004b48:	50030400 	.word	0x50030400

0c004b4c <HAL_ICACHE_Invalidate>:
  * @note   This function waits for the end of cache invalidation procedure
  *         and clears the associated BSYENDF flag.
  * @retval HAL status (HAL_OK/HAL_ERROR/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_Invalidate(void)
{
 c004b4c:	b580      	push	{r7, lr}
 c004b4e:	b082      	sub	sp, #8
 c004b50:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Check if no ongoing operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) == 0U)
 c004b52:	4b0a      	ldr	r3, [pc, #40]	@ (c004b7c <HAL_ICACHE_Invalidate+0x30>)
 c004b54:	685b      	ldr	r3, [r3, #4]
 c004b56:	f003 0301 	and.w	r3, r3, #1
 c004b5a:	2b00      	cmp	r3, #0
 c004b5c:	d105      	bne.n	c004b6a <HAL_ICACHE_Invalidate+0x1e>
  {
    /* Launch cache invalidation */
    SET_BIT(ICACHE->CR, ICACHE_CR_CACHEINV);
 c004b5e:	4b07      	ldr	r3, [pc, #28]	@ (c004b7c <HAL_ICACHE_Invalidate+0x30>)
 c004b60:	681b      	ldr	r3, [r3, #0]
 c004b62:	4a06      	ldr	r2, [pc, #24]	@ (c004b7c <HAL_ICACHE_Invalidate+0x30>)
 c004b64:	f043 0302 	orr.w	r3, r3, #2
 c004b68:	6013      	str	r3, [r2, #0]
  }

  status = HAL_ICACHE_WaitForInvalidateComplete();
 c004b6a:	f000 f809 	bl	c004b80 <HAL_ICACHE_WaitForInvalidateComplete>
 c004b6e:	4603      	mov	r3, r0
 c004b70:	71fb      	strb	r3, [r7, #7]

  return status;
 c004b72:	79fb      	ldrb	r3, [r7, #7]
}
 c004b74:	4618      	mov	r0, r3
 c004b76:	3708      	adds	r7, #8
 c004b78:	46bd      	mov	sp, r7
 c004b7a:	bd80      	pop	{r7, pc}
 c004b7c:	50030400 	.word	0x50030400

0c004b80 <HAL_ICACHE_WaitForInvalidateComplete>:
  * @brief Wait for the end of the Instruction Cache invalidate procedure.
  * @note This function checks and clears the BSYENDF flag when set.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_WaitForInvalidateComplete(void)
{
 c004b80:	b580      	push	{r7, lr}
 c004b82:	b082      	sub	sp, #8
 c004b84:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 c004b86:	2300      	movs	r3, #0
 c004b88:	71fb      	strb	r3, [r7, #7]
  uint32_t tickstart;

  /* Check if ongoing invalidation operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c004b8a:	4b14      	ldr	r3, [pc, #80]	@ (c004bdc <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004b8c:	685b      	ldr	r3, [r3, #4]
 c004b8e:	f003 0301 	and.w	r3, r3, #1
 c004b92:	2b00      	cmp	r3, #0
 c004b94:	d019      	beq.n	c004bca <HAL_ICACHE_WaitForInvalidateComplete+0x4a>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
 c004b96:	f7ff f879 	bl	c003c8c <HAL_GetTick>
 c004b9a:	6038      	str	r0, [r7, #0]

    /* Wait for end of cache invalidation */
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004b9c:	e00f      	b.n	c004bbe <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
    {
      if ((HAL_GetTick() - tickstart) > ICACHE_INVALIDATE_TIMEOUT_VALUE)
 c004b9e:	f7ff f875 	bl	c003c8c <HAL_GetTick>
 c004ba2:	4602      	mov	r2, r0
 c004ba4:	683b      	ldr	r3, [r7, #0]
 c004ba6:	1ad3      	subs	r3, r2, r3
 c004ba8:	2b01      	cmp	r3, #1
 c004baa:	d908      	bls.n	c004bbe <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004bac:	4b0b      	ldr	r3, [pc, #44]	@ (c004bdc <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bae:	685b      	ldr	r3, [r3, #4]
 c004bb0:	f003 0302 	and.w	r3, r3, #2
 c004bb4:	2b00      	cmp	r3, #0
 c004bb6:	d102      	bne.n	c004bbe <HAL_ICACHE_WaitForInvalidateComplete+0x3e>
        {
          status = HAL_TIMEOUT;
 c004bb8:	2303      	movs	r3, #3
 c004bba:	71fb      	strb	r3, [r7, #7]
          break;
 c004bbc:	e005      	b.n	c004bca <HAL_ICACHE_WaitForInvalidateComplete+0x4a>
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c004bbe:	4b07      	ldr	r3, [pc, #28]	@ (c004bdc <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bc0:	685b      	ldr	r3, [r3, #4]
 c004bc2:	f003 0302 	and.w	r3, r3, #2
 c004bc6:	2b00      	cmp	r3, #0
 c004bc8:	d0e9      	beq.n	c004b9e <HAL_ICACHE_WaitForInvalidateComplete+0x1e>
      }
    }
  }

  /* Clear BSYENDF */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c004bca:	4b04      	ldr	r3, [pc, #16]	@ (c004bdc <HAL_ICACHE_WaitForInvalidateComplete+0x5c>)
 c004bcc:	2202      	movs	r2, #2
 c004bce:	60da      	str	r2, [r3, #12]

  return status;
 c004bd0:	79fb      	ldrb	r3, [r7, #7]
}
 c004bd2:	4618      	mov	r0, r3
 c004bd4:	3708      	adds	r7, #8
 c004bd6:	46bd      	mov	sp, r7
 c004bd8:	bd80      	pop	{r7, pc}
 c004bda:	bf00      	nop
 c004bdc:	50030400 	.word	0x50030400

0c004be0 <HAL_PWREx_EnableVddIO2>:
  * @brief Enable VDDIO2 supply.
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
 c004be0:	b480      	push	{r7}
 c004be2:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 c004be4:	4b05      	ldr	r3, [pc, #20]	@ (c004bfc <HAL_PWREx_EnableVddIO2+0x1c>)
 c004be6:	685b      	ldr	r3, [r3, #4]
 c004be8:	4a04      	ldr	r2, [pc, #16]	@ (c004bfc <HAL_PWREx_EnableVddIO2+0x1c>)
 c004bea:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 c004bee:	6053      	str	r3, [r2, #4]
}
 c004bf0:	bf00      	nop
 c004bf2:	46bd      	mov	sp, r7
 c004bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004bf8:	4770      	bx	lr
 c004bfa:	bf00      	nop
 c004bfc:	50007000 	.word	0x50007000

0c004c00 <HAL_PWREx_DisableUCPDDeadBattery>:
  *       or to hand over control to the UCPD (which should therefore be
  *       initialized before doing the disable).
  * @retval None
  */
void HAL_PWREx_DisableUCPDDeadBattery(void)
{
 c004c00:	b480      	push	{r7}
 c004c02:	af00      	add	r7, sp, #0
  /* Write 1 to disable the USB Type-C dead battery pull-down behavior */
  SET_BIT(PWR->CR3, PWR_CR3_UCPD_DBDIS);
 c004c04:	4b05      	ldr	r3, [pc, #20]	@ (c004c1c <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 c004c06:	689b      	ldr	r3, [r3, #8]
 c004c08:	4a04      	ldr	r2, [pc, #16]	@ (c004c1c <HAL_PWREx_DisableUCPDDeadBattery+0x1c>)
 c004c0a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 c004c0e:	6093      	str	r3, [r2, #8]
}
 c004c10:	bf00      	nop
 c004c12:	46bd      	mov	sp, r7
 c004c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004c18:	4770      	bx	lr
 c004c1a:	bf00      	nop
 c004c1c:	50007000 	.word	0x50007000

0c004c20 <__acle_se_SecureContext_Init>:
	uint8_t *pucStackStart;				/**< First location of the stack memory. */
} SecureContext_t;
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_Init( void )
{
 c004c20:	b480      	push	{r7}
 c004c22:	b083      	sub	sp, #12
 c004c24:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004c26:	f3ef 8305 	mrs	r3, IPSR
 c004c2a:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004c2c:	687b      	ldr	r3, [r7, #4]
 c004c2e:	2b00      	cmp	r3, #0
 c004c30:	d008      	beq.n	c004c44 <__acle_se_SecureContext_Init+0x24>
	{
		/* No stack for thread mode until a task's context is loaded. */
		secureportSET_PSPLIM( securecontextNO_STACK );
 c004c32:	2300      	movs	r3, #0
 c004c34:	f383 880b 	msr	PSPLIM, r3
		secureportSET_PSP( securecontextNO_STACK );
 c004c38:	2300      	movs	r3, #0
 c004c3a:	f383 8809 	msr	PSP, r3
			secureportSET_CONTROL( securecontextCONTROL_VALUE_UNPRIVILEGED );
		}
		#else /* configENABLE_MPU */
		{
			/* Configure thread mode to use PSP and to be privileged.. */
			secureportSET_CONTROL( securecontextCONTROL_VALUE_PRIVILEGED );
 c004c3e:	2302      	movs	r3, #2
 c004c40:	f383 8814 	msr	CONTROL, r3
		}
		#endif /* configENABLE_MPU */
	}
}
 c004c44:	bf00      	nop
 c004c46:	370c      	adds	r7, #12
 c004c48:	46bd      	mov	sp, r7
 c004c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004c4e:	4670      	mov	r0, lr
 c004c50:	4671      	mov	r1, lr
 c004c52:	4672      	mov	r2, lr
 c004c54:	4673      	mov	r3, lr
 c004c56:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004c5a:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004c5e:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004c62:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004c66:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004c6a:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004c6e:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004c72:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004c76:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004c7a:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004c7e:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004c82:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004c86:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004c8a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004c8e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004c92:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004c96:	f38e 8c00 	msr	CPSR_fs, lr
 c004c9a:	b410      	push	{r4}
 c004c9c:	eef1 ca10 	vmrs	ip, fpscr
 c004ca0:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004ca4:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004ca8:	ea0c 0c04 	and.w	ip, ip, r4
 c004cac:	eee1 ca10 	vmsr	fpscr, ip
 c004cb0:	bc10      	pop	{r4}
 c004cb2:	46f4      	mov	ip, lr
 c004cb4:	4774      	bxns	lr

0c004cb6 <__acle_se_SecureContext_AllocateContext>:
#if( configENABLE_MPU == 1 )
	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize, uint32_t ulIsTaskPrivileged )
#else /* configENABLE_MPU */
	secureportNON_SECURE_CALLABLE SecureContextHandle_t SecureContext_AllocateContext( uint32_t ulSecureStackSize )
#endif /* configENABLE_MPU */
{
 c004cb6:	b580      	push	{r7, lr}
 c004cb8:	b086      	sub	sp, #24
 c004cba:	af00      	add	r7, sp, #0
 c004cbc:	6078      	str	r0, [r7, #4]
	uint8_t *pucStackMemory = NULL;
 c004cbe:	2300      	movs	r3, #0
 c004cc0:	613b      	str	r3, [r7, #16]
	uint32_t ulIPSR;
	SecureContextHandle_t xSecureContextHandle = NULL;
 c004cc2:	2300      	movs	r3, #0
 c004cc4:	617b      	str	r3, [r7, #20]
	#if( configENABLE_MPU == 1 )
		uint32_t *pulCurrentStackPointer = NULL;
	#endif /* configENABLE_MPU */

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004cc6:	f3ef 8305 	mrs	r3, IPSR
 c004cca:	60fb      	str	r3, [r7, #12]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004ccc:	68fb      	ldr	r3, [r7, #12]
 c004cce:	2b00      	cmp	r3, #0
 c004cd0:	d01f      	beq.n	c004d12 <__acle_se_SecureContext_AllocateContext+0x5c>
	{
		/* Allocate the context structure. */
		xSecureContextHandle = ( SecureContextHandle_t ) pvPortMalloc( sizeof( SecureContext_t ) );
 c004cd2:	200c      	movs	r0, #12
 c004cd4:	f000 f9f8 	bl	c0050c8 <pvPortMalloc>
 c004cd8:	6178      	str	r0, [r7, #20]

		if( xSecureContextHandle != NULL )
 c004cda:	697b      	ldr	r3, [r7, #20]
 c004cdc:	2b00      	cmp	r3, #0
 c004cde:	d018      	beq.n	c004d12 <__acle_se_SecureContext_AllocateContext+0x5c>
		{
			/* Allocate the stack space. */
			pucStackMemory = pvPortMalloc( ulSecureStackSize );
 c004ce0:	6878      	ldr	r0, [r7, #4]
 c004ce2:	f000 f9f1 	bl	c0050c8 <pvPortMalloc>
 c004ce6:	6138      	str	r0, [r7, #16]

			if( pucStackMemory != NULL )
 c004ce8:	693b      	ldr	r3, [r7, #16]
 c004cea:	2b00      	cmp	r3, #0
 c004cec:	d00c      	beq.n	c004d08 <__acle_se_SecureContext_AllocateContext+0x52>
				 * location. Note that this location is next to the last
				 * allocated byte because the hardware decrements the stack
				 * pointer before writing i.e. if stack pointer is 0x2, a push
				 * operation will decrement the stack pointer to 0x1 and then
				 * write at 0x1. */
				xSecureContextHandle->pucStackStart = pucStackMemory + ulSecureStackSize;
 c004cee:	693a      	ldr	r2, [r7, #16]
 c004cf0:	687b      	ldr	r3, [r7, #4]
 c004cf2:	441a      	add	r2, r3
 c004cf4:	697b      	ldr	r3, [r7, #20]
 c004cf6:	609a      	str	r2, [r3, #8]

				/* The stack cannot go beyond this location. This value is
				 * programmed in the PSPLIM register on context switch.*/
				xSecureContextHandle->pucStackLimit = pucStackMemory;
 c004cf8:	697b      	ldr	r3, [r7, #20]
 c004cfa:	693a      	ldr	r2, [r7, #16]
 c004cfc:	605a      	str	r2, [r3, #4]
				}
				#else /* configENABLE_MPU */
				{
					/* Current SP is set to the starting of the stack. This
					 * value programmed in the PSP register on context switch. */
					xSecureContextHandle->pucCurrentStackPointer = xSecureContextHandle->pucStackStart;
 c004cfe:	697b      	ldr	r3, [r7, #20]
 c004d00:	689a      	ldr	r2, [r3, #8]
 c004d02:	697b      	ldr	r3, [r7, #20]
 c004d04:	601a      	str	r2, [r3, #0]
 c004d06:	e004      	b.n	c004d12 <__acle_se_SecureContext_AllocateContext+0x5c>
			}
			else
			{
				/* Free the context to avoid memory leak and make sure to return
				 * NULL to indicate failure. */
				vPortFree( xSecureContextHandle );
 c004d08:	6978      	ldr	r0, [r7, #20]
 c004d0a:	f000 fa95 	bl	c005238 <vPortFree>
				xSecureContextHandle = NULL;
 c004d0e:	2300      	movs	r3, #0
 c004d10:	617b      	str	r3, [r7, #20]
			}
		}
	}

	return xSecureContextHandle;
 c004d12:	697b      	ldr	r3, [r7, #20]
}
 c004d14:	4618      	mov	r0, r3
 c004d16:	3718      	adds	r7, #24
 c004d18:	46bd      	mov	sp, r7
 c004d1a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c004d1e:	4671      	mov	r1, lr
 c004d20:	4672      	mov	r2, lr
 c004d22:	4673      	mov	r3, lr
 c004d24:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004d28:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004d2c:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004d30:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004d34:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004d38:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004d3c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004d40:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004d44:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004d48:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004d4c:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004d50:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004d54:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004d58:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004d5c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004d60:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004d64:	f38e 8c00 	msr	CPSR_fs, lr
 c004d68:	b410      	push	{r4}
 c004d6a:	eef1 ca10 	vmrs	ip, fpscr
 c004d6e:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004d72:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004d76:	ea0c 0c04 	and.w	ip, ip, r4
 c004d7a:	eee1 ca10 	vmsr	fpscr, ip
 c004d7e:	bc10      	pop	{r4}
 c004d80:	46f4      	mov	ip, lr
 c004d82:	4774      	bxns	lr

0c004d84 <__acle_se_SecureContext_FreeContext>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_FreeContext( SecureContextHandle_t xSecureContextHandle )
{
 c004d84:	b580      	push	{r7, lr}
 c004d86:	b084      	sub	sp, #16
 c004d88:	af00      	add	r7, sp, #0
 c004d8a:	6078      	str	r0, [r7, #4]
	uint32_t ulIPSR;

	/* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c004d8c:	f3ef 8305 	mrs	r3, IPSR
 c004d90:	60fb      	str	r3, [r7, #12]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c004d92:	68fb      	ldr	r3, [r7, #12]
 c004d94:	2b00      	cmp	r3, #0
 c004d96:	d012      	beq.n	c004dbe <__acle_se_SecureContext_FreeContext+0x3a>
	{
		/* Ensure that valid parameters are passed. */
		secureportASSERT( xSecureContextHandle != NULL );
 c004d98:	687b      	ldr	r3, [r7, #4]
 c004d9a:	2b00      	cmp	r3, #0
 c004d9c:	d107      	bne.n	c004dae <__acle_se_SecureContext_FreeContext+0x2a>
 c004d9e:	2301      	movs	r3, #1
 c004da0:	f383 8810 	msr	PRIMASK, r3
 c004da4:	2301      	movs	r3, #1
 c004da6:	f383 8890 	msr	PRIMASK_NS, r3
 c004daa:	bf00      	nop
 c004dac:	e7fd      	b.n	c004daa <__acle_se_SecureContext_FreeContext+0x26>

		/* Free the stack space. */
		vPortFree( xSecureContextHandle->pucStackLimit );
 c004dae:	687b      	ldr	r3, [r7, #4]
 c004db0:	685b      	ldr	r3, [r3, #4]
 c004db2:	4618      	mov	r0, r3
 c004db4:	f000 fa40 	bl	c005238 <vPortFree>

		/* Free the context itself. */
		vPortFree( xSecureContextHandle );
 c004db8:	6878      	ldr	r0, [r7, #4]
 c004dba:	f000 fa3d 	bl	c005238 <vPortFree>
	}
}
 c004dbe:	bf00      	nop
 c004dc0:	3710      	adds	r7, #16
 c004dc2:	46bd      	mov	sp, r7
 c004dc4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 c004dc8:	4670      	mov	r0, lr
 c004dca:	4671      	mov	r1, lr
 c004dcc:	4672      	mov	r2, lr
 c004dce:	4673      	mov	r3, lr
 c004dd0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004dd4:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004dd8:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004ddc:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004de0:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004de4:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004de8:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004dec:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004df0:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004df4:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004df8:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004dfc:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004e00:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004e04:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004e08:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004e0c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004e10:	f38e 8c00 	msr	CPSR_fs, lr
 c004e14:	b410      	push	{r4}
 c004e16:	eef1 ca10 	vmrs	ip, fpscr
 c004e1a:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004e1e:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004e22:	ea0c 0c04 	and.w	ip, ip, r4
 c004e26:	eee1 ca10 	vmsr	fpscr, ip
 c004e2a:	bc10      	pop	{r4}
 c004e2c:	46f4      	mov	ip, lr
 c004e2e:	4774      	bxns	lr

0c004e30 <__acle_se_SecureContext_LoadContext>:

/* Secure port macros. */
#include "secure_port_macros.h"

secureportNON_SECURE_CALLABLE void SecureContext_LoadContext( SecureContextHandle_t xSecureContextHandle )
{
 c004e30:	b480      	push	{r7}
 c004e32:	b083      	sub	sp, #12
 c004e34:	af00      	add	r7, sp, #0
 c004e36:	6078      	str	r0, [r7, #4]
	/* xSecureContextHandle value is in r0. */
	__asm volatile
 c004e38:	f3ef 8105 	mrs	r1, IPSR
 c004e3c:	b121      	cbz	r1, c004e48 <load_ctx_therad_mode>
 c004e3e:	c806      	ldmia	r0!, {r1, r2}
 c004e40:	f382 880b 	msr	PSPLIM, r2
 c004e44:	f381 8809 	msr	PSP, r1

0c004e48 <load_ctx_therad_mode>:
 c004e48:	bf00      	nop
	" load_ctx_therad_mode:						\n"
	"	nop										\n"
	"											\n"
	:::"r0", "r1", "r2"
	);
}
 c004e4a:	bf00      	nop
 c004e4c:	370c      	adds	r7, #12
 c004e4e:	46bd      	mov	sp, r7
 c004e50:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004e54:	4670      	mov	r0, lr
 c004e56:	4671      	mov	r1, lr
 c004e58:	4672      	mov	r2, lr
 c004e5a:	4673      	mov	r3, lr
 c004e5c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004e60:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004e64:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004e68:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004e6c:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004e70:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004e74:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004e78:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004e7c:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004e80:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004e84:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004e88:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004e8c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004e90:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004e94:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004e98:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004e9c:	f38e 8c00 	msr	CPSR_fs, lr
 c004ea0:	b410      	push	{r4}
 c004ea2:	eef1 ca10 	vmrs	ip, fpscr
 c004ea6:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004eaa:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004eae:	ea0c 0c04 	and.w	ip, ip, r4
 c004eb2:	eee1 ca10 	vmsr	fpscr, ip
 c004eb6:	bc10      	pop	{r4}
 c004eb8:	46f4      	mov	ip, lr
 c004eba:	4774      	bxns	lr

0c004ebc <__acle_se_SecureContext_SaveContext>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureContext_SaveContext( SecureContextHandle_t xSecureContextHandle )
{
 c004ebc:	b480      	push	{r7}
 c004ebe:	b083      	sub	sp, #12
 c004ec0:	af00      	add	r7, sp, #0
 c004ec2:	6078      	str	r0, [r7, #4]
	/* xSecureContextHandle value is in r0. */
	__asm volatile
 c004ec4:	f3ef 8105 	mrs	r1, IPSR
 c004ec8:	b139      	cbz	r1, c004eda <save_ctx_therad_mode>
 c004eca:	f3ef 8109 	mrs	r1, PSP
 c004ece:	6001      	str	r1, [r0, #0]
 c004ed0:	2100      	movs	r1, #0
 c004ed2:	f381 880b 	msr	PSPLIM, r1
 c004ed6:	f381 8809 	msr	PSP, r1

0c004eda <save_ctx_therad_mode>:
 c004eda:	bf00      	nop
	" save_ctx_therad_mode:						\n"
	"	nop										\n"
	"											\n"
	:: "i" ( securecontextNO_STACK ) : "r1", "memory"
	);
}
 c004edc:	bf00      	nop
 c004ede:	370c      	adds	r7, #12
 c004ee0:	46bd      	mov	sp, r7
 c004ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004ee6:	4670      	mov	r0, lr
 c004ee8:	4671      	mov	r1, lr
 c004eea:	4672      	mov	r2, lr
 c004eec:	4673      	mov	r3, lr
 c004eee:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c004ef2:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c004ef6:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c004efa:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c004efe:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c004f02:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c004f06:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c004f0a:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c004f0e:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c004f12:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c004f16:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c004f1a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c004f1e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c004f22:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c004f26:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c004f2a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c004f2e:	f38e 8c00 	msr	CPSR_fs, lr
 c004f32:	b410      	push	{r4}
 c004f34:	eef1 ca10 	vmrs	ip, fpscr
 c004f38:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c004f3c:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c004f40:	ea0c 0c04 	and.w	ip, ip, r4
 c004f44:	eee1 ca10 	vmsr	fpscr, ip
 c004f48:	bc10      	pop	{r4}
 c004f4a:	46f4      	mov	ip, lr
 c004f4c:	4774      	bxns	lr
	...

0c004f50 <prvHeapInit>:
 */
static size_t xBlockAllocatedBit = 0;
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 c004f50:	b480      	push	{r7}
 c004f52:	b085      	sub	sp, #20
 c004f54:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = secureconfigTOTAL_HEAP_SIZE;
 c004f56:	f44f 5320 	mov.w	r3, #10240	@ 0x2800
 c004f5a:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 c004f5c:	4b27      	ldr	r3, [pc, #156]	@ (c004ffc <prvHeapInit+0xac>)
 c004f5e:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & secureportBYTE_ALIGNMENT_MASK ) != 0 )
 c004f60:	68fb      	ldr	r3, [r7, #12]
 c004f62:	f003 0307 	and.w	r3, r3, #7
 c004f66:	2b00      	cmp	r3, #0
 c004f68:	d00c      	beq.n	c004f84 <prvHeapInit+0x34>
	{
		uxAddress += ( secureportBYTE_ALIGNMENT - 1 );
 c004f6a:	68fb      	ldr	r3, [r7, #12]
 c004f6c:	3307      	adds	r3, #7
 c004f6e:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
 c004f70:	68fb      	ldr	r3, [r7, #12]
 c004f72:	f023 0307 	bic.w	r3, r3, #7
 c004f76:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 c004f78:	68ba      	ldr	r2, [r7, #8]
 c004f7a:	68fb      	ldr	r3, [r7, #12]
 c004f7c:	1ad3      	subs	r3, r2, r3
 c004f7e:	4a1f      	ldr	r2, [pc, #124]	@ (c004ffc <prvHeapInit+0xac>)
 c004f80:	4413      	add	r3, r2
 c004f82:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 c004f84:	68fb      	ldr	r3, [r7, #12]
 c004f86:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	 * blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 c004f88:	4a1d      	ldr	r2, [pc, #116]	@ (c005000 <prvHeapInit+0xb0>)
 c004f8a:	687b      	ldr	r3, [r7, #4]
 c004f8c:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 c004f8e:	4b1c      	ldr	r3, [pc, #112]	@ (c005000 <prvHeapInit+0xb0>)
 c004f90:	2200      	movs	r2, #0
 c004f92:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	 * at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 c004f94:	687b      	ldr	r3, [r7, #4]
 c004f96:	68ba      	ldr	r2, [r7, #8]
 c004f98:	4413      	add	r3, r2
 c004f9a:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 c004f9c:	2208      	movs	r2, #8
 c004f9e:	68fb      	ldr	r3, [r7, #12]
 c004fa0:	1a9b      	subs	r3, r3, r2
 c004fa2:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) secureportBYTE_ALIGNMENT_MASK );
 c004fa4:	68fb      	ldr	r3, [r7, #12]
 c004fa6:	f023 0307 	bic.w	r3, r3, #7
 c004faa:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 c004fac:	68fb      	ldr	r3, [r7, #12]
 c004fae:	4a15      	ldr	r2, [pc, #84]	@ (c005004 <prvHeapInit+0xb4>)
 c004fb0:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 c004fb2:	4b14      	ldr	r3, [pc, #80]	@ (c005004 <prvHeapInit+0xb4>)
 c004fb4:	681b      	ldr	r3, [r3, #0]
 c004fb6:	2200      	movs	r2, #0
 c004fb8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 c004fba:	4b12      	ldr	r3, [pc, #72]	@ (c005004 <prvHeapInit+0xb4>)
 c004fbc:	681b      	ldr	r3, [r3, #0]
 c004fbe:	2200      	movs	r2, #0
 c004fc0:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	 * entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 c004fc2:	687b      	ldr	r3, [r7, #4]
 c004fc4:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 c004fc6:	683b      	ldr	r3, [r7, #0]
 c004fc8:	68fa      	ldr	r2, [r7, #12]
 c004fca:	1ad2      	subs	r2, r2, r3
 c004fcc:	683b      	ldr	r3, [r7, #0]
 c004fce:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 c004fd0:	4b0c      	ldr	r3, [pc, #48]	@ (c005004 <prvHeapInit+0xb4>)
 c004fd2:	681a      	ldr	r2, [r3, #0]
 c004fd4:	683b      	ldr	r3, [r7, #0]
 c004fd6:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 c004fd8:	683b      	ldr	r3, [r7, #0]
 c004fda:	685b      	ldr	r3, [r3, #4]
 c004fdc:	4a0a      	ldr	r2, [pc, #40]	@ (c005008 <prvHeapInit+0xb8>)
 c004fde:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 c004fe0:	683b      	ldr	r3, [r7, #0]
 c004fe2:	685b      	ldr	r3, [r3, #4]
 c004fe4:	4a09      	ldr	r2, [pc, #36]	@ (c00500c <prvHeapInit+0xbc>)
 c004fe6:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * secureheapBITS_PER_BYTE ) - 1 );
 c004fe8:	4b09      	ldr	r3, [pc, #36]	@ (c005010 <prvHeapInit+0xc0>)
 c004fea:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 c004fee:	601a      	str	r2, [r3, #0]
}
 c004ff0:	bf00      	nop
 c004ff2:	3714      	adds	r7, #20
 c004ff4:	46bd      	mov	sp, r7
 c004ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
 c004ffa:	4770      	bx	lr
 c004ffc:	30000ac0 	.word	0x30000ac0
 c005000:	300032c0 	.word	0x300032c0
 c005004:	300032c8 	.word	0x300032c8
 c005008:	300032d0 	.word	0x300032d0
 c00500c:	300032cc 	.word	0x300032cc
 c005010:	300032d4 	.word	0x300032d4

0c005014 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 c005014:	b480      	push	{r7}
 c005016:	b085      	sub	sp, #20
 c005018:	af00      	add	r7, sp, #0
 c00501a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	 * than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 c00501c:	4b28      	ldr	r3, [pc, #160]	@ (c0050c0 <prvInsertBlockIntoFreeList+0xac>)
 c00501e:	60fb      	str	r3, [r7, #12]
 c005020:	e002      	b.n	c005028 <prvInsertBlockIntoFreeList+0x14>
 c005022:	68fb      	ldr	r3, [r7, #12]
 c005024:	681b      	ldr	r3, [r3, #0]
 c005026:	60fb      	str	r3, [r7, #12]
 c005028:	68fb      	ldr	r3, [r7, #12]
 c00502a:	681b      	ldr	r3, [r3, #0]
 c00502c:	687a      	ldr	r2, [r7, #4]
 c00502e:	429a      	cmp	r2, r3
 c005030:	d8f7      	bhi.n	c005022 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	 * make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 c005032:	68fb      	ldr	r3, [r7, #12]
 c005034:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 c005036:	68fb      	ldr	r3, [r7, #12]
 c005038:	685b      	ldr	r3, [r3, #4]
 c00503a:	68ba      	ldr	r2, [r7, #8]
 c00503c:	4413      	add	r3, r2
 c00503e:	687a      	ldr	r2, [r7, #4]
 c005040:	429a      	cmp	r2, r3
 c005042:	d108      	bne.n	c005056 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 c005044:	68fb      	ldr	r3, [r7, #12]
 c005046:	685a      	ldr	r2, [r3, #4]
 c005048:	687b      	ldr	r3, [r7, #4]
 c00504a:	685b      	ldr	r3, [r3, #4]
 c00504c:	441a      	add	r2, r3
 c00504e:	68fb      	ldr	r3, [r7, #12]
 c005050:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 c005052:	68fb      	ldr	r3, [r7, #12]
 c005054:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	 * make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 c005056:	687b      	ldr	r3, [r7, #4]
 c005058:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 c00505a:	687b      	ldr	r3, [r7, #4]
 c00505c:	685b      	ldr	r3, [r3, #4]
 c00505e:	68ba      	ldr	r2, [r7, #8]
 c005060:	441a      	add	r2, r3
 c005062:	68fb      	ldr	r3, [r7, #12]
 c005064:	681b      	ldr	r3, [r3, #0]
 c005066:	429a      	cmp	r2, r3
 c005068:	d118      	bne.n	c00509c <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 c00506a:	68fb      	ldr	r3, [r7, #12]
 c00506c:	681a      	ldr	r2, [r3, #0]
 c00506e:	4b15      	ldr	r3, [pc, #84]	@ (c0050c4 <prvInsertBlockIntoFreeList+0xb0>)
 c005070:	681b      	ldr	r3, [r3, #0]
 c005072:	429a      	cmp	r2, r3
 c005074:	d00d      	beq.n	c005092 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 c005076:	687b      	ldr	r3, [r7, #4]
 c005078:	685a      	ldr	r2, [r3, #4]
 c00507a:	68fb      	ldr	r3, [r7, #12]
 c00507c:	681b      	ldr	r3, [r3, #0]
 c00507e:	685b      	ldr	r3, [r3, #4]
 c005080:	441a      	add	r2, r3
 c005082:	687b      	ldr	r3, [r7, #4]
 c005084:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 c005086:	68fb      	ldr	r3, [r7, #12]
 c005088:	681b      	ldr	r3, [r3, #0]
 c00508a:	681a      	ldr	r2, [r3, #0]
 c00508c:	687b      	ldr	r3, [r7, #4]
 c00508e:	601a      	str	r2, [r3, #0]
 c005090:	e008      	b.n	c0050a4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 c005092:	4b0c      	ldr	r3, [pc, #48]	@ (c0050c4 <prvInsertBlockIntoFreeList+0xb0>)
 c005094:	681a      	ldr	r2, [r3, #0]
 c005096:	687b      	ldr	r3, [r7, #4]
 c005098:	601a      	str	r2, [r3, #0]
 c00509a:	e003      	b.n	c0050a4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 c00509c:	68fb      	ldr	r3, [r7, #12]
 c00509e:	681a      	ldr	r2, [r3, #0]
 c0050a0:	687b      	ldr	r3, [r7, #4]
 c0050a2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	 * before and the block after, then it's pxNextFreeBlock pointer will have
	 * already been set, and should not be set here as that would make it point
	 * to itself. */
	if( pxIterator != pxBlockToInsert )
 c0050a4:	68fa      	ldr	r2, [r7, #12]
 c0050a6:	687b      	ldr	r3, [r7, #4]
 c0050a8:	429a      	cmp	r2, r3
 c0050aa:	d002      	beq.n	c0050b2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 c0050ac:	68fb      	ldr	r3, [r7, #12]
 c0050ae:	687a      	ldr	r2, [r7, #4]
 c0050b0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 c0050b2:	bf00      	nop
 c0050b4:	3714      	adds	r7, #20
 c0050b6:	46bd      	mov	sp, r7
 c0050b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0050bc:	4770      	bx	lr
 c0050be:	bf00      	nop
 c0050c0:	300032c0 	.word	0x300032c0
 c0050c4:	300032c8 	.word	0x300032c8

0c0050c8 <pvPortMalloc>:
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 c0050c8:	b580      	push	{r7, lr}
 c0050ca:	b086      	sub	sp, #24
 c0050cc:	af00      	add	r7, sp, #0
 c0050ce:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 c0050d0:	2300      	movs	r3, #0
 c0050d2:	60fb      	str	r3, [r7, #12]

	/* If this is the first call to malloc then the heap will require
	 * initialisation to setup the list of free blocks. */
	if( pxEnd == NULL )
 c0050d4:	4b53      	ldr	r3, [pc, #332]	@ (c005224 <pvPortMalloc+0x15c>)
 c0050d6:	681b      	ldr	r3, [r3, #0]
 c0050d8:	2b00      	cmp	r3, #0
 c0050da:	d101      	bne.n	c0050e0 <pvPortMalloc+0x18>
	{
		prvHeapInit();
 c0050dc:	f7ff ff38 	bl	c004f50 <prvHeapInit>

	/* Check the requested block size is not so large that the top bit is set.
	 * The top bit of the block size member of the BlockLink_t structure is used
	 * to determine who owns the block - the application or the kernel, so it
	 * must be free. */
	if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 c0050e0:	4b51      	ldr	r3, [pc, #324]	@ (c005228 <pvPortMalloc+0x160>)
 c0050e2:	681a      	ldr	r2, [r3, #0]
 c0050e4:	687b      	ldr	r3, [r7, #4]
 c0050e6:	4013      	ands	r3, r2
 c0050e8:	2b00      	cmp	r3, #0
 c0050ea:	f040 8088 	bne.w	c0051fe <pvPortMalloc+0x136>
	{
		/* The wanted size is increased so it can contain a BlockLink_t
		 * structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 c0050ee:	687b      	ldr	r3, [r7, #4]
 c0050f0:	2b00      	cmp	r3, #0
 c0050f2:	d01a      	beq.n	c00512a <pvPortMalloc+0x62>
		{
			xWantedSize += xHeapStructSize;
 c0050f4:	2208      	movs	r2, #8
 c0050f6:	687b      	ldr	r3, [r7, #4]
 c0050f8:	4413      	add	r3, r2
 c0050fa:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of
			 * bytes. */
			if( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) != 0x00 )
 c0050fc:	687b      	ldr	r3, [r7, #4]
 c0050fe:	f003 0307 	and.w	r3, r3, #7
 c005102:	2b00      	cmp	r3, #0
 c005104:	d011      	beq.n	c00512a <pvPortMalloc+0x62>
			{
				/* Byte alignment required. */
				xWantedSize += ( secureportBYTE_ALIGNMENT - ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) );
 c005106:	687b      	ldr	r3, [r7, #4]
 c005108:	f023 0307 	bic.w	r3, r3, #7
 c00510c:	3308      	adds	r3, #8
 c00510e:	607b      	str	r3, [r7, #4]
				secureportASSERT( ( xWantedSize & secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c005110:	687b      	ldr	r3, [r7, #4]
 c005112:	f003 0307 	and.w	r3, r3, #7
 c005116:	2b00      	cmp	r3, #0
 c005118:	d007      	beq.n	c00512a <pvPortMalloc+0x62>
 c00511a:	2301      	movs	r3, #1
 c00511c:	f383 8810 	msr	PRIMASK, r3
 c005120:	2301      	movs	r3, #1
 c005122:	f383 8890 	msr	PRIMASK_NS, r3
 c005126:	bf00      	nop
 c005128:	e7fd      	b.n	c005126 <pvPortMalloc+0x5e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 c00512a:	687b      	ldr	r3, [r7, #4]
 c00512c:	2b00      	cmp	r3, #0
 c00512e:	d066      	beq.n	c0051fe <pvPortMalloc+0x136>
 c005130:	4b3e      	ldr	r3, [pc, #248]	@ (c00522c <pvPortMalloc+0x164>)
 c005132:	681b      	ldr	r3, [r3, #0]
 c005134:	687a      	ldr	r2, [r7, #4]
 c005136:	429a      	cmp	r2, r3
 c005138:	d861      	bhi.n	c0051fe <pvPortMalloc+0x136>
		{
			/* Traverse the list from the start (lowest address) block until
			 * one of adequate size is found. */
			pxPreviousBlock = &xStart;
 c00513a:	4b3d      	ldr	r3, [pc, #244]	@ (c005230 <pvPortMalloc+0x168>)
 c00513c:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
 c00513e:	4b3c      	ldr	r3, [pc, #240]	@ (c005230 <pvPortMalloc+0x168>)
 c005140:	681b      	ldr	r3, [r3, #0]
 c005142:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 c005144:	e004      	b.n	c005150 <pvPortMalloc+0x88>
			{
				pxPreviousBlock = pxBlock;
 c005146:	697b      	ldr	r3, [r7, #20]
 c005148:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
 c00514a:	697b      	ldr	r3, [r7, #20]
 c00514c:	681b      	ldr	r3, [r3, #0]
 c00514e:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 c005150:	697b      	ldr	r3, [r7, #20]
 c005152:	685b      	ldr	r3, [r3, #4]
 c005154:	687a      	ldr	r2, [r7, #4]
 c005156:	429a      	cmp	r2, r3
 c005158:	d903      	bls.n	c005162 <pvPortMalloc+0x9a>
 c00515a:	697b      	ldr	r3, [r7, #20]
 c00515c:	681b      	ldr	r3, [r3, #0]
 c00515e:	2b00      	cmp	r3, #0
 c005160:	d1f1      	bne.n	c005146 <pvPortMalloc+0x7e>
			}

			/* If the end marker was reached then a block of adequate size was
			 * not found. */
			if( pxBlock != pxEnd )
 c005162:	4b30      	ldr	r3, [pc, #192]	@ (c005224 <pvPortMalloc+0x15c>)
 c005164:	681b      	ldr	r3, [r3, #0]
 c005166:	697a      	ldr	r2, [r7, #20]
 c005168:	429a      	cmp	r2, r3
 c00516a:	d048      	beq.n	c0051fe <pvPortMalloc+0x136>
			{
				/* Return the memory space pointed to - jumping over the
				 * BlockLink_t structure at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 c00516c:	693b      	ldr	r3, [r7, #16]
 c00516e:	681b      	ldr	r3, [r3, #0]
 c005170:	2208      	movs	r2, #8
 c005172:	4413      	add	r3, r2
 c005174:	60fb      	str	r3, [r7, #12]

				/* This block is being returned for use so must be taken out
				 * of the list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 c005176:	697b      	ldr	r3, [r7, #20]
 c005178:	681a      	ldr	r2, [r3, #0]
 c00517a:	693b      	ldr	r3, [r7, #16]
 c00517c:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into
				 * two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > secureheapMINIMUM_BLOCK_SIZE )
 c00517e:	697b      	ldr	r3, [r7, #20]
 c005180:	685a      	ldr	r2, [r3, #4]
 c005182:	687b      	ldr	r3, [r7, #4]
 c005184:	1ad2      	subs	r2, r2, r3
 c005186:	2308      	movs	r3, #8
 c005188:	005b      	lsls	r3, r3, #1
 c00518a:	429a      	cmp	r2, r3
 c00518c:	d91c      	bls.n	c0051c8 <pvPortMalloc+0x100>
				{
					/* This block is to be split into two.  Create a new
					 * block following the number of bytes requested. The void
					 * cast is used to prevent byte alignment warnings from the
					 * compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 c00518e:	697a      	ldr	r2, [r7, #20]
 c005190:	687b      	ldr	r3, [r7, #4]
 c005192:	4413      	add	r3, r2
 c005194:	60bb      	str	r3, [r7, #8]
					secureportASSERT( ( ( ( size_t ) pxNewBlockLink ) & secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c005196:	68bb      	ldr	r3, [r7, #8]
 c005198:	f003 0307 	and.w	r3, r3, #7
 c00519c:	2b00      	cmp	r3, #0
 c00519e:	d007      	beq.n	c0051b0 <pvPortMalloc+0xe8>
 c0051a0:	2301      	movs	r3, #1
 c0051a2:	f383 8810 	msr	PRIMASK, r3
 c0051a6:	2301      	movs	r3, #1
 c0051a8:	f383 8890 	msr	PRIMASK_NS, r3
 c0051ac:	bf00      	nop
 c0051ae:	e7fd      	b.n	c0051ac <pvPortMalloc+0xe4>

					/* Calculate the sizes of two blocks split from the single
					 * block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 c0051b0:	697b      	ldr	r3, [r7, #20]
 c0051b2:	685a      	ldr	r2, [r3, #4]
 c0051b4:	687b      	ldr	r3, [r7, #4]
 c0051b6:	1ad2      	subs	r2, r2, r3
 c0051b8:	68bb      	ldr	r3, [r7, #8]
 c0051ba:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 c0051bc:	697b      	ldr	r3, [r7, #20]
 c0051be:	687a      	ldr	r2, [r7, #4]
 c0051c0:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( pxNewBlockLink );
 c0051c2:	68b8      	ldr	r0, [r7, #8]
 c0051c4:	f7ff ff26 	bl	c005014 <prvInsertBlockIntoFreeList>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 c0051c8:	4b18      	ldr	r3, [pc, #96]	@ (c00522c <pvPortMalloc+0x164>)
 c0051ca:	681a      	ldr	r2, [r3, #0]
 c0051cc:	697b      	ldr	r3, [r7, #20]
 c0051ce:	685b      	ldr	r3, [r3, #4]
 c0051d0:	1ad3      	subs	r3, r2, r3
 c0051d2:	4a16      	ldr	r2, [pc, #88]	@ (c00522c <pvPortMalloc+0x164>)
 c0051d4:	6013      	str	r3, [r2, #0]

				if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 c0051d6:	4b15      	ldr	r3, [pc, #84]	@ (c00522c <pvPortMalloc+0x164>)
 c0051d8:	681a      	ldr	r2, [r3, #0]
 c0051da:	4b16      	ldr	r3, [pc, #88]	@ (c005234 <pvPortMalloc+0x16c>)
 c0051dc:	681b      	ldr	r3, [r3, #0]
 c0051de:	429a      	cmp	r2, r3
 c0051e0:	d203      	bcs.n	c0051ea <pvPortMalloc+0x122>
				{
					xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 c0051e2:	4b12      	ldr	r3, [pc, #72]	@ (c00522c <pvPortMalloc+0x164>)
 c0051e4:	681b      	ldr	r3, [r3, #0]
 c0051e6:	4a13      	ldr	r2, [pc, #76]	@ (c005234 <pvPortMalloc+0x16c>)
 c0051e8:	6013      	str	r3, [r2, #0]
					mtCOVERAGE_TEST_MARKER();
				}

				/* The block is being returned - it is allocated and owned by
				 * the application and has no "next" block. */
				pxBlock->xBlockSize |= xBlockAllocatedBit;
 c0051ea:	697b      	ldr	r3, [r7, #20]
 c0051ec:	685a      	ldr	r2, [r3, #4]
 c0051ee:	4b0e      	ldr	r3, [pc, #56]	@ (c005228 <pvPortMalloc+0x160>)
 c0051f0:	681b      	ldr	r3, [r3, #0]
 c0051f2:	431a      	orrs	r2, r3
 c0051f4:	697b      	ldr	r3, [r7, #20]
 c0051f6:	605a      	str	r2, [r3, #4]
				pxBlock->pxNextFreeBlock = NULL;
 c0051f8:	697b      	ldr	r3, [r7, #20]
 c0051fa:	2200      	movs	r2, #0
 c0051fc:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	secureportASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) secureportBYTE_ALIGNMENT_MASK ) == 0 );
 c0051fe:	68fb      	ldr	r3, [r7, #12]
 c005200:	f003 0307 	and.w	r3, r3, #7
 c005204:	2b00      	cmp	r3, #0
 c005206:	d007      	beq.n	c005218 <pvPortMalloc+0x150>
 c005208:	2301      	movs	r3, #1
 c00520a:	f383 8810 	msr	PRIMASK, r3
 c00520e:	2301      	movs	r3, #1
 c005210:	f383 8890 	msr	PRIMASK_NS, r3
 c005214:	bf00      	nop
 c005216:	e7fd      	b.n	c005214 <pvPortMalloc+0x14c>
	return pvReturn;
 c005218:	68fb      	ldr	r3, [r7, #12]
}
 c00521a:	4618      	mov	r0, r3
 c00521c:	3718      	adds	r7, #24
 c00521e:	46bd      	mov	sp, r7
 c005220:	bd80      	pop	{r7, pc}
 c005222:	bf00      	nop
 c005224:	300032c8 	.word	0x300032c8
 c005228:	300032d4 	.word	0x300032d4
 c00522c:	300032cc 	.word	0x300032cc
 c005230:	300032c0 	.word	0x300032c0
 c005234:	300032d0 	.word	0x300032d0

0c005238 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 c005238:	b580      	push	{r7, lr}
 c00523a:	b084      	sub	sp, #16
 c00523c:	af00      	add	r7, sp, #0
 c00523e:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 c005240:	687b      	ldr	r3, [r7, #4]
 c005242:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
 c005244:	687b      	ldr	r3, [r7, #4]
 c005246:	2b00      	cmp	r3, #0
 c005248:	d044      	beq.n	c0052d4 <vPortFree+0x9c>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		 * before it. */
		puc -= xHeapStructSize;
 c00524a:	2308      	movs	r3, #8
 c00524c:	425b      	negs	r3, r3
 c00524e:	68fa      	ldr	r2, [r7, #12]
 c005250:	4413      	add	r3, r2
 c005252:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 c005254:	68fb      	ldr	r3, [r7, #12]
 c005256:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		secureportASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 c005258:	68bb      	ldr	r3, [r7, #8]
 c00525a:	685a      	ldr	r2, [r3, #4]
 c00525c:	4b1f      	ldr	r3, [pc, #124]	@ (c0052dc <vPortFree+0xa4>)
 c00525e:	681b      	ldr	r3, [r3, #0]
 c005260:	4013      	ands	r3, r2
 c005262:	2b00      	cmp	r3, #0
 c005264:	d107      	bne.n	c005276 <vPortFree+0x3e>
 c005266:	2301      	movs	r3, #1
 c005268:	f383 8810 	msr	PRIMASK, r3
 c00526c:	2301      	movs	r3, #1
 c00526e:	f383 8890 	msr	PRIMASK_NS, r3
 c005272:	bf00      	nop
 c005274:	e7fd      	b.n	c005272 <vPortFree+0x3a>
		secureportASSERT( pxLink->pxNextFreeBlock == NULL );
 c005276:	68bb      	ldr	r3, [r7, #8]
 c005278:	681b      	ldr	r3, [r3, #0]
 c00527a:	2b00      	cmp	r3, #0
 c00527c:	d007      	beq.n	c00528e <vPortFree+0x56>
 c00527e:	2301      	movs	r3, #1
 c005280:	f383 8810 	msr	PRIMASK, r3
 c005284:	2301      	movs	r3, #1
 c005286:	f383 8890 	msr	PRIMASK_NS, r3
 c00528a:	bf00      	nop
 c00528c:	e7fd      	b.n	c00528a <vPortFree+0x52>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 c00528e:	68bb      	ldr	r3, [r7, #8]
 c005290:	685a      	ldr	r2, [r3, #4]
 c005292:	4b12      	ldr	r3, [pc, #72]	@ (c0052dc <vPortFree+0xa4>)
 c005294:	681b      	ldr	r3, [r3, #0]
 c005296:	4013      	ands	r3, r2
 c005298:	2b00      	cmp	r3, #0
 c00529a:	d01b      	beq.n	c0052d4 <vPortFree+0x9c>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 c00529c:	68bb      	ldr	r3, [r7, #8]
 c00529e:	681b      	ldr	r3, [r3, #0]
 c0052a0:	2b00      	cmp	r3, #0
 c0052a2:	d117      	bne.n	c0052d4 <vPortFree+0x9c>
			{
				/* The block is being returned to the heap - it is no longer
				 * allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 c0052a4:	68bb      	ldr	r3, [r7, #8]
 c0052a6:	685a      	ldr	r2, [r3, #4]
 c0052a8:	4b0c      	ldr	r3, [pc, #48]	@ (c0052dc <vPortFree+0xa4>)
 c0052aa:	681b      	ldr	r3, [r3, #0]
 c0052ac:	43db      	mvns	r3, r3
 c0052ae:	401a      	ands	r2, r3
 c0052b0:	68bb      	ldr	r3, [r7, #8]
 c0052b2:	605a      	str	r2, [r3, #4]

				secureportDISABLE_NON_SECURE_INTERRUPTS();
 c0052b4:	2301      	movs	r3, #1
 c0052b6:	f383 8890 	msr	PRIMASK_NS, r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 c0052ba:	68bb      	ldr	r3, [r7, #8]
 c0052bc:	685a      	ldr	r2, [r3, #4]
 c0052be:	4b08      	ldr	r3, [pc, #32]	@ (c0052e0 <vPortFree+0xa8>)
 c0052c0:	681b      	ldr	r3, [r3, #0]
 c0052c2:	4413      	add	r3, r2
 c0052c4:	4a06      	ldr	r2, [pc, #24]	@ (c0052e0 <vPortFree+0xa8>)
 c0052c6:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 c0052c8:	68b8      	ldr	r0, [r7, #8]
 c0052ca:	f7ff fea3 	bl	c005014 <prvInsertBlockIntoFreeList>
				}
				secureportENABLE_NON_SECURE_INTERRUPTS();
 c0052ce:	2300      	movs	r3, #0
 c0052d0:	f383 8890 	msr	PRIMASK_NS, r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 c0052d4:	bf00      	nop
 c0052d6:	3710      	adds	r7, #16
 c0052d8:	46bd      	mov	sp, r7
 c0052da:	bd80      	pop	{r7, pc}
 c0052dc:	300032d4 	.word	0x300032d4
 c0052e0:	300032cc 	.word	0x300032cc

0c0052e4 <__acle_se_SecureInit_DePrioritizeNSExceptions>:
#define secureinitNSACR_CP11_POS			( 11UL )
#define secureinitNSACR_CP11_MASK			( 1UL << secureinitNSACR_CP11_POS )
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureInit_DePrioritizeNSExceptions( void )
{
 c0052e4:	b480      	push	{r7}
 c0052e6:	b083      	sub	sp, #12
 c0052e8:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	 /* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c0052ea:	f3ef 8305 	mrs	r3, IPSR
 c0052ee:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c0052f0:	687b      	ldr	r3, [r7, #4]
 c0052f2:	2b00      	cmp	r3, #0
 c0052f4:	d008      	beq.n	c005308 <__acle_se_SecureInit_DePrioritizeNSExceptions+0x24>
	{
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c0052f6:	4b21      	ldr	r3, [pc, #132]	@ (c00537c <__acle_se_SecureInit_DePrioritizeNSExceptions+0x98>)
 c0052f8:	681b      	ldr	r3, [r3, #0]
									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
 c0052fa:	b29b      	uxth	r3, r3
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c0052fc:	4a1f      	ldr	r2, [pc, #124]	@ (c00537c <__acle_se_SecureInit_DePrioritizeNSExceptions+0x98>)
									( ( 0x05FAUL << secureinitSCB_AIRCR_VECTKEY_POS ) & secureinitSCB_AIRCR_VECTKEY_MASK ) |
 c0052fe:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 c005302:	f443 3310 	orr.w	r3, r3, #147456	@ 0x24000
		*( secureinitSCB_AIRCR ) =	( *( secureinitSCB_AIRCR ) & ~( secureinitSCB_AIRCR_VECTKEY_MASK | secureinitSCB_AIRCR_PRIS_MASK ) ) |
 c005306:	6013      	str	r3, [r2, #0]
									( ( 0x1UL	<< secureinitSCB_AIRCR_PRIS_POS )	& secureinitSCB_AIRCR_PRIS_MASK );
	}
}
 c005308:	bf00      	nop
 c00530a:	370c      	adds	r7, #12
 c00530c:	46bd      	mov	sp, r7
 c00530e:	f85d 7b04 	ldr.w	r7, [sp], #4
 c005312:	4670      	mov	r0, lr
 c005314:	4671      	mov	r1, lr
 c005316:	4672      	mov	r2, lr
 c005318:	4673      	mov	r3, lr
 c00531a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c00531e:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c005322:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c005326:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c00532a:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c00532e:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c005332:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c005336:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c00533a:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c00533e:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c005342:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c005346:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c00534a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c00534e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c005352:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c005356:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c00535a:	f38e 8c00 	msr	CPSR_fs, lr
 c00535e:	b410      	push	{r4}
 c005360:	eef1 ca10 	vmrs	ip, fpscr
 c005364:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c005368:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00536c:	ea0c 0c04 	and.w	ip, ip, r4
 c005370:	eee1 ca10 	vmsr	fpscr, ip
 c005374:	bc10      	pop	{r4}
 c005376:	46f4      	mov	ip, lr
 c005378:	4774      	bxns	lr
 c00537a:	bf00      	nop
 c00537c:	e000ed0c 	.word	0xe000ed0c

0c005380 <__acle_se_SecureInit_EnableNSFPUAccess>:
/*-----------------------------------------------------------*/

secureportNON_SECURE_CALLABLE void SecureInit_EnableNSFPUAccess( void )
{
 c005380:	b480      	push	{r7}
 c005382:	b083      	sub	sp, #12
 c005384:	af00      	add	r7, sp, #0
	uint32_t ulIPSR;

	 /* Read the Interrupt Program Status Register (IPSR) value. */
	secureportREAD_IPSR( ulIPSR );
 c005386:	f3ef 8305 	mrs	r3, IPSR
 c00538a:	607b      	str	r3, [r7, #4]

	/* Do nothing if the processor is running in the Thread Mode. IPSR is zero
	 * when the processor is running in the Thread Mode. */
	if( ulIPSR != 0 )
 c00538c:	687b      	ldr	r3, [r7, #4]
 c00538e:	2b00      	cmp	r3, #0
 c005390:	d011      	beq.n	c0053b6 <__acle_se_SecureInit_EnableNSFPUAccess+0x36>
	{
		/* CP10 = 1 ==> Non-secure access to the Floating Point Unit is
		 * permitted. CP11 should be programmed to the same value as CP10. */
		*( secureinitNSACR ) |= ( secureinitNSACR_CP10_MASK | secureinitNSACR_CP11_MASK );
 c005392:	4b25      	ldr	r3, [pc, #148]	@ (c005428 <__acle_se_SecureInit_EnableNSFPUAccess+0xa8>)
 c005394:	681b      	ldr	r3, [r3, #0]
 c005396:	4a24      	ldr	r2, [pc, #144]	@ (c005428 <__acle_se_SecureInit_EnableNSFPUAccess+0xa8>)
 c005398:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c00539c:	6013      	str	r3, [r2, #0]

		/* LSPENS = 0 ==> LSPEN is writable fron non-secure state. This ensures
		 * that we can enable/disable lazy stacking in port.c file. */
		*( secureinitFPCCR ) &= ~ ( secureinitFPCCR_LSPENS_MASK );
 c00539e:	4b23      	ldr	r3, [pc, #140]	@ (c00542c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053a0:	681b      	ldr	r3, [r3, #0]
 c0053a2:	4a22      	ldr	r2, [pc, #136]	@ (c00542c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053a4:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 c0053a8:	6013      	str	r3, [r2, #0]

		/* TS = 1 ==> Treat FP registers as secure i.e. callee saved FP
		 * registers (S16-S31) are also pushed to stack on exception entry and
		 * restored on exception return. */
		*( secureinitFPCCR ) |= ( secureinitFPCCR_TS_MASK );
 c0053aa:	4b20      	ldr	r3, [pc, #128]	@ (c00542c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053ac:	681b      	ldr	r3, [r3, #0]
 c0053ae:	4a1f      	ldr	r2, [pc, #124]	@ (c00542c <__acle_se_SecureInit_EnableNSFPUAccess+0xac>)
 c0053b0:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 c0053b4:	6013      	str	r3, [r2, #0]
	}
}
 c0053b6:	bf00      	nop
 c0053b8:	370c      	adds	r7, #12
 c0053ba:	46bd      	mov	sp, r7
 c0053bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 c0053c0:	4670      	mov	r0, lr
 c0053c2:	4671      	mov	r1, lr
 c0053c4:	4672      	mov	r2, lr
 c0053c6:	4673      	mov	r3, lr
 c0053c8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 c0053cc:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 c0053d0:	eeb7 1a00 	vmov.f32	s2, #112	@ 0x3f800000  1.0
 c0053d4:	eef7 1a00 	vmov.f32	s3, #112	@ 0x3f800000  1.0
 c0053d8:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 c0053dc:	eef7 2a00 	vmov.f32	s5, #112	@ 0x3f800000  1.0
 c0053e0:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 c0053e4:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 c0053e8:	eeb7 4a00 	vmov.f32	s8, #112	@ 0x3f800000  1.0
 c0053ec:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 c0053f0:	eeb7 5a00 	vmov.f32	s10, #112	@ 0x3f800000  1.0
 c0053f4:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 c0053f8:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 c0053fc:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 c005400:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 c005404:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 c005408:	f38e 8c00 	msr	CPSR_fs, lr
 c00540c:	b410      	push	{r4}
 c00540e:	eef1 ca10 	vmrs	ip, fpscr
 c005412:	f64f 7460 	movw	r4, #65376	@ 0xff60
 c005416:	f6c0 74ff 	movt	r4, #4095	@ 0xfff
 c00541a:	ea0c 0c04 	and.w	ip, ip, r4
 c00541e:	eee1 ca10 	vmsr	fpscr, ip
 c005422:	bc10      	pop	{r4}
 c005424:	46f4      	mov	ip, lr
 c005426:	4774      	bxns	lr
 c005428:	e000ed8c 	.word	0xe000ed8c
 c00542c:	e000ef34 	.word	0xe000ef34

0c005430 <malloc>:
 c005430:	4b02      	ldr	r3, [pc, #8]	@ (c00543c <malloc+0xc>)
 c005432:	4601      	mov	r1, r0
 c005434:	6818      	ldr	r0, [r3, #0]
 c005436:	f000 b825 	b.w	c005484 <_malloc_r>
 c00543a:	bf00      	nop
 c00543c:	3000004c 	.word	0x3000004c

0c005440 <sbrk_aligned>:
 c005440:	b570      	push	{r4, r5, r6, lr}
 c005442:	4e0f      	ldr	r6, [pc, #60]	@ (c005480 <sbrk_aligned+0x40>)
 c005444:	460c      	mov	r4, r1
 c005446:	4605      	mov	r5, r0
 c005448:	6831      	ldr	r1, [r6, #0]
 c00544a:	b911      	cbnz	r1, c005452 <sbrk_aligned+0x12>
 c00544c:	f000 fb6c 	bl	c005b28 <_sbrk_r>
 c005450:	6030      	str	r0, [r6, #0]
 c005452:	4621      	mov	r1, r4
 c005454:	4628      	mov	r0, r5
 c005456:	f000 fb67 	bl	c005b28 <_sbrk_r>
 c00545a:	1c43      	adds	r3, r0, #1
 c00545c:	d103      	bne.n	c005466 <sbrk_aligned+0x26>
 c00545e:	f04f 34ff 	mov.w	r4, #4294967295
 c005462:	4620      	mov	r0, r4
 c005464:	bd70      	pop	{r4, r5, r6, pc}
 c005466:	1cc4      	adds	r4, r0, #3
 c005468:	f024 0403 	bic.w	r4, r4, #3
 c00546c:	42a0      	cmp	r0, r4
 c00546e:	d0f8      	beq.n	c005462 <sbrk_aligned+0x22>
 c005470:	1a21      	subs	r1, r4, r0
 c005472:	4628      	mov	r0, r5
 c005474:	f000 fb58 	bl	c005b28 <_sbrk_r>
 c005478:	3001      	adds	r0, #1
 c00547a:	d1f2      	bne.n	c005462 <sbrk_aligned+0x22>
 c00547c:	e7ef      	b.n	c00545e <sbrk_aligned+0x1e>
 c00547e:	bf00      	nop
 c005480:	300032d8 	.word	0x300032d8

0c005484 <_malloc_r>:
 c005484:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c005488:	1ccd      	adds	r5, r1, #3
 c00548a:	4606      	mov	r6, r0
 c00548c:	f025 0503 	bic.w	r5, r5, #3
 c005490:	3508      	adds	r5, #8
 c005492:	2d0c      	cmp	r5, #12
 c005494:	bf38      	it	cc
 c005496:	250c      	movcc	r5, #12
 c005498:	2d00      	cmp	r5, #0
 c00549a:	db01      	blt.n	c0054a0 <_malloc_r+0x1c>
 c00549c:	42a9      	cmp	r1, r5
 c00549e:	d904      	bls.n	c0054aa <_malloc_r+0x26>
 c0054a0:	230c      	movs	r3, #12
 c0054a2:	6033      	str	r3, [r6, #0]
 c0054a4:	2000      	movs	r0, #0
 c0054a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c0054aa:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ c005580 <_malloc_r+0xfc>
 c0054ae:	f000 f869 	bl	c005584 <__malloc_lock>
 c0054b2:	f8d8 3000 	ldr.w	r3, [r8]
 c0054b6:	461c      	mov	r4, r3
 c0054b8:	bb44      	cbnz	r4, c00550c <_malloc_r+0x88>
 c0054ba:	4629      	mov	r1, r5
 c0054bc:	4630      	mov	r0, r6
 c0054be:	f7ff ffbf 	bl	c005440 <sbrk_aligned>
 c0054c2:	1c43      	adds	r3, r0, #1
 c0054c4:	4604      	mov	r4, r0
 c0054c6:	d158      	bne.n	c00557a <_malloc_r+0xf6>
 c0054c8:	f8d8 4000 	ldr.w	r4, [r8]
 c0054cc:	4627      	mov	r7, r4
 c0054ce:	2f00      	cmp	r7, #0
 c0054d0:	d143      	bne.n	c00555a <_malloc_r+0xd6>
 c0054d2:	2c00      	cmp	r4, #0
 c0054d4:	d04b      	beq.n	c00556e <_malloc_r+0xea>
 c0054d6:	6823      	ldr	r3, [r4, #0]
 c0054d8:	4639      	mov	r1, r7
 c0054da:	4630      	mov	r0, r6
 c0054dc:	eb04 0903 	add.w	r9, r4, r3
 c0054e0:	f000 fb22 	bl	c005b28 <_sbrk_r>
 c0054e4:	4581      	cmp	r9, r0
 c0054e6:	d142      	bne.n	c00556e <_malloc_r+0xea>
 c0054e8:	6821      	ldr	r1, [r4, #0]
 c0054ea:	4630      	mov	r0, r6
 c0054ec:	1a6d      	subs	r5, r5, r1
 c0054ee:	4629      	mov	r1, r5
 c0054f0:	f7ff ffa6 	bl	c005440 <sbrk_aligned>
 c0054f4:	3001      	adds	r0, #1
 c0054f6:	d03a      	beq.n	c00556e <_malloc_r+0xea>
 c0054f8:	6823      	ldr	r3, [r4, #0]
 c0054fa:	442b      	add	r3, r5
 c0054fc:	6023      	str	r3, [r4, #0]
 c0054fe:	f8d8 3000 	ldr.w	r3, [r8]
 c005502:	685a      	ldr	r2, [r3, #4]
 c005504:	bb62      	cbnz	r2, c005560 <_malloc_r+0xdc>
 c005506:	f8c8 7000 	str.w	r7, [r8]
 c00550a:	e00f      	b.n	c00552c <_malloc_r+0xa8>
 c00550c:	6822      	ldr	r2, [r4, #0]
 c00550e:	1b52      	subs	r2, r2, r5
 c005510:	d420      	bmi.n	c005554 <_malloc_r+0xd0>
 c005512:	2a0b      	cmp	r2, #11
 c005514:	d917      	bls.n	c005546 <_malloc_r+0xc2>
 c005516:	1961      	adds	r1, r4, r5
 c005518:	42a3      	cmp	r3, r4
 c00551a:	6025      	str	r5, [r4, #0]
 c00551c:	bf18      	it	ne
 c00551e:	6059      	strne	r1, [r3, #4]
 c005520:	6863      	ldr	r3, [r4, #4]
 c005522:	bf08      	it	eq
 c005524:	f8c8 1000 	streq.w	r1, [r8]
 c005528:	5162      	str	r2, [r4, r5]
 c00552a:	604b      	str	r3, [r1, #4]
 c00552c:	4630      	mov	r0, r6
 c00552e:	f000 f82f 	bl	c005590 <__malloc_unlock>
 c005532:	f104 000b 	add.w	r0, r4, #11
 c005536:	1d23      	adds	r3, r4, #4
 c005538:	f020 0007 	bic.w	r0, r0, #7
 c00553c:	1ac2      	subs	r2, r0, r3
 c00553e:	bf1c      	itt	ne
 c005540:	1a1b      	subne	r3, r3, r0
 c005542:	50a3      	strne	r3, [r4, r2]
 c005544:	e7af      	b.n	c0054a6 <_malloc_r+0x22>
 c005546:	6862      	ldr	r2, [r4, #4]
 c005548:	42a3      	cmp	r3, r4
 c00554a:	bf0c      	ite	eq
 c00554c:	f8c8 2000 	streq.w	r2, [r8]
 c005550:	605a      	strne	r2, [r3, #4]
 c005552:	e7eb      	b.n	c00552c <_malloc_r+0xa8>
 c005554:	4623      	mov	r3, r4
 c005556:	6864      	ldr	r4, [r4, #4]
 c005558:	e7ae      	b.n	c0054b8 <_malloc_r+0x34>
 c00555a:	463c      	mov	r4, r7
 c00555c:	687f      	ldr	r7, [r7, #4]
 c00555e:	e7b6      	b.n	c0054ce <_malloc_r+0x4a>
 c005560:	461a      	mov	r2, r3
 c005562:	685b      	ldr	r3, [r3, #4]
 c005564:	42a3      	cmp	r3, r4
 c005566:	d1fb      	bne.n	c005560 <_malloc_r+0xdc>
 c005568:	2300      	movs	r3, #0
 c00556a:	6053      	str	r3, [r2, #4]
 c00556c:	e7de      	b.n	c00552c <_malloc_r+0xa8>
 c00556e:	230c      	movs	r3, #12
 c005570:	4630      	mov	r0, r6
 c005572:	6033      	str	r3, [r6, #0]
 c005574:	f000 f80c 	bl	c005590 <__malloc_unlock>
 c005578:	e794      	b.n	c0054a4 <_malloc_r+0x20>
 c00557a:	6005      	str	r5, [r0, #0]
 c00557c:	e7d6      	b.n	c00552c <_malloc_r+0xa8>
 c00557e:	bf00      	nop
 c005580:	300032dc 	.word	0x300032dc

0c005584 <__malloc_lock>:
 c005584:	4801      	ldr	r0, [pc, #4]	@ (c00558c <__malloc_lock+0x8>)
 c005586:	f000 bb1c 	b.w	c005bc2 <__retarget_lock_acquire_recursive>
 c00558a:	bf00      	nop
 c00558c:	30003420 	.word	0x30003420

0c005590 <__malloc_unlock>:
 c005590:	4801      	ldr	r0, [pc, #4]	@ (c005598 <__malloc_unlock+0x8>)
 c005592:	f000 bb17 	b.w	c005bc4 <__retarget_lock_release_recursive>
 c005596:	bf00      	nop
 c005598:	30003420 	.word	0x30003420

0c00559c <srand>:
 c00559c:	b538      	push	{r3, r4, r5, lr}
 c00559e:	4b10      	ldr	r3, [pc, #64]	@ (c0055e0 <srand+0x44>)
 c0055a0:	4604      	mov	r4, r0
 c0055a2:	681d      	ldr	r5, [r3, #0]
 c0055a4:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 c0055a6:	b9b3      	cbnz	r3, c0055d6 <srand+0x3a>
 c0055a8:	2018      	movs	r0, #24
 c0055aa:	f7ff ff41 	bl	c005430 <malloc>
 c0055ae:	4602      	mov	r2, r0
 c0055b0:	6328      	str	r0, [r5, #48]	@ 0x30
 c0055b2:	b920      	cbnz	r0, c0055be <srand+0x22>
 c0055b4:	4b0b      	ldr	r3, [pc, #44]	@ (c0055e4 <srand+0x48>)
 c0055b6:	2146      	movs	r1, #70	@ 0x46
 c0055b8:	480b      	ldr	r0, [pc, #44]	@ (c0055e8 <srand+0x4c>)
 c0055ba:	f000 fb11 	bl	c005be0 <__assert_func>
 c0055be:	490b      	ldr	r1, [pc, #44]	@ (c0055ec <srand+0x50>)
 c0055c0:	4b0b      	ldr	r3, [pc, #44]	@ (c0055f0 <srand+0x54>)
 c0055c2:	e9c0 1300 	strd	r1, r3, [r0]
 c0055c6:	4b0b      	ldr	r3, [pc, #44]	@ (c0055f4 <srand+0x58>)
 c0055c8:	2100      	movs	r1, #0
 c0055ca:	6083      	str	r3, [r0, #8]
 c0055cc:	230b      	movs	r3, #11
 c0055ce:	8183      	strh	r3, [r0, #12]
 c0055d0:	2001      	movs	r0, #1
 c0055d2:	e9c2 0104 	strd	r0, r1, [r2, #16]
 c0055d6:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 c0055d8:	2200      	movs	r2, #0
 c0055da:	611c      	str	r4, [r3, #16]
 c0055dc:	615a      	str	r2, [r3, #20]
 c0055de:	bd38      	pop	{r3, r4, r5, pc}
 c0055e0:	3000004c 	.word	0x3000004c
 c0055e4:	0c006cac 	.word	0x0c006cac
 c0055e8:	0c006cc3 	.word	0x0c006cc3
 c0055ec:	abcd330e 	.word	0xabcd330e
 c0055f0:	e66d1234 	.word	0xe66d1234
 c0055f4:	0005deec 	.word	0x0005deec

0c0055f8 <rand>:
 c0055f8:	4b16      	ldr	r3, [pc, #88]	@ (c005654 <rand+0x5c>)
 c0055fa:	b510      	push	{r4, lr}
 c0055fc:	681c      	ldr	r4, [r3, #0]
 c0055fe:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c005600:	b9b3      	cbnz	r3, c005630 <rand+0x38>
 c005602:	2018      	movs	r0, #24
 c005604:	f7ff ff14 	bl	c005430 <malloc>
 c005608:	4602      	mov	r2, r0
 c00560a:	6320      	str	r0, [r4, #48]	@ 0x30
 c00560c:	b920      	cbnz	r0, c005618 <rand+0x20>
 c00560e:	4b12      	ldr	r3, [pc, #72]	@ (c005658 <rand+0x60>)
 c005610:	2152      	movs	r1, #82	@ 0x52
 c005612:	4812      	ldr	r0, [pc, #72]	@ (c00565c <rand+0x64>)
 c005614:	f000 fae4 	bl	c005be0 <__assert_func>
 c005618:	4911      	ldr	r1, [pc, #68]	@ (c005660 <rand+0x68>)
 c00561a:	4b12      	ldr	r3, [pc, #72]	@ (c005664 <rand+0x6c>)
 c00561c:	e9c0 1300 	strd	r1, r3, [r0]
 c005620:	4b11      	ldr	r3, [pc, #68]	@ (c005668 <rand+0x70>)
 c005622:	2100      	movs	r1, #0
 c005624:	6083      	str	r3, [r0, #8]
 c005626:	230b      	movs	r3, #11
 c005628:	8183      	strh	r3, [r0, #12]
 c00562a:	2001      	movs	r0, #1
 c00562c:	e9c2 0104 	strd	r0, r1, [r2, #16]
 c005630:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 c005632:	480e      	ldr	r0, [pc, #56]	@ (c00566c <rand+0x74>)
 c005634:	690b      	ldr	r3, [r1, #16]
 c005636:	694c      	ldr	r4, [r1, #20]
 c005638:	4a0d      	ldr	r2, [pc, #52]	@ (c005670 <rand+0x78>)
 c00563a:	4358      	muls	r0, r3
 c00563c:	fb02 0004 	mla	r0, r2, r4, r0
 c005640:	fba3 3202 	umull	r3, r2, r3, r2
 c005644:	3301      	adds	r3, #1
 c005646:	eb40 0002 	adc.w	r0, r0, r2
 c00564a:	e9c1 3004 	strd	r3, r0, [r1, #16]
 c00564e:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 c005652:	bd10      	pop	{r4, pc}
 c005654:	3000004c 	.word	0x3000004c
 c005658:	0c006cac 	.word	0x0c006cac
 c00565c:	0c006cc3 	.word	0x0c006cc3
 c005660:	abcd330e 	.word	0xabcd330e
 c005664:	e66d1234 	.word	0xe66d1234
 c005668:	0005deec 	.word	0x0005deec
 c00566c:	5851f42d 	.word	0x5851f42d
 c005670:	4c957f2d 	.word	0x4c957f2d

0c005674 <std>:
 c005674:	2300      	movs	r3, #0
 c005676:	b510      	push	{r4, lr}
 c005678:	4604      	mov	r4, r0
 c00567a:	6083      	str	r3, [r0, #8]
 c00567c:	8181      	strh	r1, [r0, #12]
 c00567e:	4619      	mov	r1, r3
 c005680:	6643      	str	r3, [r0, #100]	@ 0x64
 c005682:	81c2      	strh	r2, [r0, #14]
 c005684:	2208      	movs	r2, #8
 c005686:	6183      	str	r3, [r0, #24]
 c005688:	e9c0 3300 	strd	r3, r3, [r0]
 c00568c:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c005690:	305c      	adds	r0, #92	@ 0x5c
 c005692:	f000 f9f9 	bl	c005a88 <memset>
 c005696:	4b0d      	ldr	r3, [pc, #52]	@ (c0056cc <std+0x58>)
 c005698:	6224      	str	r4, [r4, #32]
 c00569a:	6263      	str	r3, [r4, #36]	@ 0x24
 c00569c:	4b0c      	ldr	r3, [pc, #48]	@ (c0056d0 <std+0x5c>)
 c00569e:	62a3      	str	r3, [r4, #40]	@ 0x28
 c0056a0:	4b0c      	ldr	r3, [pc, #48]	@ (c0056d4 <std+0x60>)
 c0056a2:	62e3      	str	r3, [r4, #44]	@ 0x2c
 c0056a4:	4b0c      	ldr	r3, [pc, #48]	@ (c0056d8 <std+0x64>)
 c0056a6:	6323      	str	r3, [r4, #48]	@ 0x30
 c0056a8:	4b0c      	ldr	r3, [pc, #48]	@ (c0056dc <std+0x68>)
 c0056aa:	429c      	cmp	r4, r3
 c0056ac:	d006      	beq.n	c0056bc <std+0x48>
 c0056ae:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 c0056b2:	4294      	cmp	r4, r2
 c0056b4:	d002      	beq.n	c0056bc <std+0x48>
 c0056b6:	33d0      	adds	r3, #208	@ 0xd0
 c0056b8:	429c      	cmp	r4, r3
 c0056ba:	d105      	bne.n	c0056c8 <std+0x54>
 c0056bc:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 c0056c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0056c4:	f000 ba7c 	b.w	c005bc0 <__retarget_lock_init_recursive>
 c0056c8:	bd10      	pop	{r4, pc}
 c0056ca:	bf00      	nop
 c0056cc:	0c0058d9 	.word	0x0c0058d9
 c0056d0:	0c0058fb 	.word	0x0c0058fb
 c0056d4:	0c005933 	.word	0x0c005933
 c0056d8:	0c005957 	.word	0x0c005957
 c0056dc:	300032e0 	.word	0x300032e0

0c0056e0 <stdio_exit_handler>:
 c0056e0:	4a02      	ldr	r2, [pc, #8]	@ (c0056ec <stdio_exit_handler+0xc>)
 c0056e2:	4903      	ldr	r1, [pc, #12]	@ (c0056f0 <stdio_exit_handler+0x10>)
 c0056e4:	4803      	ldr	r0, [pc, #12]	@ (c0056f4 <stdio_exit_handler+0x14>)
 c0056e6:	f000 b869 	b.w	c0057bc <_fwalk_sglue>
 c0056ea:	bf00      	nop
 c0056ec:	30000040 	.word	0x30000040
 c0056f0:	0c00635d 	.word	0x0c00635d
 c0056f4:	30000050 	.word	0x30000050

0c0056f8 <cleanup_stdio>:
 c0056f8:	6841      	ldr	r1, [r0, #4]
 c0056fa:	4b0c      	ldr	r3, [pc, #48]	@ (c00572c <cleanup_stdio+0x34>)
 c0056fc:	4299      	cmp	r1, r3
 c0056fe:	b510      	push	{r4, lr}
 c005700:	4604      	mov	r4, r0
 c005702:	d001      	beq.n	c005708 <cleanup_stdio+0x10>
 c005704:	f000 fe2a 	bl	c00635c <_fflush_r>
 c005708:	68a1      	ldr	r1, [r4, #8]
 c00570a:	4b09      	ldr	r3, [pc, #36]	@ (c005730 <cleanup_stdio+0x38>)
 c00570c:	4299      	cmp	r1, r3
 c00570e:	d002      	beq.n	c005716 <cleanup_stdio+0x1e>
 c005710:	4620      	mov	r0, r4
 c005712:	f000 fe23 	bl	c00635c <_fflush_r>
 c005716:	68e1      	ldr	r1, [r4, #12]
 c005718:	4b06      	ldr	r3, [pc, #24]	@ (c005734 <cleanup_stdio+0x3c>)
 c00571a:	4299      	cmp	r1, r3
 c00571c:	d004      	beq.n	c005728 <cleanup_stdio+0x30>
 c00571e:	4620      	mov	r0, r4
 c005720:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c005724:	f000 be1a 	b.w	c00635c <_fflush_r>
 c005728:	bd10      	pop	{r4, pc}
 c00572a:	bf00      	nop
 c00572c:	300032e0 	.word	0x300032e0
 c005730:	30003348 	.word	0x30003348
 c005734:	300033b0 	.word	0x300033b0

0c005738 <global_stdio_init.part.0>:
 c005738:	b510      	push	{r4, lr}
 c00573a:	4b0b      	ldr	r3, [pc, #44]	@ (c005768 <global_stdio_init.part.0+0x30>)
 c00573c:	2104      	movs	r1, #4
 c00573e:	4c0b      	ldr	r4, [pc, #44]	@ (c00576c <global_stdio_init.part.0+0x34>)
 c005740:	4a0b      	ldr	r2, [pc, #44]	@ (c005770 <global_stdio_init.part.0+0x38>)
 c005742:	4620      	mov	r0, r4
 c005744:	601a      	str	r2, [r3, #0]
 c005746:	2200      	movs	r2, #0
 c005748:	f7ff ff94 	bl	c005674 <std>
 c00574c:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 c005750:	2201      	movs	r2, #1
 c005752:	2109      	movs	r1, #9
 c005754:	f7ff ff8e 	bl	c005674 <std>
 c005758:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 c00575c:	2202      	movs	r2, #2
 c00575e:	2112      	movs	r1, #18
 c005760:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c005764:	f7ff bf86 	b.w	c005674 <std>
 c005768:	30003418 	.word	0x30003418
 c00576c:	300032e0 	.word	0x300032e0
 c005770:	0c0056e1 	.word	0x0c0056e1

0c005774 <__sfp_lock_acquire>:
 c005774:	4801      	ldr	r0, [pc, #4]	@ (c00577c <__sfp_lock_acquire+0x8>)
 c005776:	f000 ba24 	b.w	c005bc2 <__retarget_lock_acquire_recursive>
 c00577a:	bf00      	nop
 c00577c:	30003421 	.word	0x30003421

0c005780 <__sfp_lock_release>:
 c005780:	4801      	ldr	r0, [pc, #4]	@ (c005788 <__sfp_lock_release+0x8>)
 c005782:	f000 ba1f 	b.w	c005bc4 <__retarget_lock_release_recursive>
 c005786:	bf00      	nop
 c005788:	30003421 	.word	0x30003421

0c00578c <__sinit>:
 c00578c:	b510      	push	{r4, lr}
 c00578e:	4604      	mov	r4, r0
 c005790:	f7ff fff0 	bl	c005774 <__sfp_lock_acquire>
 c005794:	6a23      	ldr	r3, [r4, #32]
 c005796:	b11b      	cbz	r3, c0057a0 <__sinit+0x14>
 c005798:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c00579c:	f7ff bff0 	b.w	c005780 <__sfp_lock_release>
 c0057a0:	4b04      	ldr	r3, [pc, #16]	@ (c0057b4 <__sinit+0x28>)
 c0057a2:	6223      	str	r3, [r4, #32]
 c0057a4:	4b04      	ldr	r3, [pc, #16]	@ (c0057b8 <__sinit+0x2c>)
 c0057a6:	681b      	ldr	r3, [r3, #0]
 c0057a8:	2b00      	cmp	r3, #0
 c0057aa:	d1f5      	bne.n	c005798 <__sinit+0xc>
 c0057ac:	f7ff ffc4 	bl	c005738 <global_stdio_init.part.0>
 c0057b0:	e7f2      	b.n	c005798 <__sinit+0xc>
 c0057b2:	bf00      	nop
 c0057b4:	0c0056f9 	.word	0x0c0056f9
 c0057b8:	30003418 	.word	0x30003418

0c0057bc <_fwalk_sglue>:
 c0057bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0057c0:	4607      	mov	r7, r0
 c0057c2:	4688      	mov	r8, r1
 c0057c4:	4614      	mov	r4, r2
 c0057c6:	2600      	movs	r6, #0
 c0057c8:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 c0057cc:	f1b9 0901 	subs.w	r9, r9, #1
 c0057d0:	d505      	bpl.n	c0057de <_fwalk_sglue+0x22>
 c0057d2:	6824      	ldr	r4, [r4, #0]
 c0057d4:	2c00      	cmp	r4, #0
 c0057d6:	d1f7      	bne.n	c0057c8 <_fwalk_sglue+0xc>
 c0057d8:	4630      	mov	r0, r6
 c0057da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c0057de:	89ab      	ldrh	r3, [r5, #12]
 c0057e0:	2b01      	cmp	r3, #1
 c0057e2:	d907      	bls.n	c0057f4 <_fwalk_sglue+0x38>
 c0057e4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c0057e8:	3301      	adds	r3, #1
 c0057ea:	d003      	beq.n	c0057f4 <_fwalk_sglue+0x38>
 c0057ec:	4629      	mov	r1, r5
 c0057ee:	4638      	mov	r0, r7
 c0057f0:	47c0      	blx	r8
 c0057f2:	4306      	orrs	r6, r0
 c0057f4:	3568      	adds	r5, #104	@ 0x68
 c0057f6:	e7e9      	b.n	c0057cc <_fwalk_sglue+0x10>

0c0057f8 <iprintf>:
 c0057f8:	b40f      	push	{r0, r1, r2, r3}
 c0057fa:	b507      	push	{r0, r1, r2, lr}
 c0057fc:	4906      	ldr	r1, [pc, #24]	@ (c005818 <iprintf+0x20>)
 c0057fe:	ab04      	add	r3, sp, #16
 c005800:	6808      	ldr	r0, [r1, #0]
 c005802:	f853 2b04 	ldr.w	r2, [r3], #4
 c005806:	6881      	ldr	r1, [r0, #8]
 c005808:	9301      	str	r3, [sp, #4]
 c00580a:	f000 fa7b 	bl	c005d04 <_vfiprintf_r>
 c00580e:	b003      	add	sp, #12
 c005810:	f85d eb04 	ldr.w	lr, [sp], #4
 c005814:	b004      	add	sp, #16
 c005816:	4770      	bx	lr
 c005818:	3000004c 	.word	0x3000004c

0c00581c <_puts_r>:
 c00581c:	6a03      	ldr	r3, [r0, #32]
 c00581e:	b570      	push	{r4, r5, r6, lr}
 c005820:	4605      	mov	r5, r0
 c005822:	460e      	mov	r6, r1
 c005824:	6884      	ldr	r4, [r0, #8]
 c005826:	b90b      	cbnz	r3, c00582c <_puts_r+0x10>
 c005828:	f7ff ffb0 	bl	c00578c <__sinit>
 c00582c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c00582e:	07db      	lsls	r3, r3, #31
 c005830:	d405      	bmi.n	c00583e <_puts_r+0x22>
 c005832:	89a3      	ldrh	r3, [r4, #12]
 c005834:	0598      	lsls	r0, r3, #22
 c005836:	d402      	bmi.n	c00583e <_puts_r+0x22>
 c005838:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c00583a:	f000 f9c2 	bl	c005bc2 <__retarget_lock_acquire_recursive>
 c00583e:	89a3      	ldrh	r3, [r4, #12]
 c005840:	0719      	lsls	r1, r3, #28
 c005842:	d502      	bpl.n	c00584a <_puts_r+0x2e>
 c005844:	6923      	ldr	r3, [r4, #16]
 c005846:	2b00      	cmp	r3, #0
 c005848:	d135      	bne.n	c0058b6 <_puts_r+0x9a>
 c00584a:	4621      	mov	r1, r4
 c00584c:	4628      	mov	r0, r5
 c00584e:	f000 f8c5 	bl	c0059dc <__swsetup_r>
 c005852:	b380      	cbz	r0, c0058b6 <_puts_r+0x9a>
 c005854:	f04f 35ff 	mov.w	r5, #4294967295
 c005858:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c00585a:	07da      	lsls	r2, r3, #31
 c00585c:	d405      	bmi.n	c00586a <_puts_r+0x4e>
 c00585e:	89a3      	ldrh	r3, [r4, #12]
 c005860:	059b      	lsls	r3, r3, #22
 c005862:	d402      	bmi.n	c00586a <_puts_r+0x4e>
 c005864:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c005866:	f000 f9ad 	bl	c005bc4 <__retarget_lock_release_recursive>
 c00586a:	4628      	mov	r0, r5
 c00586c:	bd70      	pop	{r4, r5, r6, pc}
 c00586e:	2b00      	cmp	r3, #0
 c005870:	da04      	bge.n	c00587c <_puts_r+0x60>
 c005872:	69a2      	ldr	r2, [r4, #24]
 c005874:	429a      	cmp	r2, r3
 c005876:	dc17      	bgt.n	c0058a8 <_puts_r+0x8c>
 c005878:	290a      	cmp	r1, #10
 c00587a:	d015      	beq.n	c0058a8 <_puts_r+0x8c>
 c00587c:	6823      	ldr	r3, [r4, #0]
 c00587e:	1c5a      	adds	r2, r3, #1
 c005880:	6022      	str	r2, [r4, #0]
 c005882:	7019      	strb	r1, [r3, #0]
 c005884:	68a3      	ldr	r3, [r4, #8]
 c005886:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c00588a:	3b01      	subs	r3, #1
 c00588c:	60a3      	str	r3, [r4, #8]
 c00588e:	2900      	cmp	r1, #0
 c005890:	d1ed      	bne.n	c00586e <_puts_r+0x52>
 c005892:	2b00      	cmp	r3, #0
 c005894:	da11      	bge.n	c0058ba <_puts_r+0x9e>
 c005896:	4622      	mov	r2, r4
 c005898:	210a      	movs	r1, #10
 c00589a:	4628      	mov	r0, r5
 c00589c:	f000 f85f 	bl	c00595e <__swbuf_r>
 c0058a0:	3001      	adds	r0, #1
 c0058a2:	d0d7      	beq.n	c005854 <_puts_r+0x38>
 c0058a4:	250a      	movs	r5, #10
 c0058a6:	e7d7      	b.n	c005858 <_puts_r+0x3c>
 c0058a8:	4622      	mov	r2, r4
 c0058aa:	4628      	mov	r0, r5
 c0058ac:	f000 f857 	bl	c00595e <__swbuf_r>
 c0058b0:	3001      	adds	r0, #1
 c0058b2:	d1e7      	bne.n	c005884 <_puts_r+0x68>
 c0058b4:	e7ce      	b.n	c005854 <_puts_r+0x38>
 c0058b6:	3e01      	subs	r6, #1
 c0058b8:	e7e4      	b.n	c005884 <_puts_r+0x68>
 c0058ba:	6823      	ldr	r3, [r4, #0]
 c0058bc:	1c5a      	adds	r2, r3, #1
 c0058be:	6022      	str	r2, [r4, #0]
 c0058c0:	220a      	movs	r2, #10
 c0058c2:	701a      	strb	r2, [r3, #0]
 c0058c4:	e7ee      	b.n	c0058a4 <_puts_r+0x88>
	...

0c0058c8 <puts>:
 c0058c8:	4b02      	ldr	r3, [pc, #8]	@ (c0058d4 <puts+0xc>)
 c0058ca:	4601      	mov	r1, r0
 c0058cc:	6818      	ldr	r0, [r3, #0]
 c0058ce:	f7ff bfa5 	b.w	c00581c <_puts_r>
 c0058d2:	bf00      	nop
 c0058d4:	3000004c 	.word	0x3000004c

0c0058d8 <__sread>:
 c0058d8:	b510      	push	{r4, lr}
 c0058da:	460c      	mov	r4, r1
 c0058dc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0058e0:	f000 f910 	bl	c005b04 <_read_r>
 c0058e4:	2800      	cmp	r0, #0
 c0058e6:	bfab      	itete	ge
 c0058e8:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 c0058ea:	89a3      	ldrhlt	r3, [r4, #12]
 c0058ec:	181b      	addge	r3, r3, r0
 c0058ee:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 c0058f2:	bfac      	ite	ge
 c0058f4:	6563      	strge	r3, [r4, #84]	@ 0x54
 c0058f6:	81a3      	strhlt	r3, [r4, #12]
 c0058f8:	bd10      	pop	{r4, pc}

0c0058fa <__swrite>:
 c0058fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0058fe:	461f      	mov	r7, r3
 c005900:	898b      	ldrh	r3, [r1, #12]
 c005902:	4605      	mov	r5, r0
 c005904:	460c      	mov	r4, r1
 c005906:	05db      	lsls	r3, r3, #23
 c005908:	4616      	mov	r6, r2
 c00590a:	d505      	bpl.n	c005918 <__swrite+0x1e>
 c00590c:	2302      	movs	r3, #2
 c00590e:	2200      	movs	r2, #0
 c005910:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c005914:	f000 f8e4 	bl	c005ae0 <_lseek_r>
 c005918:	89a3      	ldrh	r3, [r4, #12]
 c00591a:	4632      	mov	r2, r6
 c00591c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c005920:	4628      	mov	r0, r5
 c005922:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 c005926:	81a3      	strh	r3, [r4, #12]
 c005928:	463b      	mov	r3, r7
 c00592a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c00592e:	f000 b90b 	b.w	c005b48 <_write_r>

0c005932 <__sseek>:
 c005932:	b510      	push	{r4, lr}
 c005934:	460c      	mov	r4, r1
 c005936:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00593a:	f000 f8d1 	bl	c005ae0 <_lseek_r>
 c00593e:	1c43      	adds	r3, r0, #1
 c005940:	89a3      	ldrh	r3, [r4, #12]
 c005942:	bf15      	itete	ne
 c005944:	6560      	strne	r0, [r4, #84]	@ 0x54
 c005946:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 c00594a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 c00594e:	81a3      	strheq	r3, [r4, #12]
 c005950:	bf18      	it	ne
 c005952:	81a3      	strhne	r3, [r4, #12]
 c005954:	bd10      	pop	{r4, pc}

0c005956 <__sclose>:
 c005956:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00595a:	f000 b8b1 	b.w	c005ac0 <_close_r>

0c00595e <__swbuf_r>:
 c00595e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005960:	460e      	mov	r6, r1
 c005962:	4614      	mov	r4, r2
 c005964:	4605      	mov	r5, r0
 c005966:	b118      	cbz	r0, c005970 <__swbuf_r+0x12>
 c005968:	6a03      	ldr	r3, [r0, #32]
 c00596a:	b90b      	cbnz	r3, c005970 <__swbuf_r+0x12>
 c00596c:	f7ff ff0e 	bl	c00578c <__sinit>
 c005970:	69a3      	ldr	r3, [r4, #24]
 c005972:	60a3      	str	r3, [r4, #8]
 c005974:	89a3      	ldrh	r3, [r4, #12]
 c005976:	071a      	lsls	r2, r3, #28
 c005978:	d501      	bpl.n	c00597e <__swbuf_r+0x20>
 c00597a:	6923      	ldr	r3, [r4, #16]
 c00597c:	b943      	cbnz	r3, c005990 <__swbuf_r+0x32>
 c00597e:	4621      	mov	r1, r4
 c005980:	4628      	mov	r0, r5
 c005982:	f000 f82b 	bl	c0059dc <__swsetup_r>
 c005986:	b118      	cbz	r0, c005990 <__swbuf_r+0x32>
 c005988:	f04f 37ff 	mov.w	r7, #4294967295
 c00598c:	4638      	mov	r0, r7
 c00598e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c005990:	6823      	ldr	r3, [r4, #0]
 c005992:	b2f6      	uxtb	r6, r6
 c005994:	6922      	ldr	r2, [r4, #16]
 c005996:	4637      	mov	r7, r6
 c005998:	1a98      	subs	r0, r3, r2
 c00599a:	6963      	ldr	r3, [r4, #20]
 c00599c:	4283      	cmp	r3, r0
 c00599e:	dc05      	bgt.n	c0059ac <__swbuf_r+0x4e>
 c0059a0:	4621      	mov	r1, r4
 c0059a2:	4628      	mov	r0, r5
 c0059a4:	f000 fcda 	bl	c00635c <_fflush_r>
 c0059a8:	2800      	cmp	r0, #0
 c0059aa:	d1ed      	bne.n	c005988 <__swbuf_r+0x2a>
 c0059ac:	68a3      	ldr	r3, [r4, #8]
 c0059ae:	3b01      	subs	r3, #1
 c0059b0:	60a3      	str	r3, [r4, #8]
 c0059b2:	6823      	ldr	r3, [r4, #0]
 c0059b4:	1c5a      	adds	r2, r3, #1
 c0059b6:	6022      	str	r2, [r4, #0]
 c0059b8:	701e      	strb	r6, [r3, #0]
 c0059ba:	1c43      	adds	r3, r0, #1
 c0059bc:	6962      	ldr	r2, [r4, #20]
 c0059be:	429a      	cmp	r2, r3
 c0059c0:	d004      	beq.n	c0059cc <__swbuf_r+0x6e>
 c0059c2:	89a3      	ldrh	r3, [r4, #12]
 c0059c4:	07db      	lsls	r3, r3, #31
 c0059c6:	d5e1      	bpl.n	c00598c <__swbuf_r+0x2e>
 c0059c8:	2e0a      	cmp	r6, #10
 c0059ca:	d1df      	bne.n	c00598c <__swbuf_r+0x2e>
 c0059cc:	4621      	mov	r1, r4
 c0059ce:	4628      	mov	r0, r5
 c0059d0:	f000 fcc4 	bl	c00635c <_fflush_r>
 c0059d4:	2800      	cmp	r0, #0
 c0059d6:	d0d9      	beq.n	c00598c <__swbuf_r+0x2e>
 c0059d8:	e7d6      	b.n	c005988 <__swbuf_r+0x2a>
	...

0c0059dc <__swsetup_r>:
 c0059dc:	b538      	push	{r3, r4, r5, lr}
 c0059de:	4b29      	ldr	r3, [pc, #164]	@ (c005a84 <__swsetup_r+0xa8>)
 c0059e0:	4605      	mov	r5, r0
 c0059e2:	460c      	mov	r4, r1
 c0059e4:	6818      	ldr	r0, [r3, #0]
 c0059e6:	b118      	cbz	r0, c0059f0 <__swsetup_r+0x14>
 c0059e8:	6a03      	ldr	r3, [r0, #32]
 c0059ea:	b90b      	cbnz	r3, c0059f0 <__swsetup_r+0x14>
 c0059ec:	f7ff fece 	bl	c00578c <__sinit>
 c0059f0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0059f4:	0719      	lsls	r1, r3, #28
 c0059f6:	d422      	bmi.n	c005a3e <__swsetup_r+0x62>
 c0059f8:	06da      	lsls	r2, r3, #27
 c0059fa:	d407      	bmi.n	c005a0c <__swsetup_r+0x30>
 c0059fc:	2209      	movs	r2, #9
 c0059fe:	602a      	str	r2, [r5, #0]
 c005a00:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c005a04:	f04f 30ff 	mov.w	r0, #4294967295
 c005a08:	81a3      	strh	r3, [r4, #12]
 c005a0a:	e033      	b.n	c005a74 <__swsetup_r+0x98>
 c005a0c:	0758      	lsls	r0, r3, #29
 c005a0e:	d512      	bpl.n	c005a36 <__swsetup_r+0x5a>
 c005a10:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c005a12:	b141      	cbz	r1, c005a26 <__swsetup_r+0x4a>
 c005a14:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c005a18:	4299      	cmp	r1, r3
 c005a1a:	d002      	beq.n	c005a22 <__swsetup_r+0x46>
 c005a1c:	4628      	mov	r0, r5
 c005a1e:	f000 f8fd 	bl	c005c1c <_free_r>
 c005a22:	2300      	movs	r3, #0
 c005a24:	6363      	str	r3, [r4, #52]	@ 0x34
 c005a26:	89a3      	ldrh	r3, [r4, #12]
 c005a28:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 c005a2c:	81a3      	strh	r3, [r4, #12]
 c005a2e:	2300      	movs	r3, #0
 c005a30:	6063      	str	r3, [r4, #4]
 c005a32:	6923      	ldr	r3, [r4, #16]
 c005a34:	6023      	str	r3, [r4, #0]
 c005a36:	89a3      	ldrh	r3, [r4, #12]
 c005a38:	f043 0308 	orr.w	r3, r3, #8
 c005a3c:	81a3      	strh	r3, [r4, #12]
 c005a3e:	6923      	ldr	r3, [r4, #16]
 c005a40:	b94b      	cbnz	r3, c005a56 <__swsetup_r+0x7a>
 c005a42:	89a3      	ldrh	r3, [r4, #12]
 c005a44:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 c005a48:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c005a4c:	d003      	beq.n	c005a56 <__swsetup_r+0x7a>
 c005a4e:	4621      	mov	r1, r4
 c005a50:	4628      	mov	r0, r5
 c005a52:	f000 fce2 	bl	c00641a <__smakebuf_r>
 c005a56:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c005a5a:	f013 0201 	ands.w	r2, r3, #1
 c005a5e:	d00a      	beq.n	c005a76 <__swsetup_r+0x9a>
 c005a60:	2200      	movs	r2, #0
 c005a62:	60a2      	str	r2, [r4, #8]
 c005a64:	6962      	ldr	r2, [r4, #20]
 c005a66:	4252      	negs	r2, r2
 c005a68:	61a2      	str	r2, [r4, #24]
 c005a6a:	6922      	ldr	r2, [r4, #16]
 c005a6c:	b942      	cbnz	r2, c005a80 <__swsetup_r+0xa4>
 c005a6e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 c005a72:	d1c5      	bne.n	c005a00 <__swsetup_r+0x24>
 c005a74:	bd38      	pop	{r3, r4, r5, pc}
 c005a76:	0799      	lsls	r1, r3, #30
 c005a78:	bf58      	it	pl
 c005a7a:	6962      	ldrpl	r2, [r4, #20]
 c005a7c:	60a2      	str	r2, [r4, #8]
 c005a7e:	e7f4      	b.n	c005a6a <__swsetup_r+0x8e>
 c005a80:	2000      	movs	r0, #0
 c005a82:	e7f7      	b.n	c005a74 <__swsetup_r+0x98>
 c005a84:	3000004c 	.word	0x3000004c

0c005a88 <memset>:
 c005a88:	4402      	add	r2, r0
 c005a8a:	4603      	mov	r3, r0
 c005a8c:	4293      	cmp	r3, r2
 c005a8e:	d100      	bne.n	c005a92 <memset+0xa>
 c005a90:	4770      	bx	lr
 c005a92:	f803 1b01 	strb.w	r1, [r3], #1
 c005a96:	e7f9      	b.n	c005a8c <memset+0x4>

0c005a98 <strncpy>:
 c005a98:	3901      	subs	r1, #1
 c005a9a:	4603      	mov	r3, r0
 c005a9c:	b510      	push	{r4, lr}
 c005a9e:	b132      	cbz	r2, c005aae <strncpy+0x16>
 c005aa0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 c005aa4:	3a01      	subs	r2, #1
 c005aa6:	f803 4b01 	strb.w	r4, [r3], #1
 c005aaa:	2c00      	cmp	r4, #0
 c005aac:	d1f7      	bne.n	c005a9e <strncpy+0x6>
 c005aae:	441a      	add	r2, r3
 c005ab0:	2100      	movs	r1, #0
 c005ab2:	4293      	cmp	r3, r2
 c005ab4:	d100      	bne.n	c005ab8 <strncpy+0x20>
 c005ab6:	bd10      	pop	{r4, pc}
 c005ab8:	f803 1b01 	strb.w	r1, [r3], #1
 c005abc:	e7f9      	b.n	c005ab2 <strncpy+0x1a>
	...

0c005ac0 <_close_r>:
 c005ac0:	b538      	push	{r3, r4, r5, lr}
 c005ac2:	2300      	movs	r3, #0
 c005ac4:	4d05      	ldr	r5, [pc, #20]	@ (c005adc <_close_r+0x1c>)
 c005ac6:	4604      	mov	r4, r0
 c005ac8:	4608      	mov	r0, r1
 c005aca:	602b      	str	r3, [r5, #0]
 c005acc:	f7fd fe0c 	bl	c0036e8 <_close>
 c005ad0:	1c43      	adds	r3, r0, #1
 c005ad2:	d102      	bne.n	c005ada <_close_r+0x1a>
 c005ad4:	682b      	ldr	r3, [r5, #0]
 c005ad6:	b103      	cbz	r3, c005ada <_close_r+0x1a>
 c005ad8:	6023      	str	r3, [r4, #0]
 c005ada:	bd38      	pop	{r3, r4, r5, pc}
 c005adc:	3000341c 	.word	0x3000341c

0c005ae0 <_lseek_r>:
 c005ae0:	b538      	push	{r3, r4, r5, lr}
 c005ae2:	4604      	mov	r4, r0
 c005ae4:	4d06      	ldr	r5, [pc, #24]	@ (c005b00 <_lseek_r+0x20>)
 c005ae6:	4608      	mov	r0, r1
 c005ae8:	4611      	mov	r1, r2
 c005aea:	2200      	movs	r2, #0
 c005aec:	602a      	str	r2, [r5, #0]
 c005aee:	461a      	mov	r2, r3
 c005af0:	f7fd fe21 	bl	c003736 <_lseek>
 c005af4:	1c43      	adds	r3, r0, #1
 c005af6:	d102      	bne.n	c005afe <_lseek_r+0x1e>
 c005af8:	682b      	ldr	r3, [r5, #0]
 c005afa:	b103      	cbz	r3, c005afe <_lseek_r+0x1e>
 c005afc:	6023      	str	r3, [r4, #0]
 c005afe:	bd38      	pop	{r3, r4, r5, pc}
 c005b00:	3000341c 	.word	0x3000341c

0c005b04 <_read_r>:
 c005b04:	b538      	push	{r3, r4, r5, lr}
 c005b06:	4604      	mov	r4, r0
 c005b08:	4d06      	ldr	r5, [pc, #24]	@ (c005b24 <_read_r+0x20>)
 c005b0a:	4608      	mov	r0, r1
 c005b0c:	4611      	mov	r1, r2
 c005b0e:	2200      	movs	r2, #0
 c005b10:	602a      	str	r2, [r5, #0]
 c005b12:	461a      	mov	r2, r3
 c005b14:	f7fd fdaf 	bl	c003676 <_read>
 c005b18:	1c43      	adds	r3, r0, #1
 c005b1a:	d102      	bne.n	c005b22 <_read_r+0x1e>
 c005b1c:	682b      	ldr	r3, [r5, #0]
 c005b1e:	b103      	cbz	r3, c005b22 <_read_r+0x1e>
 c005b20:	6023      	str	r3, [r4, #0]
 c005b22:	bd38      	pop	{r3, r4, r5, pc}
 c005b24:	3000341c 	.word	0x3000341c

0c005b28 <_sbrk_r>:
 c005b28:	b538      	push	{r3, r4, r5, lr}
 c005b2a:	2300      	movs	r3, #0
 c005b2c:	4d05      	ldr	r5, [pc, #20]	@ (c005b44 <_sbrk_r+0x1c>)
 c005b2e:	4604      	mov	r4, r0
 c005b30:	4608      	mov	r0, r1
 c005b32:	602b      	str	r3, [r5, #0]
 c005b34:	f7fd fe0c 	bl	c003750 <_sbrk>
 c005b38:	1c43      	adds	r3, r0, #1
 c005b3a:	d102      	bne.n	c005b42 <_sbrk_r+0x1a>
 c005b3c:	682b      	ldr	r3, [r5, #0]
 c005b3e:	b103      	cbz	r3, c005b42 <_sbrk_r+0x1a>
 c005b40:	6023      	str	r3, [r4, #0]
 c005b42:	bd38      	pop	{r3, r4, r5, pc}
 c005b44:	3000341c 	.word	0x3000341c

0c005b48 <_write_r>:
 c005b48:	b538      	push	{r3, r4, r5, lr}
 c005b4a:	4604      	mov	r4, r0
 c005b4c:	4d06      	ldr	r5, [pc, #24]	@ (c005b68 <_write_r+0x20>)
 c005b4e:	4608      	mov	r0, r1
 c005b50:	4611      	mov	r1, r2
 c005b52:	2200      	movs	r2, #0
 c005b54:	602a      	str	r2, [r5, #0]
 c005b56:	461a      	mov	r2, r3
 c005b58:	f7fd fdaa 	bl	c0036b0 <_write>
 c005b5c:	1c43      	adds	r3, r0, #1
 c005b5e:	d102      	bne.n	c005b66 <_write_r+0x1e>
 c005b60:	682b      	ldr	r3, [r5, #0]
 c005b62:	b103      	cbz	r3, c005b66 <_write_r+0x1e>
 c005b64:	6023      	str	r3, [r4, #0]
 c005b66:	bd38      	pop	{r3, r4, r5, pc}
 c005b68:	3000341c 	.word	0x3000341c

0c005b6c <__errno>:
 c005b6c:	4b01      	ldr	r3, [pc, #4]	@ (c005b74 <__errno+0x8>)
 c005b6e:	6818      	ldr	r0, [r3, #0]
 c005b70:	4770      	bx	lr
 c005b72:	bf00      	nop
 c005b74:	3000004c 	.word	0x3000004c

0c005b78 <__libc_init_array>:
 c005b78:	b570      	push	{r4, r5, r6, lr}
 c005b7a:	4d0d      	ldr	r5, [pc, #52]	@ (c005bb0 <__libc_init_array+0x38>)
 c005b7c:	2600      	movs	r6, #0
 c005b7e:	4c0d      	ldr	r4, [pc, #52]	@ (c005bb4 <__libc_init_array+0x3c>)
 c005b80:	1b64      	subs	r4, r4, r5
 c005b82:	10a4      	asrs	r4, r4, #2
 c005b84:	42a6      	cmp	r6, r4
 c005b86:	d109      	bne.n	c005b9c <__libc_init_array+0x24>
 c005b88:	4d0b      	ldr	r5, [pc, #44]	@ (c005bb8 <__libc_init_array+0x40>)
 c005b8a:	2600      	movs	r6, #0
 c005b8c:	4c0b      	ldr	r4, [pc, #44]	@ (c005bbc <__libc_init_array+0x44>)
 c005b8e:	f000 fcfd 	bl	c00658c <_init>
 c005b92:	1b64      	subs	r4, r4, r5
 c005b94:	10a4      	asrs	r4, r4, #2
 c005b96:	42a6      	cmp	r6, r4
 c005b98:	d105      	bne.n	c005ba6 <__libc_init_array+0x2e>
 c005b9a:	bd70      	pop	{r4, r5, r6, pc}
 c005b9c:	f855 3b04 	ldr.w	r3, [r5], #4
 c005ba0:	3601      	adds	r6, #1
 c005ba2:	4798      	blx	r3
 c005ba4:	e7ee      	b.n	c005b84 <__libc_init_array+0xc>
 c005ba6:	f855 3b04 	ldr.w	r3, [r5], #4
 c005baa:	3601      	adds	r6, #1
 c005bac:	4798      	blx	r3
 c005bae:	e7f2      	b.n	c005b96 <__libc_init_array+0x1e>
 c005bb0:	0c006d98 	.word	0x0c006d98
 c005bb4:	0c006d98 	.word	0x0c006d98
 c005bb8:	0c006d98 	.word	0x0c006d98
 c005bbc:	0c006d9c 	.word	0x0c006d9c

0c005bc0 <__retarget_lock_init_recursive>:
 c005bc0:	4770      	bx	lr

0c005bc2 <__retarget_lock_acquire_recursive>:
 c005bc2:	4770      	bx	lr

0c005bc4 <__retarget_lock_release_recursive>:
 c005bc4:	4770      	bx	lr

0c005bc6 <memcpy>:
 c005bc6:	440a      	add	r2, r1
 c005bc8:	1e43      	subs	r3, r0, #1
 c005bca:	4291      	cmp	r1, r2
 c005bcc:	d100      	bne.n	c005bd0 <memcpy+0xa>
 c005bce:	4770      	bx	lr
 c005bd0:	b510      	push	{r4, lr}
 c005bd2:	f811 4b01 	ldrb.w	r4, [r1], #1
 c005bd6:	4291      	cmp	r1, r2
 c005bd8:	f803 4f01 	strb.w	r4, [r3, #1]!
 c005bdc:	d1f9      	bne.n	c005bd2 <memcpy+0xc>
 c005bde:	bd10      	pop	{r4, pc}

0c005be0 <__assert_func>:
 c005be0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c005be2:	4614      	mov	r4, r2
 c005be4:	461a      	mov	r2, r3
 c005be6:	4b09      	ldr	r3, [pc, #36]	@ (c005c0c <__assert_func+0x2c>)
 c005be8:	4605      	mov	r5, r0
 c005bea:	681b      	ldr	r3, [r3, #0]
 c005bec:	68d8      	ldr	r0, [r3, #12]
 c005bee:	b14c      	cbz	r4, c005c04 <__assert_func+0x24>
 c005bf0:	4b07      	ldr	r3, [pc, #28]	@ (c005c10 <__assert_func+0x30>)
 c005bf2:	9100      	str	r1, [sp, #0]
 c005bf4:	4907      	ldr	r1, [pc, #28]	@ (c005c14 <__assert_func+0x34>)
 c005bf6:	e9cd 3401 	strd	r3, r4, [sp, #4]
 c005bfa:	462b      	mov	r3, r5
 c005bfc:	f000 fbd6 	bl	c0063ac <fiprintf>
 c005c00:	f000 fc78 	bl	c0064f4 <abort>
 c005c04:	4b04      	ldr	r3, [pc, #16]	@ (c005c18 <__assert_func+0x38>)
 c005c06:	461c      	mov	r4, r3
 c005c08:	e7f3      	b.n	c005bf2 <__assert_func+0x12>
 c005c0a:	bf00      	nop
 c005c0c:	3000004c 	.word	0x3000004c
 c005c10:	0c006d1b 	.word	0x0c006d1b
 c005c14:	0c006d28 	.word	0x0c006d28
 c005c18:	0c006d56 	.word	0x0c006d56

0c005c1c <_free_r>:
 c005c1c:	b538      	push	{r3, r4, r5, lr}
 c005c1e:	4605      	mov	r5, r0
 c005c20:	2900      	cmp	r1, #0
 c005c22:	d041      	beq.n	c005ca8 <_free_r+0x8c>
 c005c24:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c005c28:	1f0c      	subs	r4, r1, #4
 c005c2a:	2b00      	cmp	r3, #0
 c005c2c:	bfb8      	it	lt
 c005c2e:	18e4      	addlt	r4, r4, r3
 c005c30:	f7ff fca8 	bl	c005584 <__malloc_lock>
 c005c34:	4a1d      	ldr	r2, [pc, #116]	@ (c005cac <_free_r+0x90>)
 c005c36:	6813      	ldr	r3, [r2, #0]
 c005c38:	b933      	cbnz	r3, c005c48 <_free_r+0x2c>
 c005c3a:	6063      	str	r3, [r4, #4]
 c005c3c:	6014      	str	r4, [r2, #0]
 c005c3e:	4628      	mov	r0, r5
 c005c40:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c005c44:	f7ff bca4 	b.w	c005590 <__malloc_unlock>
 c005c48:	42a3      	cmp	r3, r4
 c005c4a:	d908      	bls.n	c005c5e <_free_r+0x42>
 c005c4c:	6820      	ldr	r0, [r4, #0]
 c005c4e:	1821      	adds	r1, r4, r0
 c005c50:	428b      	cmp	r3, r1
 c005c52:	bf01      	itttt	eq
 c005c54:	6819      	ldreq	r1, [r3, #0]
 c005c56:	685b      	ldreq	r3, [r3, #4]
 c005c58:	1809      	addeq	r1, r1, r0
 c005c5a:	6021      	streq	r1, [r4, #0]
 c005c5c:	e7ed      	b.n	c005c3a <_free_r+0x1e>
 c005c5e:	461a      	mov	r2, r3
 c005c60:	685b      	ldr	r3, [r3, #4]
 c005c62:	b10b      	cbz	r3, c005c68 <_free_r+0x4c>
 c005c64:	42a3      	cmp	r3, r4
 c005c66:	d9fa      	bls.n	c005c5e <_free_r+0x42>
 c005c68:	6811      	ldr	r1, [r2, #0]
 c005c6a:	1850      	adds	r0, r2, r1
 c005c6c:	42a0      	cmp	r0, r4
 c005c6e:	d10b      	bne.n	c005c88 <_free_r+0x6c>
 c005c70:	6820      	ldr	r0, [r4, #0]
 c005c72:	4401      	add	r1, r0
 c005c74:	1850      	adds	r0, r2, r1
 c005c76:	6011      	str	r1, [r2, #0]
 c005c78:	4283      	cmp	r3, r0
 c005c7a:	d1e0      	bne.n	c005c3e <_free_r+0x22>
 c005c7c:	6818      	ldr	r0, [r3, #0]
 c005c7e:	685b      	ldr	r3, [r3, #4]
 c005c80:	4408      	add	r0, r1
 c005c82:	6053      	str	r3, [r2, #4]
 c005c84:	6010      	str	r0, [r2, #0]
 c005c86:	e7da      	b.n	c005c3e <_free_r+0x22>
 c005c88:	d902      	bls.n	c005c90 <_free_r+0x74>
 c005c8a:	230c      	movs	r3, #12
 c005c8c:	602b      	str	r3, [r5, #0]
 c005c8e:	e7d6      	b.n	c005c3e <_free_r+0x22>
 c005c90:	6820      	ldr	r0, [r4, #0]
 c005c92:	1821      	adds	r1, r4, r0
 c005c94:	428b      	cmp	r3, r1
 c005c96:	bf02      	ittt	eq
 c005c98:	6819      	ldreq	r1, [r3, #0]
 c005c9a:	685b      	ldreq	r3, [r3, #4]
 c005c9c:	1809      	addeq	r1, r1, r0
 c005c9e:	6063      	str	r3, [r4, #4]
 c005ca0:	bf08      	it	eq
 c005ca2:	6021      	streq	r1, [r4, #0]
 c005ca4:	6054      	str	r4, [r2, #4]
 c005ca6:	e7ca      	b.n	c005c3e <_free_r+0x22>
 c005ca8:	bd38      	pop	{r3, r4, r5, pc}
 c005caa:	bf00      	nop
 c005cac:	300032dc 	.word	0x300032dc

0c005cb0 <__sfputc_r>:
 c005cb0:	6893      	ldr	r3, [r2, #8]
 c005cb2:	3b01      	subs	r3, #1
 c005cb4:	2b00      	cmp	r3, #0
 c005cb6:	b410      	push	{r4}
 c005cb8:	6093      	str	r3, [r2, #8]
 c005cba:	da08      	bge.n	c005cce <__sfputc_r+0x1e>
 c005cbc:	6994      	ldr	r4, [r2, #24]
 c005cbe:	42a3      	cmp	r3, r4
 c005cc0:	db01      	blt.n	c005cc6 <__sfputc_r+0x16>
 c005cc2:	290a      	cmp	r1, #10
 c005cc4:	d103      	bne.n	c005cce <__sfputc_r+0x1e>
 c005cc6:	f85d 4b04 	ldr.w	r4, [sp], #4
 c005cca:	f7ff be48 	b.w	c00595e <__swbuf_r>
 c005cce:	6813      	ldr	r3, [r2, #0]
 c005cd0:	1c58      	adds	r0, r3, #1
 c005cd2:	6010      	str	r0, [r2, #0]
 c005cd4:	4608      	mov	r0, r1
 c005cd6:	7019      	strb	r1, [r3, #0]
 c005cd8:	f85d 4b04 	ldr.w	r4, [sp], #4
 c005cdc:	4770      	bx	lr

0c005cde <__sfputs_r>:
 c005cde:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005ce0:	4606      	mov	r6, r0
 c005ce2:	460f      	mov	r7, r1
 c005ce4:	4614      	mov	r4, r2
 c005ce6:	18d5      	adds	r5, r2, r3
 c005ce8:	42ac      	cmp	r4, r5
 c005cea:	d101      	bne.n	c005cf0 <__sfputs_r+0x12>
 c005cec:	2000      	movs	r0, #0
 c005cee:	e007      	b.n	c005d00 <__sfputs_r+0x22>
 c005cf0:	463a      	mov	r2, r7
 c005cf2:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005cf6:	4630      	mov	r0, r6
 c005cf8:	f7ff ffda 	bl	c005cb0 <__sfputc_r>
 c005cfc:	1c43      	adds	r3, r0, #1
 c005cfe:	d1f3      	bne.n	c005ce8 <__sfputs_r+0xa>
 c005d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c005d04 <_vfiprintf_r>:
 c005d04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c005d08:	460d      	mov	r5, r1
 c005d0a:	b09d      	sub	sp, #116	@ 0x74
 c005d0c:	4614      	mov	r4, r2
 c005d0e:	4698      	mov	r8, r3
 c005d10:	4606      	mov	r6, r0
 c005d12:	b118      	cbz	r0, c005d1c <_vfiprintf_r+0x18>
 c005d14:	6a03      	ldr	r3, [r0, #32]
 c005d16:	b90b      	cbnz	r3, c005d1c <_vfiprintf_r+0x18>
 c005d18:	f7ff fd38 	bl	c00578c <__sinit>
 c005d1c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005d1e:	07d9      	lsls	r1, r3, #31
 c005d20:	d405      	bmi.n	c005d2e <_vfiprintf_r+0x2a>
 c005d22:	89ab      	ldrh	r3, [r5, #12]
 c005d24:	059a      	lsls	r2, r3, #22
 c005d26:	d402      	bmi.n	c005d2e <_vfiprintf_r+0x2a>
 c005d28:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005d2a:	f7ff ff4a 	bl	c005bc2 <__retarget_lock_acquire_recursive>
 c005d2e:	89ab      	ldrh	r3, [r5, #12]
 c005d30:	071b      	lsls	r3, r3, #28
 c005d32:	d501      	bpl.n	c005d38 <_vfiprintf_r+0x34>
 c005d34:	692b      	ldr	r3, [r5, #16]
 c005d36:	b99b      	cbnz	r3, c005d60 <_vfiprintf_r+0x5c>
 c005d38:	4629      	mov	r1, r5
 c005d3a:	4630      	mov	r0, r6
 c005d3c:	f7ff fe4e 	bl	c0059dc <__swsetup_r>
 c005d40:	b170      	cbz	r0, c005d60 <_vfiprintf_r+0x5c>
 c005d42:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005d44:	07dc      	lsls	r4, r3, #31
 c005d46:	d504      	bpl.n	c005d52 <_vfiprintf_r+0x4e>
 c005d48:	f04f 30ff 	mov.w	r0, #4294967295
 c005d4c:	b01d      	add	sp, #116	@ 0x74
 c005d4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c005d52:	89ab      	ldrh	r3, [r5, #12]
 c005d54:	0598      	lsls	r0, r3, #22
 c005d56:	d4f7      	bmi.n	c005d48 <_vfiprintf_r+0x44>
 c005d58:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005d5a:	f7ff ff33 	bl	c005bc4 <__retarget_lock_release_recursive>
 c005d5e:	e7f3      	b.n	c005d48 <_vfiprintf_r+0x44>
 c005d60:	2300      	movs	r3, #0
 c005d62:	f8cd 800c 	str.w	r8, [sp, #12]
 c005d66:	f04f 0901 	mov.w	r9, #1
 c005d6a:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ c005f20 <_vfiprintf_r+0x21c>
 c005d6e:	9309      	str	r3, [sp, #36]	@ 0x24
 c005d70:	2320      	movs	r3, #32
 c005d72:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 c005d76:	2330      	movs	r3, #48	@ 0x30
 c005d78:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 c005d7c:	4623      	mov	r3, r4
 c005d7e:	469a      	mov	sl, r3
 c005d80:	f813 2b01 	ldrb.w	r2, [r3], #1
 c005d84:	b10a      	cbz	r2, c005d8a <_vfiprintf_r+0x86>
 c005d86:	2a25      	cmp	r2, #37	@ 0x25
 c005d88:	d1f9      	bne.n	c005d7e <_vfiprintf_r+0x7a>
 c005d8a:	ebba 0b04 	subs.w	fp, sl, r4
 c005d8e:	d00b      	beq.n	c005da8 <_vfiprintf_r+0xa4>
 c005d90:	465b      	mov	r3, fp
 c005d92:	4622      	mov	r2, r4
 c005d94:	4629      	mov	r1, r5
 c005d96:	4630      	mov	r0, r6
 c005d98:	f7ff ffa1 	bl	c005cde <__sfputs_r>
 c005d9c:	3001      	adds	r0, #1
 c005d9e:	f000 80a7 	beq.w	c005ef0 <_vfiprintf_r+0x1ec>
 c005da2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c005da4:	445a      	add	r2, fp
 c005da6:	9209      	str	r2, [sp, #36]	@ 0x24
 c005da8:	f89a 3000 	ldrb.w	r3, [sl]
 c005dac:	2b00      	cmp	r3, #0
 c005dae:	f000 809f 	beq.w	c005ef0 <_vfiprintf_r+0x1ec>
 c005db2:	2300      	movs	r3, #0
 c005db4:	f04f 32ff 	mov.w	r2, #4294967295
 c005db8:	f10a 0a01 	add.w	sl, sl, #1
 c005dbc:	9304      	str	r3, [sp, #16]
 c005dbe:	9307      	str	r3, [sp, #28]
 c005dc0:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 c005dc4:	931a      	str	r3, [sp, #104]	@ 0x68
 c005dc6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c005dca:	4654      	mov	r4, sl
 c005dcc:	2205      	movs	r2, #5
 c005dce:	4854      	ldr	r0, [pc, #336]	@ (c005f20 <_vfiprintf_r+0x21c>)
 c005dd0:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005dd4:	f000 fb80 	bl	c0064d8 <memchr>
 c005dd8:	9a04      	ldr	r2, [sp, #16]
 c005dda:	b9d8      	cbnz	r0, c005e14 <_vfiprintf_r+0x110>
 c005ddc:	06d1      	lsls	r1, r2, #27
 c005dde:	bf44      	itt	mi
 c005de0:	2320      	movmi	r3, #32
 c005de2:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c005de6:	0713      	lsls	r3, r2, #28
 c005de8:	bf44      	itt	mi
 c005dea:	232b      	movmi	r3, #43	@ 0x2b
 c005dec:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c005df0:	f89a 3000 	ldrb.w	r3, [sl]
 c005df4:	2b2a      	cmp	r3, #42	@ 0x2a
 c005df6:	d015      	beq.n	c005e24 <_vfiprintf_r+0x120>
 c005df8:	9a07      	ldr	r2, [sp, #28]
 c005dfa:	4654      	mov	r4, sl
 c005dfc:	2000      	movs	r0, #0
 c005dfe:	f04f 0c0a 	mov.w	ip, #10
 c005e02:	4621      	mov	r1, r4
 c005e04:	f811 3b01 	ldrb.w	r3, [r1], #1
 c005e08:	3b30      	subs	r3, #48	@ 0x30
 c005e0a:	2b09      	cmp	r3, #9
 c005e0c:	d94b      	bls.n	c005ea6 <_vfiprintf_r+0x1a2>
 c005e0e:	b1b0      	cbz	r0, c005e3e <_vfiprintf_r+0x13a>
 c005e10:	9207      	str	r2, [sp, #28]
 c005e12:	e014      	b.n	c005e3e <_vfiprintf_r+0x13a>
 c005e14:	eba0 0308 	sub.w	r3, r0, r8
 c005e18:	46a2      	mov	sl, r4
 c005e1a:	fa09 f303 	lsl.w	r3, r9, r3
 c005e1e:	4313      	orrs	r3, r2
 c005e20:	9304      	str	r3, [sp, #16]
 c005e22:	e7d2      	b.n	c005dca <_vfiprintf_r+0xc6>
 c005e24:	9b03      	ldr	r3, [sp, #12]
 c005e26:	1d19      	adds	r1, r3, #4
 c005e28:	681b      	ldr	r3, [r3, #0]
 c005e2a:	2b00      	cmp	r3, #0
 c005e2c:	9103      	str	r1, [sp, #12]
 c005e2e:	bfbb      	ittet	lt
 c005e30:	425b      	neglt	r3, r3
 c005e32:	f042 0202 	orrlt.w	r2, r2, #2
 c005e36:	9307      	strge	r3, [sp, #28]
 c005e38:	9307      	strlt	r3, [sp, #28]
 c005e3a:	bfb8      	it	lt
 c005e3c:	9204      	strlt	r2, [sp, #16]
 c005e3e:	7823      	ldrb	r3, [r4, #0]
 c005e40:	2b2e      	cmp	r3, #46	@ 0x2e
 c005e42:	d10a      	bne.n	c005e5a <_vfiprintf_r+0x156>
 c005e44:	7863      	ldrb	r3, [r4, #1]
 c005e46:	2b2a      	cmp	r3, #42	@ 0x2a
 c005e48:	d132      	bne.n	c005eb0 <_vfiprintf_r+0x1ac>
 c005e4a:	9b03      	ldr	r3, [sp, #12]
 c005e4c:	3402      	adds	r4, #2
 c005e4e:	1d1a      	adds	r2, r3, #4
 c005e50:	681b      	ldr	r3, [r3, #0]
 c005e52:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 c005e56:	9203      	str	r2, [sp, #12]
 c005e58:	9305      	str	r3, [sp, #20]
 c005e5a:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ c005f30 <_vfiprintf_r+0x22c>
 c005e5e:	2203      	movs	r2, #3
 c005e60:	7821      	ldrb	r1, [r4, #0]
 c005e62:	4650      	mov	r0, sl
 c005e64:	f000 fb38 	bl	c0064d8 <memchr>
 c005e68:	b138      	cbz	r0, c005e7a <_vfiprintf_r+0x176>
 c005e6a:	eba0 000a 	sub.w	r0, r0, sl
 c005e6e:	2240      	movs	r2, #64	@ 0x40
 c005e70:	9b04      	ldr	r3, [sp, #16]
 c005e72:	3401      	adds	r4, #1
 c005e74:	4082      	lsls	r2, r0
 c005e76:	4313      	orrs	r3, r2
 c005e78:	9304      	str	r3, [sp, #16]
 c005e7a:	f814 1b01 	ldrb.w	r1, [r4], #1
 c005e7e:	2206      	movs	r2, #6
 c005e80:	4828      	ldr	r0, [pc, #160]	@ (c005f24 <_vfiprintf_r+0x220>)
 c005e82:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 c005e86:	f000 fb27 	bl	c0064d8 <memchr>
 c005e8a:	2800      	cmp	r0, #0
 c005e8c:	d03f      	beq.n	c005f0e <_vfiprintf_r+0x20a>
 c005e8e:	4b26      	ldr	r3, [pc, #152]	@ (c005f28 <_vfiprintf_r+0x224>)
 c005e90:	bb1b      	cbnz	r3, c005eda <_vfiprintf_r+0x1d6>
 c005e92:	9b03      	ldr	r3, [sp, #12]
 c005e94:	3307      	adds	r3, #7
 c005e96:	f023 0307 	bic.w	r3, r3, #7
 c005e9a:	3308      	adds	r3, #8
 c005e9c:	9303      	str	r3, [sp, #12]
 c005e9e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c005ea0:	443b      	add	r3, r7
 c005ea2:	9309      	str	r3, [sp, #36]	@ 0x24
 c005ea4:	e76a      	b.n	c005d7c <_vfiprintf_r+0x78>
 c005ea6:	fb0c 3202 	mla	r2, ip, r2, r3
 c005eaa:	460c      	mov	r4, r1
 c005eac:	2001      	movs	r0, #1
 c005eae:	e7a8      	b.n	c005e02 <_vfiprintf_r+0xfe>
 c005eb0:	2300      	movs	r3, #0
 c005eb2:	3401      	adds	r4, #1
 c005eb4:	f04f 0c0a 	mov.w	ip, #10
 c005eb8:	4619      	mov	r1, r3
 c005eba:	9305      	str	r3, [sp, #20]
 c005ebc:	4620      	mov	r0, r4
 c005ebe:	f810 2b01 	ldrb.w	r2, [r0], #1
 c005ec2:	3a30      	subs	r2, #48	@ 0x30
 c005ec4:	2a09      	cmp	r2, #9
 c005ec6:	d903      	bls.n	c005ed0 <_vfiprintf_r+0x1cc>
 c005ec8:	2b00      	cmp	r3, #0
 c005eca:	d0c6      	beq.n	c005e5a <_vfiprintf_r+0x156>
 c005ecc:	9105      	str	r1, [sp, #20]
 c005ece:	e7c4      	b.n	c005e5a <_vfiprintf_r+0x156>
 c005ed0:	fb0c 2101 	mla	r1, ip, r1, r2
 c005ed4:	4604      	mov	r4, r0
 c005ed6:	2301      	movs	r3, #1
 c005ed8:	e7f0      	b.n	c005ebc <_vfiprintf_r+0x1b8>
 c005eda:	ab03      	add	r3, sp, #12
 c005edc:	462a      	mov	r2, r5
 c005ede:	a904      	add	r1, sp, #16
 c005ee0:	4630      	mov	r0, r6
 c005ee2:	9300      	str	r3, [sp, #0]
 c005ee4:	4b11      	ldr	r3, [pc, #68]	@ (c005f2c <_vfiprintf_r+0x228>)
 c005ee6:	f3af 8000 	nop.w
 c005eea:	4607      	mov	r7, r0
 c005eec:	1c78      	adds	r0, r7, #1
 c005eee:	d1d6      	bne.n	c005e9e <_vfiprintf_r+0x19a>
 c005ef0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c005ef2:	07d9      	lsls	r1, r3, #31
 c005ef4:	d405      	bmi.n	c005f02 <_vfiprintf_r+0x1fe>
 c005ef6:	89ab      	ldrh	r3, [r5, #12]
 c005ef8:	059a      	lsls	r2, r3, #22
 c005efa:	d402      	bmi.n	c005f02 <_vfiprintf_r+0x1fe>
 c005efc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c005efe:	f7ff fe61 	bl	c005bc4 <__retarget_lock_release_recursive>
 c005f02:	89ab      	ldrh	r3, [r5, #12]
 c005f04:	065b      	lsls	r3, r3, #25
 c005f06:	f53f af1f 	bmi.w	c005d48 <_vfiprintf_r+0x44>
 c005f0a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c005f0c:	e71e      	b.n	c005d4c <_vfiprintf_r+0x48>
 c005f0e:	ab03      	add	r3, sp, #12
 c005f10:	462a      	mov	r2, r5
 c005f12:	a904      	add	r1, sp, #16
 c005f14:	4630      	mov	r0, r6
 c005f16:	9300      	str	r3, [sp, #0]
 c005f18:	4b04      	ldr	r3, [pc, #16]	@ (c005f2c <_vfiprintf_r+0x228>)
 c005f1a:	f000 f87d 	bl	c006018 <_printf_i>
 c005f1e:	e7e4      	b.n	c005eea <_vfiprintf_r+0x1e6>
 c005f20:	0c006d57 	.word	0x0c006d57
 c005f24:	0c006d61 	.word	0x0c006d61
 c005f28:	00000000 	.word	0x00000000
 c005f2c:	0c005cdf 	.word	0x0c005cdf
 c005f30:	0c006d5d 	.word	0x0c006d5d

0c005f34 <_printf_common>:
 c005f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c005f38:	4616      	mov	r6, r2
 c005f3a:	4698      	mov	r8, r3
 c005f3c:	688a      	ldr	r2, [r1, #8]
 c005f3e:	4607      	mov	r7, r0
 c005f40:	690b      	ldr	r3, [r1, #16]
 c005f42:	460c      	mov	r4, r1
 c005f44:	f8dd 9020 	ldr.w	r9, [sp, #32]
 c005f48:	4293      	cmp	r3, r2
 c005f4a:	bfb8      	it	lt
 c005f4c:	4613      	movlt	r3, r2
 c005f4e:	6033      	str	r3, [r6, #0]
 c005f50:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 c005f54:	b10a      	cbz	r2, c005f5a <_printf_common+0x26>
 c005f56:	3301      	adds	r3, #1
 c005f58:	6033      	str	r3, [r6, #0]
 c005f5a:	6823      	ldr	r3, [r4, #0]
 c005f5c:	0699      	lsls	r1, r3, #26
 c005f5e:	bf42      	ittt	mi
 c005f60:	6833      	ldrmi	r3, [r6, #0]
 c005f62:	3302      	addmi	r3, #2
 c005f64:	6033      	strmi	r3, [r6, #0]
 c005f66:	6825      	ldr	r5, [r4, #0]
 c005f68:	f015 0506 	ands.w	r5, r5, #6
 c005f6c:	d106      	bne.n	c005f7c <_printf_common+0x48>
 c005f6e:	f104 0a19 	add.w	sl, r4, #25
 c005f72:	68e3      	ldr	r3, [r4, #12]
 c005f74:	6832      	ldr	r2, [r6, #0]
 c005f76:	1a9b      	subs	r3, r3, r2
 c005f78:	42ab      	cmp	r3, r5
 c005f7a:	dc2b      	bgt.n	c005fd4 <_printf_common+0xa0>
 c005f7c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 c005f80:	6822      	ldr	r2, [r4, #0]
 c005f82:	3b00      	subs	r3, #0
 c005f84:	bf18      	it	ne
 c005f86:	2301      	movne	r3, #1
 c005f88:	0692      	lsls	r2, r2, #26
 c005f8a:	d430      	bmi.n	c005fee <_printf_common+0xba>
 c005f8c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 c005f90:	4641      	mov	r1, r8
 c005f92:	4638      	mov	r0, r7
 c005f94:	47c8      	blx	r9
 c005f96:	3001      	adds	r0, #1
 c005f98:	d023      	beq.n	c005fe2 <_printf_common+0xae>
 c005f9a:	6823      	ldr	r3, [r4, #0]
 c005f9c:	341a      	adds	r4, #26
 c005f9e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c005fa2:	f003 0306 	and.w	r3, r3, #6
 c005fa6:	2b04      	cmp	r3, #4
 c005fa8:	bf0a      	itet	eq
 c005faa:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 c005fae:	2500      	movne	r5, #0
 c005fb0:	6833      	ldreq	r3, [r6, #0]
 c005fb2:	f04f 0600 	mov.w	r6, #0
 c005fb6:	bf08      	it	eq
 c005fb8:	1aed      	subeq	r5, r5, r3
 c005fba:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c005fbe:	bf08      	it	eq
 c005fc0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c005fc4:	4293      	cmp	r3, r2
 c005fc6:	bfc4      	itt	gt
 c005fc8:	1a9b      	subgt	r3, r3, r2
 c005fca:	18ed      	addgt	r5, r5, r3
 c005fcc:	42b5      	cmp	r5, r6
 c005fce:	d11a      	bne.n	c006006 <_printf_common+0xd2>
 c005fd0:	2000      	movs	r0, #0
 c005fd2:	e008      	b.n	c005fe6 <_printf_common+0xb2>
 c005fd4:	2301      	movs	r3, #1
 c005fd6:	4652      	mov	r2, sl
 c005fd8:	4641      	mov	r1, r8
 c005fda:	4638      	mov	r0, r7
 c005fdc:	47c8      	blx	r9
 c005fde:	3001      	adds	r0, #1
 c005fe0:	d103      	bne.n	c005fea <_printf_common+0xb6>
 c005fe2:	f04f 30ff 	mov.w	r0, #4294967295
 c005fe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c005fea:	3501      	adds	r5, #1
 c005fec:	e7c1      	b.n	c005f72 <_printf_common+0x3e>
 c005fee:	18e1      	adds	r1, r4, r3
 c005ff0:	1c5a      	adds	r2, r3, #1
 c005ff2:	2030      	movs	r0, #48	@ 0x30
 c005ff4:	3302      	adds	r3, #2
 c005ff6:	4422      	add	r2, r4
 c005ff8:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 c005ffc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 c006000:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 c006004:	e7c2      	b.n	c005f8c <_printf_common+0x58>
 c006006:	2301      	movs	r3, #1
 c006008:	4622      	mov	r2, r4
 c00600a:	4641      	mov	r1, r8
 c00600c:	4638      	mov	r0, r7
 c00600e:	47c8      	blx	r9
 c006010:	3001      	adds	r0, #1
 c006012:	d0e6      	beq.n	c005fe2 <_printf_common+0xae>
 c006014:	3601      	adds	r6, #1
 c006016:	e7d9      	b.n	c005fcc <_printf_common+0x98>

0c006018 <_printf_i>:
 c006018:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c00601c:	7e0f      	ldrb	r7, [r1, #24]
 c00601e:	4691      	mov	r9, r2
 c006020:	4680      	mov	r8, r0
 c006022:	460c      	mov	r4, r1
 c006024:	2f78      	cmp	r7, #120	@ 0x78
 c006026:	469a      	mov	sl, r3
 c006028:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 c00602a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 c00602e:	d807      	bhi.n	c006040 <_printf_i+0x28>
 c006030:	2f62      	cmp	r7, #98	@ 0x62
 c006032:	d80a      	bhi.n	c00604a <_printf_i+0x32>
 c006034:	2f00      	cmp	r7, #0
 c006036:	f000 80d1 	beq.w	c0061dc <_printf_i+0x1c4>
 c00603a:	2f58      	cmp	r7, #88	@ 0x58
 c00603c:	f000 80b8 	beq.w	c0061b0 <_printf_i+0x198>
 c006040:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c006044:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 c006048:	e03a      	b.n	c0060c0 <_printf_i+0xa8>
 c00604a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 c00604e:	2b15      	cmp	r3, #21
 c006050:	d8f6      	bhi.n	c006040 <_printf_i+0x28>
 c006052:	a101      	add	r1, pc, #4	@ (adr r1, c006058 <_printf_i+0x40>)
 c006054:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 c006058:	0c0060b1 	.word	0x0c0060b1
 c00605c:	0c0060c5 	.word	0x0c0060c5
 c006060:	0c006041 	.word	0x0c006041
 c006064:	0c006041 	.word	0x0c006041
 c006068:	0c006041 	.word	0x0c006041
 c00606c:	0c006041 	.word	0x0c006041
 c006070:	0c0060c5 	.word	0x0c0060c5
 c006074:	0c006041 	.word	0x0c006041
 c006078:	0c006041 	.word	0x0c006041
 c00607c:	0c006041 	.word	0x0c006041
 c006080:	0c006041 	.word	0x0c006041
 c006084:	0c0061c3 	.word	0x0c0061c3
 c006088:	0c0060ef 	.word	0x0c0060ef
 c00608c:	0c00617d 	.word	0x0c00617d
 c006090:	0c006041 	.word	0x0c006041
 c006094:	0c006041 	.word	0x0c006041
 c006098:	0c0061e5 	.word	0x0c0061e5
 c00609c:	0c006041 	.word	0x0c006041
 c0060a0:	0c0060ef 	.word	0x0c0060ef
 c0060a4:	0c006041 	.word	0x0c006041
 c0060a8:	0c006041 	.word	0x0c006041
 c0060ac:	0c006185 	.word	0x0c006185
 c0060b0:	6833      	ldr	r3, [r6, #0]
 c0060b2:	1d1a      	adds	r2, r3, #4
 c0060b4:	681b      	ldr	r3, [r3, #0]
 c0060b6:	6032      	str	r2, [r6, #0]
 c0060b8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c0060bc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 c0060c0:	2301      	movs	r3, #1
 c0060c2:	e09c      	b.n	c0061fe <_printf_i+0x1e6>
 c0060c4:	6833      	ldr	r3, [r6, #0]
 c0060c6:	6820      	ldr	r0, [r4, #0]
 c0060c8:	1d19      	adds	r1, r3, #4
 c0060ca:	6031      	str	r1, [r6, #0]
 c0060cc:	0606      	lsls	r6, r0, #24
 c0060ce:	d501      	bpl.n	c0060d4 <_printf_i+0xbc>
 c0060d0:	681d      	ldr	r5, [r3, #0]
 c0060d2:	e003      	b.n	c0060dc <_printf_i+0xc4>
 c0060d4:	0645      	lsls	r5, r0, #25
 c0060d6:	d5fb      	bpl.n	c0060d0 <_printf_i+0xb8>
 c0060d8:	f9b3 5000 	ldrsh.w	r5, [r3]
 c0060dc:	2d00      	cmp	r5, #0
 c0060de:	da03      	bge.n	c0060e8 <_printf_i+0xd0>
 c0060e0:	232d      	movs	r3, #45	@ 0x2d
 c0060e2:	426d      	negs	r5, r5
 c0060e4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c0060e8:	4858      	ldr	r0, [pc, #352]	@ (c00624c <_printf_i+0x234>)
 c0060ea:	230a      	movs	r3, #10
 c0060ec:	e011      	b.n	c006112 <_printf_i+0xfa>
 c0060ee:	6821      	ldr	r1, [r4, #0]
 c0060f0:	6833      	ldr	r3, [r6, #0]
 c0060f2:	0608      	lsls	r0, r1, #24
 c0060f4:	f853 5b04 	ldr.w	r5, [r3], #4
 c0060f8:	d402      	bmi.n	c006100 <_printf_i+0xe8>
 c0060fa:	0649      	lsls	r1, r1, #25
 c0060fc:	bf48      	it	mi
 c0060fe:	b2ad      	uxthmi	r5, r5
 c006100:	2f6f      	cmp	r7, #111	@ 0x6f
 c006102:	6033      	str	r3, [r6, #0]
 c006104:	4851      	ldr	r0, [pc, #324]	@ (c00624c <_printf_i+0x234>)
 c006106:	bf14      	ite	ne
 c006108:	230a      	movne	r3, #10
 c00610a:	2308      	moveq	r3, #8
 c00610c:	2100      	movs	r1, #0
 c00610e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 c006112:	6866      	ldr	r6, [r4, #4]
 c006114:	2e00      	cmp	r6, #0
 c006116:	60a6      	str	r6, [r4, #8]
 c006118:	db05      	blt.n	c006126 <_printf_i+0x10e>
 c00611a:	6821      	ldr	r1, [r4, #0]
 c00611c:	432e      	orrs	r6, r5
 c00611e:	f021 0104 	bic.w	r1, r1, #4
 c006122:	6021      	str	r1, [r4, #0]
 c006124:	d04b      	beq.n	c0061be <_printf_i+0x1a6>
 c006126:	4616      	mov	r6, r2
 c006128:	fbb5 f1f3 	udiv	r1, r5, r3
 c00612c:	fb03 5711 	mls	r7, r3, r1, r5
 c006130:	5dc7      	ldrb	r7, [r0, r7]
 c006132:	f806 7d01 	strb.w	r7, [r6, #-1]!
 c006136:	462f      	mov	r7, r5
 c006138:	460d      	mov	r5, r1
 c00613a:	42bb      	cmp	r3, r7
 c00613c:	d9f4      	bls.n	c006128 <_printf_i+0x110>
 c00613e:	2b08      	cmp	r3, #8
 c006140:	d10b      	bne.n	c00615a <_printf_i+0x142>
 c006142:	6823      	ldr	r3, [r4, #0]
 c006144:	07df      	lsls	r7, r3, #31
 c006146:	d508      	bpl.n	c00615a <_printf_i+0x142>
 c006148:	6923      	ldr	r3, [r4, #16]
 c00614a:	6861      	ldr	r1, [r4, #4]
 c00614c:	4299      	cmp	r1, r3
 c00614e:	bfde      	ittt	le
 c006150:	2330      	movle	r3, #48	@ 0x30
 c006152:	f806 3c01 	strble.w	r3, [r6, #-1]
 c006156:	f106 36ff 	addle.w	r6, r6, #4294967295
 c00615a:	1b92      	subs	r2, r2, r6
 c00615c:	6122      	str	r2, [r4, #16]
 c00615e:	464b      	mov	r3, r9
 c006160:	aa03      	add	r2, sp, #12
 c006162:	4621      	mov	r1, r4
 c006164:	4640      	mov	r0, r8
 c006166:	f8cd a000 	str.w	sl, [sp]
 c00616a:	f7ff fee3 	bl	c005f34 <_printf_common>
 c00616e:	3001      	adds	r0, #1
 c006170:	d14a      	bne.n	c006208 <_printf_i+0x1f0>
 c006172:	f04f 30ff 	mov.w	r0, #4294967295
 c006176:	b004      	add	sp, #16
 c006178:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00617c:	6823      	ldr	r3, [r4, #0]
 c00617e:	f043 0320 	orr.w	r3, r3, #32
 c006182:	6023      	str	r3, [r4, #0]
 c006184:	2778      	movs	r7, #120	@ 0x78
 c006186:	4832      	ldr	r0, [pc, #200]	@ (c006250 <_printf_i+0x238>)
 c006188:	6823      	ldr	r3, [r4, #0]
 c00618a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 c00618e:	061f      	lsls	r7, r3, #24
 c006190:	6831      	ldr	r1, [r6, #0]
 c006192:	f851 5b04 	ldr.w	r5, [r1], #4
 c006196:	d402      	bmi.n	c00619e <_printf_i+0x186>
 c006198:	065f      	lsls	r7, r3, #25
 c00619a:	bf48      	it	mi
 c00619c:	b2ad      	uxthmi	r5, r5
 c00619e:	6031      	str	r1, [r6, #0]
 c0061a0:	07d9      	lsls	r1, r3, #31
 c0061a2:	bf44      	itt	mi
 c0061a4:	f043 0320 	orrmi.w	r3, r3, #32
 c0061a8:	6023      	strmi	r3, [r4, #0]
 c0061aa:	b11d      	cbz	r5, c0061b4 <_printf_i+0x19c>
 c0061ac:	2310      	movs	r3, #16
 c0061ae:	e7ad      	b.n	c00610c <_printf_i+0xf4>
 c0061b0:	4826      	ldr	r0, [pc, #152]	@ (c00624c <_printf_i+0x234>)
 c0061b2:	e7e9      	b.n	c006188 <_printf_i+0x170>
 c0061b4:	6823      	ldr	r3, [r4, #0]
 c0061b6:	f023 0320 	bic.w	r3, r3, #32
 c0061ba:	6023      	str	r3, [r4, #0]
 c0061bc:	e7f6      	b.n	c0061ac <_printf_i+0x194>
 c0061be:	4616      	mov	r6, r2
 c0061c0:	e7bd      	b.n	c00613e <_printf_i+0x126>
 c0061c2:	6833      	ldr	r3, [r6, #0]
 c0061c4:	6825      	ldr	r5, [r4, #0]
 c0061c6:	1d18      	adds	r0, r3, #4
 c0061c8:	6961      	ldr	r1, [r4, #20]
 c0061ca:	6030      	str	r0, [r6, #0]
 c0061cc:	062e      	lsls	r6, r5, #24
 c0061ce:	681b      	ldr	r3, [r3, #0]
 c0061d0:	d501      	bpl.n	c0061d6 <_printf_i+0x1be>
 c0061d2:	6019      	str	r1, [r3, #0]
 c0061d4:	e002      	b.n	c0061dc <_printf_i+0x1c4>
 c0061d6:	0668      	lsls	r0, r5, #25
 c0061d8:	d5fb      	bpl.n	c0061d2 <_printf_i+0x1ba>
 c0061da:	8019      	strh	r1, [r3, #0]
 c0061dc:	2300      	movs	r3, #0
 c0061de:	4616      	mov	r6, r2
 c0061e0:	6123      	str	r3, [r4, #16]
 c0061e2:	e7bc      	b.n	c00615e <_printf_i+0x146>
 c0061e4:	6833      	ldr	r3, [r6, #0]
 c0061e6:	2100      	movs	r1, #0
 c0061e8:	1d1a      	adds	r2, r3, #4
 c0061ea:	6032      	str	r2, [r6, #0]
 c0061ec:	681e      	ldr	r6, [r3, #0]
 c0061ee:	6862      	ldr	r2, [r4, #4]
 c0061f0:	4630      	mov	r0, r6
 c0061f2:	f000 f971 	bl	c0064d8 <memchr>
 c0061f6:	b108      	cbz	r0, c0061fc <_printf_i+0x1e4>
 c0061f8:	1b80      	subs	r0, r0, r6
 c0061fa:	6060      	str	r0, [r4, #4]
 c0061fc:	6863      	ldr	r3, [r4, #4]
 c0061fe:	6123      	str	r3, [r4, #16]
 c006200:	2300      	movs	r3, #0
 c006202:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c006206:	e7aa      	b.n	c00615e <_printf_i+0x146>
 c006208:	6923      	ldr	r3, [r4, #16]
 c00620a:	4632      	mov	r2, r6
 c00620c:	4649      	mov	r1, r9
 c00620e:	4640      	mov	r0, r8
 c006210:	47d0      	blx	sl
 c006212:	3001      	adds	r0, #1
 c006214:	d0ad      	beq.n	c006172 <_printf_i+0x15a>
 c006216:	6823      	ldr	r3, [r4, #0]
 c006218:	079b      	lsls	r3, r3, #30
 c00621a:	d413      	bmi.n	c006244 <_printf_i+0x22c>
 c00621c:	68e0      	ldr	r0, [r4, #12]
 c00621e:	9b03      	ldr	r3, [sp, #12]
 c006220:	4298      	cmp	r0, r3
 c006222:	bfb8      	it	lt
 c006224:	4618      	movlt	r0, r3
 c006226:	e7a6      	b.n	c006176 <_printf_i+0x15e>
 c006228:	2301      	movs	r3, #1
 c00622a:	4632      	mov	r2, r6
 c00622c:	4649      	mov	r1, r9
 c00622e:	4640      	mov	r0, r8
 c006230:	47d0      	blx	sl
 c006232:	3001      	adds	r0, #1
 c006234:	d09d      	beq.n	c006172 <_printf_i+0x15a>
 c006236:	3501      	adds	r5, #1
 c006238:	68e3      	ldr	r3, [r4, #12]
 c00623a:	9903      	ldr	r1, [sp, #12]
 c00623c:	1a5b      	subs	r3, r3, r1
 c00623e:	42ab      	cmp	r3, r5
 c006240:	dcf2      	bgt.n	c006228 <_printf_i+0x210>
 c006242:	e7eb      	b.n	c00621c <_printf_i+0x204>
 c006244:	2500      	movs	r5, #0
 c006246:	f104 0619 	add.w	r6, r4, #25
 c00624a:	e7f5      	b.n	c006238 <_printf_i+0x220>
 c00624c:	0c006d68 	.word	0x0c006d68
 c006250:	0c006d79 	.word	0x0c006d79

0c006254 <__sflush_r>:
 c006254:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 c006258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00625c:	0716      	lsls	r6, r2, #28
 c00625e:	4605      	mov	r5, r0
 c006260:	460c      	mov	r4, r1
 c006262:	d454      	bmi.n	c00630e <__sflush_r+0xba>
 c006264:	684b      	ldr	r3, [r1, #4]
 c006266:	2b00      	cmp	r3, #0
 c006268:	dc02      	bgt.n	c006270 <__sflush_r+0x1c>
 c00626a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 c00626c:	2b00      	cmp	r3, #0
 c00626e:	dd48      	ble.n	c006302 <__sflush_r+0xae>
 c006270:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c006272:	2e00      	cmp	r6, #0
 c006274:	d045      	beq.n	c006302 <__sflush_r+0xae>
 c006276:	2300      	movs	r3, #0
 c006278:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 c00627c:	682f      	ldr	r7, [r5, #0]
 c00627e:	6a21      	ldr	r1, [r4, #32]
 c006280:	602b      	str	r3, [r5, #0]
 c006282:	d030      	beq.n	c0062e6 <__sflush_r+0x92>
 c006284:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 c006286:	89a3      	ldrh	r3, [r4, #12]
 c006288:	0759      	lsls	r1, r3, #29
 c00628a:	d505      	bpl.n	c006298 <__sflush_r+0x44>
 c00628c:	6863      	ldr	r3, [r4, #4]
 c00628e:	1ad2      	subs	r2, r2, r3
 c006290:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c006292:	b10b      	cbz	r3, c006298 <__sflush_r+0x44>
 c006294:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c006296:	1ad2      	subs	r2, r2, r3
 c006298:	2300      	movs	r3, #0
 c00629a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c00629c:	6a21      	ldr	r1, [r4, #32]
 c00629e:	4628      	mov	r0, r5
 c0062a0:	47b0      	blx	r6
 c0062a2:	1c43      	adds	r3, r0, #1
 c0062a4:	89a3      	ldrh	r3, [r4, #12]
 c0062a6:	d106      	bne.n	c0062b6 <__sflush_r+0x62>
 c0062a8:	6829      	ldr	r1, [r5, #0]
 c0062aa:	291d      	cmp	r1, #29
 c0062ac:	d82b      	bhi.n	c006306 <__sflush_r+0xb2>
 c0062ae:	4a2a      	ldr	r2, [pc, #168]	@ (c006358 <__sflush_r+0x104>)
 c0062b0:	40ca      	lsrs	r2, r1
 c0062b2:	07d6      	lsls	r6, r2, #31
 c0062b4:	d527      	bpl.n	c006306 <__sflush_r+0xb2>
 c0062b6:	2200      	movs	r2, #0
 c0062b8:	04d9      	lsls	r1, r3, #19
 c0062ba:	6062      	str	r2, [r4, #4]
 c0062bc:	6922      	ldr	r2, [r4, #16]
 c0062be:	6022      	str	r2, [r4, #0]
 c0062c0:	d504      	bpl.n	c0062cc <__sflush_r+0x78>
 c0062c2:	1c42      	adds	r2, r0, #1
 c0062c4:	d101      	bne.n	c0062ca <__sflush_r+0x76>
 c0062c6:	682b      	ldr	r3, [r5, #0]
 c0062c8:	b903      	cbnz	r3, c0062cc <__sflush_r+0x78>
 c0062ca:	6560      	str	r0, [r4, #84]	@ 0x54
 c0062cc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c0062ce:	602f      	str	r7, [r5, #0]
 c0062d0:	b1b9      	cbz	r1, c006302 <__sflush_r+0xae>
 c0062d2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c0062d6:	4299      	cmp	r1, r3
 c0062d8:	d002      	beq.n	c0062e0 <__sflush_r+0x8c>
 c0062da:	4628      	mov	r0, r5
 c0062dc:	f7ff fc9e 	bl	c005c1c <_free_r>
 c0062e0:	2300      	movs	r3, #0
 c0062e2:	6363      	str	r3, [r4, #52]	@ 0x34
 c0062e4:	e00d      	b.n	c006302 <__sflush_r+0xae>
 c0062e6:	2301      	movs	r3, #1
 c0062e8:	4628      	mov	r0, r5
 c0062ea:	47b0      	blx	r6
 c0062ec:	4602      	mov	r2, r0
 c0062ee:	1c50      	adds	r0, r2, #1
 c0062f0:	d1c9      	bne.n	c006286 <__sflush_r+0x32>
 c0062f2:	682b      	ldr	r3, [r5, #0]
 c0062f4:	2b00      	cmp	r3, #0
 c0062f6:	d0c6      	beq.n	c006286 <__sflush_r+0x32>
 c0062f8:	2b1d      	cmp	r3, #29
 c0062fa:	d001      	beq.n	c006300 <__sflush_r+0xac>
 c0062fc:	2b16      	cmp	r3, #22
 c0062fe:	d11d      	bne.n	c00633c <__sflush_r+0xe8>
 c006300:	602f      	str	r7, [r5, #0]
 c006302:	2000      	movs	r0, #0
 c006304:	e021      	b.n	c00634a <__sflush_r+0xf6>
 c006306:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c00630a:	b21b      	sxth	r3, r3
 c00630c:	e01a      	b.n	c006344 <__sflush_r+0xf0>
 c00630e:	690f      	ldr	r7, [r1, #16]
 c006310:	2f00      	cmp	r7, #0
 c006312:	d0f6      	beq.n	c006302 <__sflush_r+0xae>
 c006314:	0793      	lsls	r3, r2, #30
 c006316:	680e      	ldr	r6, [r1, #0]
 c006318:	600f      	str	r7, [r1, #0]
 c00631a:	bf0c      	ite	eq
 c00631c:	694b      	ldreq	r3, [r1, #20]
 c00631e:	2300      	movne	r3, #0
 c006320:	eba6 0807 	sub.w	r8, r6, r7
 c006324:	608b      	str	r3, [r1, #8]
 c006326:	f1b8 0f00 	cmp.w	r8, #0
 c00632a:	ddea      	ble.n	c006302 <__sflush_r+0xae>
 c00632c:	4643      	mov	r3, r8
 c00632e:	463a      	mov	r2, r7
 c006330:	6a21      	ldr	r1, [r4, #32]
 c006332:	4628      	mov	r0, r5
 c006334:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 c006336:	47b0      	blx	r6
 c006338:	2800      	cmp	r0, #0
 c00633a:	dc08      	bgt.n	c00634e <__sflush_r+0xfa>
 c00633c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c006340:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c006344:	f04f 30ff 	mov.w	r0, #4294967295
 c006348:	81a3      	strh	r3, [r4, #12]
 c00634a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c00634e:	4407      	add	r7, r0
 c006350:	eba8 0800 	sub.w	r8, r8, r0
 c006354:	e7e7      	b.n	c006326 <__sflush_r+0xd2>
 c006356:	bf00      	nop
 c006358:	20400001 	.word	0x20400001

0c00635c <_fflush_r>:
 c00635c:	b538      	push	{r3, r4, r5, lr}
 c00635e:	690b      	ldr	r3, [r1, #16]
 c006360:	4605      	mov	r5, r0
 c006362:	460c      	mov	r4, r1
 c006364:	b913      	cbnz	r3, c00636c <_fflush_r+0x10>
 c006366:	2500      	movs	r5, #0
 c006368:	4628      	mov	r0, r5
 c00636a:	bd38      	pop	{r3, r4, r5, pc}
 c00636c:	b118      	cbz	r0, c006376 <_fflush_r+0x1a>
 c00636e:	6a03      	ldr	r3, [r0, #32]
 c006370:	b90b      	cbnz	r3, c006376 <_fflush_r+0x1a>
 c006372:	f7ff fa0b 	bl	c00578c <__sinit>
 c006376:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c00637a:	2b00      	cmp	r3, #0
 c00637c:	d0f3      	beq.n	c006366 <_fflush_r+0xa>
 c00637e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 c006380:	07d0      	lsls	r0, r2, #31
 c006382:	d404      	bmi.n	c00638e <_fflush_r+0x32>
 c006384:	0599      	lsls	r1, r3, #22
 c006386:	d402      	bmi.n	c00638e <_fflush_r+0x32>
 c006388:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c00638a:	f7ff fc1a 	bl	c005bc2 <__retarget_lock_acquire_recursive>
 c00638e:	4628      	mov	r0, r5
 c006390:	4621      	mov	r1, r4
 c006392:	f7ff ff5f 	bl	c006254 <__sflush_r>
 c006396:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c006398:	4605      	mov	r5, r0
 c00639a:	07da      	lsls	r2, r3, #31
 c00639c:	d4e4      	bmi.n	c006368 <_fflush_r+0xc>
 c00639e:	89a3      	ldrh	r3, [r4, #12]
 c0063a0:	059b      	lsls	r3, r3, #22
 c0063a2:	d4e1      	bmi.n	c006368 <_fflush_r+0xc>
 c0063a4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c0063a6:	f7ff fc0d 	bl	c005bc4 <__retarget_lock_release_recursive>
 c0063aa:	e7dd      	b.n	c006368 <_fflush_r+0xc>

0c0063ac <fiprintf>:
 c0063ac:	b40e      	push	{r1, r2, r3}
 c0063ae:	b503      	push	{r0, r1, lr}
 c0063b0:	ab03      	add	r3, sp, #12
 c0063b2:	4601      	mov	r1, r0
 c0063b4:	4805      	ldr	r0, [pc, #20]	@ (c0063cc <fiprintf+0x20>)
 c0063b6:	f853 2b04 	ldr.w	r2, [r3], #4
 c0063ba:	6800      	ldr	r0, [r0, #0]
 c0063bc:	9301      	str	r3, [sp, #4]
 c0063be:	f7ff fca1 	bl	c005d04 <_vfiprintf_r>
 c0063c2:	b002      	add	sp, #8
 c0063c4:	f85d eb04 	ldr.w	lr, [sp], #4
 c0063c8:	b003      	add	sp, #12
 c0063ca:	4770      	bx	lr
 c0063cc:	3000004c 	.word	0x3000004c

0c0063d0 <__swhatbuf_r>:
 c0063d0:	b570      	push	{r4, r5, r6, lr}
 c0063d2:	460c      	mov	r4, r1
 c0063d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0063d8:	b096      	sub	sp, #88	@ 0x58
 c0063da:	4615      	mov	r5, r2
 c0063dc:	2900      	cmp	r1, #0
 c0063de:	461e      	mov	r6, r3
 c0063e0:	da0c      	bge.n	c0063fc <__swhatbuf_r+0x2c>
 c0063e2:	89a3      	ldrh	r3, [r4, #12]
 c0063e4:	2100      	movs	r1, #0
 c0063e6:	f013 0f80 	tst.w	r3, #128	@ 0x80
 c0063ea:	bf14      	ite	ne
 c0063ec:	2340      	movne	r3, #64	@ 0x40
 c0063ee:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 c0063f2:	2000      	movs	r0, #0
 c0063f4:	6031      	str	r1, [r6, #0]
 c0063f6:	602b      	str	r3, [r5, #0]
 c0063f8:	b016      	add	sp, #88	@ 0x58
 c0063fa:	bd70      	pop	{r4, r5, r6, pc}
 c0063fc:	466a      	mov	r2, sp
 c0063fe:	f000 f849 	bl	c006494 <_fstat_r>
 c006402:	2800      	cmp	r0, #0
 c006404:	dbed      	blt.n	c0063e2 <__swhatbuf_r+0x12>
 c006406:	9901      	ldr	r1, [sp, #4]
 c006408:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 c00640c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 c006410:	4259      	negs	r1, r3
 c006412:	4159      	adcs	r1, r3
 c006414:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 c006418:	e7eb      	b.n	c0063f2 <__swhatbuf_r+0x22>

0c00641a <__smakebuf_r>:
 c00641a:	898b      	ldrh	r3, [r1, #12]
 c00641c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c00641e:	079d      	lsls	r5, r3, #30
 c006420:	4606      	mov	r6, r0
 c006422:	460c      	mov	r4, r1
 c006424:	d507      	bpl.n	c006436 <__smakebuf_r+0x1c>
 c006426:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 c00642a:	6023      	str	r3, [r4, #0]
 c00642c:	6123      	str	r3, [r4, #16]
 c00642e:	2301      	movs	r3, #1
 c006430:	6163      	str	r3, [r4, #20]
 c006432:	b003      	add	sp, #12
 c006434:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c006436:	ab01      	add	r3, sp, #4
 c006438:	466a      	mov	r2, sp
 c00643a:	f7ff ffc9 	bl	c0063d0 <__swhatbuf_r>
 c00643e:	9f00      	ldr	r7, [sp, #0]
 c006440:	4605      	mov	r5, r0
 c006442:	4630      	mov	r0, r6
 c006444:	4639      	mov	r1, r7
 c006446:	f7ff f81d 	bl	c005484 <_malloc_r>
 c00644a:	b948      	cbnz	r0, c006460 <__smakebuf_r+0x46>
 c00644c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c006450:	059a      	lsls	r2, r3, #22
 c006452:	d4ee      	bmi.n	c006432 <__smakebuf_r+0x18>
 c006454:	f023 0303 	bic.w	r3, r3, #3
 c006458:	f043 0302 	orr.w	r3, r3, #2
 c00645c:	81a3      	strh	r3, [r4, #12]
 c00645e:	e7e2      	b.n	c006426 <__smakebuf_r+0xc>
 c006460:	89a3      	ldrh	r3, [r4, #12]
 c006462:	6020      	str	r0, [r4, #0]
 c006464:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c006468:	81a3      	strh	r3, [r4, #12]
 c00646a:	9b01      	ldr	r3, [sp, #4]
 c00646c:	e9c4 0704 	strd	r0, r7, [r4, #16]
 c006470:	b15b      	cbz	r3, c00648a <__smakebuf_r+0x70>
 c006472:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c006476:	4630      	mov	r0, r6
 c006478:	f000 f81e 	bl	c0064b8 <_isatty_r>
 c00647c:	b128      	cbz	r0, c00648a <__smakebuf_r+0x70>
 c00647e:	89a3      	ldrh	r3, [r4, #12]
 c006480:	f023 0303 	bic.w	r3, r3, #3
 c006484:	f043 0301 	orr.w	r3, r3, #1
 c006488:	81a3      	strh	r3, [r4, #12]
 c00648a:	89a3      	ldrh	r3, [r4, #12]
 c00648c:	431d      	orrs	r5, r3
 c00648e:	81a5      	strh	r5, [r4, #12]
 c006490:	e7cf      	b.n	c006432 <__smakebuf_r+0x18>
	...

0c006494 <_fstat_r>:
 c006494:	b538      	push	{r3, r4, r5, lr}
 c006496:	2300      	movs	r3, #0
 c006498:	4d06      	ldr	r5, [pc, #24]	@ (c0064b4 <_fstat_r+0x20>)
 c00649a:	4604      	mov	r4, r0
 c00649c:	4608      	mov	r0, r1
 c00649e:	4611      	mov	r1, r2
 c0064a0:	602b      	str	r3, [r5, #0]
 c0064a2:	f7fd f92d 	bl	c003700 <_fstat>
 c0064a6:	1c43      	adds	r3, r0, #1
 c0064a8:	d102      	bne.n	c0064b0 <_fstat_r+0x1c>
 c0064aa:	682b      	ldr	r3, [r5, #0]
 c0064ac:	b103      	cbz	r3, c0064b0 <_fstat_r+0x1c>
 c0064ae:	6023      	str	r3, [r4, #0]
 c0064b0:	bd38      	pop	{r3, r4, r5, pc}
 c0064b2:	bf00      	nop
 c0064b4:	3000341c 	.word	0x3000341c

0c0064b8 <_isatty_r>:
 c0064b8:	b538      	push	{r3, r4, r5, lr}
 c0064ba:	2300      	movs	r3, #0
 c0064bc:	4d05      	ldr	r5, [pc, #20]	@ (c0064d4 <_isatty_r+0x1c>)
 c0064be:	4604      	mov	r4, r0
 c0064c0:	4608      	mov	r0, r1
 c0064c2:	602b      	str	r3, [r5, #0]
 c0064c4:	f7fd f92c 	bl	c003720 <_isatty>
 c0064c8:	1c43      	adds	r3, r0, #1
 c0064ca:	d102      	bne.n	c0064d2 <_isatty_r+0x1a>
 c0064cc:	682b      	ldr	r3, [r5, #0]
 c0064ce:	b103      	cbz	r3, c0064d2 <_isatty_r+0x1a>
 c0064d0:	6023      	str	r3, [r4, #0]
 c0064d2:	bd38      	pop	{r3, r4, r5, pc}
 c0064d4:	3000341c 	.word	0x3000341c

0c0064d8 <memchr>:
 c0064d8:	b2c9      	uxtb	r1, r1
 c0064da:	4603      	mov	r3, r0
 c0064dc:	4402      	add	r2, r0
 c0064de:	b510      	push	{r4, lr}
 c0064e0:	4293      	cmp	r3, r2
 c0064e2:	4618      	mov	r0, r3
 c0064e4:	d101      	bne.n	c0064ea <memchr+0x12>
 c0064e6:	2000      	movs	r0, #0
 c0064e8:	e003      	b.n	c0064f2 <memchr+0x1a>
 c0064ea:	7804      	ldrb	r4, [r0, #0]
 c0064ec:	3301      	adds	r3, #1
 c0064ee:	428c      	cmp	r4, r1
 c0064f0:	d1f6      	bne.n	c0064e0 <memchr+0x8>
 c0064f2:	bd10      	pop	{r4, pc}

0c0064f4 <abort>:
 c0064f4:	2006      	movs	r0, #6
 c0064f6:	b508      	push	{r3, lr}
 c0064f8:	f000 f82c 	bl	c006554 <raise>
 c0064fc:	2001      	movs	r0, #1
 c0064fe:	f7fd f8af 	bl	c003660 <_exit>

0c006502 <_raise_r>:
 c006502:	291f      	cmp	r1, #31
 c006504:	b538      	push	{r3, r4, r5, lr}
 c006506:	4605      	mov	r5, r0
 c006508:	460c      	mov	r4, r1
 c00650a:	d904      	bls.n	c006516 <_raise_r+0x14>
 c00650c:	2316      	movs	r3, #22
 c00650e:	6003      	str	r3, [r0, #0]
 c006510:	f04f 30ff 	mov.w	r0, #4294967295
 c006514:	bd38      	pop	{r3, r4, r5, pc}
 c006516:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 c006518:	b112      	cbz	r2, c006520 <_raise_r+0x1e>
 c00651a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 c00651e:	b94b      	cbnz	r3, c006534 <_raise_r+0x32>
 c006520:	4628      	mov	r0, r5
 c006522:	f000 f831 	bl	c006588 <_getpid_r>
 c006526:	4622      	mov	r2, r4
 c006528:	4601      	mov	r1, r0
 c00652a:	4628      	mov	r0, r5
 c00652c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c006530:	f000 b818 	b.w	c006564 <_kill_r>
 c006534:	2b01      	cmp	r3, #1
 c006536:	d00a      	beq.n	c00654e <_raise_r+0x4c>
 c006538:	1c59      	adds	r1, r3, #1
 c00653a:	d103      	bne.n	c006544 <_raise_r+0x42>
 c00653c:	2316      	movs	r3, #22
 c00653e:	6003      	str	r3, [r0, #0]
 c006540:	2001      	movs	r0, #1
 c006542:	e7e7      	b.n	c006514 <_raise_r+0x12>
 c006544:	2100      	movs	r1, #0
 c006546:	4620      	mov	r0, r4
 c006548:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 c00654c:	4798      	blx	r3
 c00654e:	2000      	movs	r0, #0
 c006550:	e7e0      	b.n	c006514 <_raise_r+0x12>
	...

0c006554 <raise>:
 c006554:	4b02      	ldr	r3, [pc, #8]	@ (c006560 <raise+0xc>)
 c006556:	4601      	mov	r1, r0
 c006558:	6818      	ldr	r0, [r3, #0]
 c00655a:	f7ff bfd2 	b.w	c006502 <_raise_r>
 c00655e:	bf00      	nop
 c006560:	3000004c 	.word	0x3000004c

0c006564 <_kill_r>:
 c006564:	b538      	push	{r3, r4, r5, lr}
 c006566:	2300      	movs	r3, #0
 c006568:	4d06      	ldr	r5, [pc, #24]	@ (c006584 <_kill_r+0x20>)
 c00656a:	4604      	mov	r4, r0
 c00656c:	4608      	mov	r0, r1
 c00656e:	4611      	mov	r1, r2
 c006570:	602b      	str	r3, [r5, #0]
 c006572:	f7fd f865 	bl	c003640 <_kill>
 c006576:	1c43      	adds	r3, r0, #1
 c006578:	d102      	bne.n	c006580 <_kill_r+0x1c>
 c00657a:	682b      	ldr	r3, [r5, #0]
 c00657c:	b103      	cbz	r3, c006580 <_kill_r+0x1c>
 c00657e:	6023      	str	r3, [r4, #0]
 c006580:	bd38      	pop	{r3, r4, r5, pc}
 c006582:	bf00      	nop
 c006584:	3000341c 	.word	0x3000341c

0c006588 <_getpid_r>:
 c006588:	f7fd b852 	b.w	c003630 <_getpid>

0c00658c <_init>:
 c00658c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00658e:	bf00      	nop
 c006590:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c006592:	bc08      	pop	{r3}
 c006594:	469e      	mov	lr, r3
 c006596:	4770      	bx	lr

0c006598 <_fini>:
 c006598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00659a:	bf00      	nop
 c00659c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c00659e:	bc08      	pop	{r3}
 c0065a0:	469e      	mov	lr, r3
 c0065a2:	4770      	bx	lr
 c0065a4:	0000      	movs	r0, r0
	...

Disassembly of section .gnu.sgstubs:

0c03e000 <SECURE_RegisterPrintCallback>:
 c03e000:	e97f e97f 	sg
 c03e004:	f7c3 bb22 	b.w	c00164c <__acle_se_SECURE_RegisterPrintCallback>

0c03e008 <Secure_WriteFlash_128KB_2>:
 c03e008:	e97f e97f 	sg
 c03e00c:	f7c4 be98 	b.w	c002d40 <__acle_se_Secure_WriteFlash_128KB_2>

0c03e010 <SecureInit_DePrioritizeNSExceptions>:
 c03e010:	e97f e97f 	sg
 c03e014:	f7c7 b966 	b.w	c0052e4 <__acle_se_SecureInit_DePrioritizeNSExceptions>

0c03e018 <SECURE_SystemCoreClockUpdate>:
 c03e018:	e97f e97f 	sg
 c03e01c:	f7c5 bd8c 	b.w	c003b38 <__acle_se_SECURE_SystemCoreClockUpdate>

0c03e020 <SecureContext_AllocateContext>:
 c03e020:	e97f e97f 	sg
 c03e024:	f7c6 be47 	b.w	c004cb6 <__acle_se_SecureContext_AllocateContext>

0c03e028 <Secure_WriteFlash_128KB>:
 c03e028:	e97f e97f 	sg
 c03e02c:	f7c4 bd68 	b.w	c002b00 <__acle_se_Secure_WriteFlash_128KB>

0c03e030 <SECURE_SMARM>:
 c03e030:	e97f e97f 	sg
 c03e034:	f7c4 b844 	b.w	c0020c0 <__acle_se_SECURE_SMARM>

0c03e038 <SECURE_ShuffledHMAC>:
 c03e038:	e97f e97f 	sg
 c03e03c:	f7c3 bd9e 	b.w	c001b7c <__acle_se_SECURE_ShuffledHMAC>

0c03e040 <SECURE_LEDToggle>:
 c03e040:	e97f e97f 	sg
 c03e044:	f7c3 bbe6 	b.w	c001814 <__acle_se_SECURE_LEDToggle>

0c03e048 <SECURE_ShuffledHMAC_secure>:
 c03e048:	e97f e97f 	sg
 c03e04c:	f7c3 bf54 	b.w	c001ef8 <__acle_se_SECURE_ShuffledHMAC_secure>

0c03e050 <Secure_Flash256KB>:
 c03e050:	e97f e97f 	sg
 c03e054:	f7c4 bf94 	b.w	c002f80 <__acle_se_Secure_Flash256KB>

0c03e058 <SecureContext_Init>:
 c03e058:	e97f e97f 	sg
 c03e05c:	f7c6 bde0 	b.w	c004c20 <__acle_se_SecureContext_Init>

0c03e060 <SECURE_LinearHMAC>:
 c03e060:	e97f e97f 	sg
 c03e064:	f7c3 bcfe 	b.w	c001a64 <__acle_se_SECURE_LinearHMAC>

0c03e068 <Secure_FlashTest>:
 c03e068:	e97f e97f 	sg
 c03e06c:	f7c4 ba54 	b.w	c002518 <__acle_se_Secure_FlashTest>

0c03e070 <Secure_EraseWriteVerify>:
 c03e070:	e97f e97f 	sg
 c03e074:	f7c4 bc14 	b.w	c0028a0 <__acle_se_Secure_EraseWriteVerify>

0c03e078 <SECURE_TEST>:
 c03e078:	e97f e97f 	sg
 c03e07c:	f7c4 b940 	b.w	c002300 <__acle_se_SECURE_TEST>

0c03e080 <SecureContext_LoadContext>:
 c03e080:	e97f e97f 	sg
 c03e084:	f7c6 bed4 	b.w	c004e30 <__acle_se_SecureContext_LoadContext>

0c03e088 <SECURE_RegisterCallback>:
 c03e088:	e97f e97f 	sg
 c03e08c:	f7c3 bb6c 	b.w	c001768 <__acle_se_SECURE_RegisterCallback>

0c03e090 <SECURE_Print>:
 c03e090:	e97f e97f 	sg
 c03e094:	f7c3 bb20 	b.w	c0016d8 <__acle_se_SECURE_Print>

0c03e098 <SecureContext_SaveContext>:
 c03e098:	e97f e97f 	sg
 c03e09c:	f7c6 bf0e 	b.w	c004ebc <__acle_se_SecureContext_SaveContext>

0c03e0a0 <SecureInit_EnableNSFPUAccess>:
 c03e0a0:	e97f e97f 	sg
 c03e0a4:	f7c7 b96c 	b.w	c005380 <__acle_se_SecureInit_EnableNSFPUAccess>

0c03e0a8 <SecureContext_FreeContext>:
 c03e0a8:	e97f e97f 	sg
 c03e0ac:	f7c6 be6a 	b.w	c004d84 <__acle_se_SecureContext_FreeContext>

0c03e0b0 <SECURE_CopyMessage>:
 c03e0b0:	e97f e97f 	sg
 c03e0b4:	f7c3 bbec 	b.w	c001890 <__acle_se_SECURE_CopyMessage>

0c03e0b8 <SECURE_ComputeHMAC>:
 c03e0b8:	e97f e97f 	sg
 c03e0bc:	f7c3 bc3e 	b.w	c00193c <__acle_se_SECURE_ComputeHMAC>
